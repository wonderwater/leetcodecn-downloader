## Usage

 ```bash
export cookie="..." ## cookie from logon leetcode-cn
java -jar leetcodecn_downloader-1.0-SNAPSHOT-jar-with-dependencies.jar
```
Generate db file(sqlite)ï¼Œand README.md file.




## My Leetcode-cn Summary
#|title|solution|topic|difficulty
--|--|--|--|--
1|[Two Sum](https://leetcode-cn.com/problems/two-sum)|[rust](#two-sum-rust),[java](#two-sum-java)|array,hash-table|Easy
2|[Add Two Numbers](https://leetcode-cn.com/problems/add-two-numbers)|[java](#add-two-numbers-java),[rust](#add-two-numbers-rust)|recursion,linked-list,math|Medium
3|[Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)|[java](#longest-substring-without-repeating-characters-java),[rust](#longest-substring-without-repeating-characters-rust)|hash-table,string,sliding-window|Medium
4|[Median of Two Sorted Arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)|[java](#median-of-two-sorted-arrays-java),[rust](#median-of-two-sorted-arrays-rust)|array,binary-search,divide-and-conquer|Hard
5|[Longest Palindromic Substring](https://leetcode-cn.com/problems/longest-palindromic-substring)|[rust](#longest-palindromic-substring-rust),[java](#longest-palindromic-substring-java)|string,dynamic-programming|Medium
6|[ZigZag Conversion](https://leetcode-cn.com/problems/zigzag-conversion)|[java](#zigzag-conversion-java)|string|Medium
7|[Reverse Integer](https://leetcode-cn.com/problems/reverse-integer)|[java](#reverse-integer-java)|math|Easy
8|[String to Integer (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi)|[java](#string-to-integer-atoi-java)|string|Medium
9|[Palindrome Number](https://leetcode-cn.com/problems/palindrome-number)|[java](#palindrome-number-java)|math|Easy
10|[Regular Expression Matching](https://leetcode-cn.com/problems/regular-expression-matching)|[rust](#regular-expression-matching-rust),[java](#regular-expression-matching-java)|recursion,string,dynamic-programming|Hard
11|[Container With Most Water](https://leetcode-cn.com/problems/container-with-most-water)|[rust](#container-with-most-water-rust),[java](#container-with-most-water-java)|greedy,array,two-pointers|Medium
12|[Integer to Roman](https://leetcode-cn.com/problems/integer-to-roman)|[java](#integer-to-roman-java)|hash-table,math,string|Medium
13|[Roman to Integer](https://leetcode-cn.com/problems/roman-to-integer)|[java](#roman-to-integer-java)|hash-table,math,string|Easy
14|[Longest Common Prefix](https://leetcode-cn.com/problems/longest-common-prefix)|[java](#longest-common-prefix-java)|string|Easy
15|[3Sum](https://leetcode-cn.com/problems/3sum)|[rust](#3sum-rust),[java](#3sum-java)|array,two-pointers,sorting|Medium
16|[3Sum Closest](https://leetcode-cn.com/problems/3sum-closest)|[java](#3sum-closest-java)|array,two-pointers,sorting|Medium
17|[Letter Combinations of a Phone Number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number)|[rust](#letter-combinations-of-a-phone-number-rust),[java](#letter-combinations-of-a-phone-number-java)|hash-table,string,backtracking|Medium
18|[4Sum](https://leetcode-cn.com/problems/4sum)|[java](#4sum-java)|array,two-pointers,sorting|Medium
19|[Remove Nth Node From End of List](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)|[java](#remove-nth-node-from-end-of-list-java),[rust](#remove-nth-node-from-end-of-list-rust)|linked-list,two-pointers|Medium
20|[Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses)|[rust](#valid-parentheses-rust),[java](#valid-parentheses-java)|stack,string|Easy
21|[Merge Two Sorted Lists](https://leetcode-cn.com/problems/merge-two-sorted-lists)|[java](#merge-two-sorted-lists-java),[rust](#merge-two-sorted-lists-rust)|recursion,linked-list|Easy
22|[Generate Parentheses](https://leetcode-cn.com/problems/generate-parentheses)|[rust](#generate-parentheses-rust),[java](#generate-parentheses-java)|string,dynamic-programming,backtracking|Medium
23|[Merge k Sorted Lists](https://leetcode-cn.com/problems/merge-k-sorted-lists)|[java](#merge-k-sorted-lists-java),[rust](#merge-k-sorted-lists-rust)|linked-list,divide-and-conquer,heap-priority-queue,merge-sort|Hard
24|[Swap Nodes in Pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs)|[rust](#swap-nodes-in-pairs-rust),[java](#swap-nodes-in-pairs-java)|recursion,linked-list|Medium
25|[Reverse Nodes in k-Group](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)|[java](#reverse-nodes-in-k-group-java)|recursion,linked-list|Hard
26|[Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)|[rust](#remove-duplicates-from-sorted-array-rust),[java](#remove-duplicates-from-sorted-array-java)|array,two-pointers|Easy
27|[Remove Element](https://leetcode-cn.com/problems/remove-element)|[java](#remove-element-java),[rust](#remove-element-rust)|array,two-pointers|Easy
28|[Implement strStr()](https://leetcode-cn.com/problems/implement-strstr)|[java](#implement-strstr-java)|two-pointers,string,string-matching|Easy
29|[Divide Two Integers](https://leetcode-cn.com/problems/divide-two-integers)|[java](#divide-two-integers-java)|bit-manipulation,math|Medium
30|[Substring with Concatenation of All Words](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words)|[java](#substring-with-concatenation-of-all-words-java)|hash-table,string,sliding-window|Hard
31|[Next Permutation](https://leetcode-cn.com/problems/next-permutation)|[java](#next-permutation-java),[rust](#next-permutation-rust)|array,two-pointers|Medium
32|[Longest Valid Parentheses](https://leetcode-cn.com/problems/longest-valid-parentheses)|[rust](#longest-valid-parentheses-rust),[java](#longest-valid-parentheses-java)|stack,string,dynamic-programming|Hard
33|[Search in Rotated Sorted Array](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)|[rust](#search-in-rotated-sorted-array-rust),[java](#search-in-rotated-sorted-array-java)|array,binary-search|Medium
34|[Find First and Last Position of Element in Sorted Array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array)|[java](#find-first-and-last-position-of-element-in-sorted-array-java),[rust](#find-first-and-last-position-of-element-in-sorted-array-rust)|array,binary-search|Medium
35|[Search Insert Position](https://leetcode-cn.com/problems/search-insert-position)|[java](#search-insert-position-java),[rust](#search-insert-position-rust)|array,binary-search|Easy
36|[Valid Sudoku](https://leetcode-cn.com/problems/valid-sudoku)|[java](#valid-sudoku-java)|array,hash-table,matrix|Medium
37|[Sudoku Solver](https://leetcode-cn.com/problems/sudoku-solver)|[java](#sudoku-solver-java)|array,backtracking,matrix|Hard
38|[Count and Say](https://leetcode-cn.com/problems/count-and-say)|[java](#count-and-say-java)|string|Medium
39|[Combination Sum](https://leetcode-cn.com/problems/combination-sum)|[java](#combination-sum-java),[rust](#combination-sum-rust)|array,backtracking|Medium
40|[Combination Sum II](https://leetcode-cn.com/problems/combination-sum-ii)|[java](#combination-sum-ii-java)|array,backtracking|Medium
41|[First Missing Positive](https://leetcode-cn.com/problems/first-missing-positive)|[java](#first-missing-positive-java)|array,hash-table|Hard
42|[Trapping Rain Water](https://leetcode-cn.com/problems/trapping-rain-water)|[java](#trapping-rain-water-java),[rust](#trapping-rain-water-rust)|stack,array,two-pointers,dynamic-programming,monotonic-stack|Hard
43|[Multiply Strings](https://leetcode-cn.com/problems/multiply-strings)|[java](#multiply-strings-java)|math,string,simulation|Medium
44|[Wildcard Matching](https://leetcode-cn.com/problems/wildcard-matching)|[java](#wildcard-matching-java)|greedy,recursion,string,dynamic-programming|Hard
45|[Jump Game II](https://leetcode-cn.com/problems/jump-game-ii)|[java](#jump-game-ii-java)|greedy,array,dynamic-programming|Medium
46|[Permutations](https://leetcode-cn.com/problems/permutations)|[java](#permutations-java),[rust](#permutations-rust)|array,backtracking|Medium
47|[Permutations II](https://leetcode-cn.com/problems/permutations-ii)|[java](#permutations-ii-java)|array,backtracking|Medium
48|[Rotate Image](https://leetcode-cn.com/problems/rotate-image)|[rust](#rotate-image-rust),[java](#rotate-image-java)|array,math,matrix|Medium
49|[Group Anagrams](https://leetcode-cn.com/problems/group-anagrams)|[java](#group-anagrams-java),[rust](#group-anagrams-rust)|hash-table,string,sorting|Medium
50|[Pow(x, n)](https://leetcode-cn.com/problems/powx-n)|[java](#powx-n-java)|recursion,math|Medium
51|[N-Queens](https://leetcode-cn.com/problems/n-queens)|[java](#n-queens-java)|array,backtracking|Hard
52|[N-Queens II](https://leetcode-cn.com/problems/n-queens-ii)|[java](#n-queens-ii-java)|backtracking|Hard
53|[Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray)|[java](#maximum-subarray-java),[rust](#maximum-subarray-rust)|array,divide-and-conquer,dynamic-programming|Easy
54|[Spiral Matrix](https://leetcode-cn.com/problems/spiral-matrix)|[java](#spiral-matrix-java)|array,matrix,simulation|Medium
55|[Jump Game](https://leetcode-cn.com/problems/jump-game)|[java](#jump-game-java),[rust](#jump-game-rust)|greedy,array,dynamic-programming|Medium
56|[Merge Intervals](https://leetcode-cn.com/problems/merge-intervals)|[java](#merge-intervals-java),[rust](#merge-intervals-rust)|array,sorting|Medium
57|[Insert Interval](https://leetcode-cn.com/problems/insert-interval)|[java](#insert-interval-java)|array|Medium
58|[Length of Last Word](https://leetcode-cn.com/problems/length-of-last-word)|[java](#length-of-last-word-java)|string|Easy
59|[Spiral Matrix II](https://leetcode-cn.com/problems/spiral-matrix-ii)|[java](#spiral-matrix-ii-java)|array,matrix,simulation|Medium
60|[Permutation Sequence](https://leetcode-cn.com/problems/permutation-sequence)|[java](#permutation-sequence-java)|recursion,math|Hard
61|[Rotate List](https://leetcode-cn.com/problems/rotate-list)|[java](#rotate-list-java)|linked-list,two-pointers|Medium
62|[Unique Paths](https://leetcode-cn.com/problems/unique-paths)|[rust](#unique-paths-rust),[java](#unique-paths-java)|math,dynamic-programming,combinatorics|Medium
63|[Unique Paths II](https://leetcode-cn.com/problems/unique-paths-ii)|[java](#unique-paths-ii-java)|array,dynamic-programming,matrix|Medium
64|[Minimum Path Sum](https://leetcode-cn.com/problems/minimum-path-sum)|[java](#minimum-path-sum-java),[rust](#minimum-path-sum-rust)|array,dynamic-programming,matrix|Medium
65|[Valid Number](https://leetcode-cn.com/problems/valid-number)|[java](#valid-number-java)|string|Hard
66|[Plus One](https://leetcode-cn.com/problems/plus-one)|[rust](#plus-one-rust),[java](#plus-one-java)|array,math|Easy
67|[Add Binary](https://leetcode-cn.com/problems/add-binary)|[java](#add-binary-java)|bit-manipulation,math,string,simulation|Easy
68|[Text Justification](https://leetcode-cn.com/problems/text-justification)|[java](#text-justification-java)|string,simulation|Hard
69|[Sqrt(x)](https://leetcode-cn.com/problems/sqrtx)|[java](#sqrtx-java)|math,binary-search|Easy
70|[Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs)|[java](#climbing-stairs-java),[rust](#climbing-stairs-rust)|memoization,math,dynamic-programming|Easy
71|[Simplify Path](https://leetcode-cn.com/problems/simplify-path)|[java](#simplify-path-java)|stack,string|Medium
72|[Edit Distance](https://leetcode-cn.com/problems/edit-distance)|[java](#edit-distance-java),[rust](#edit-distance-rust)|string,dynamic-programming|Hard
73|[Set Matrix Zeroes](https://leetcode-cn.com/problems/set-matrix-zeroes)|[java](#set-matrix-zeroes-java)|array,hash-table,matrix|Medium
74|[Search a 2D Matrix](https://leetcode-cn.com/problems/search-a-2d-matrix)|[java](#search-a-2d-matrix-java)|array,binary-search,matrix|Medium
75|[Sort Colors](https://leetcode-cn.com/problems/sort-colors)|[rust](#sort-colors-rust),[java](#sort-colors-java)|array,two-pointers,sorting|Medium
76|[Minimum Window Substring](https://leetcode-cn.com/problems/minimum-window-substring)|[rust](#minimum-window-substring-rust),[java](#minimum-window-substring-java)|hash-table,string,sliding-window|Hard
77|[Combinations](https://leetcode-cn.com/problems/combinations)|[java](#combinations-java)|array,backtracking|Medium
78|[Subsets](https://leetcode-cn.com/problems/subsets)|[rust](#subsets-rust),[java](#subsets-java)|bit-manipulation,array,backtracking|Medium
79|[Word Search](https://leetcode-cn.com/problems/word-search)|[rust](#word-search-rust),[java](#word-search-java)|array,backtracking,matrix|Medium
80|[Remove Duplicates from Sorted Array II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii)|[java](#remove-duplicates-from-sorted-array-ii-java)|array,two-pointers|Medium
81|[Search in Rotated Sorted Array II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii)|[java](#search-in-rotated-sorted-array-ii-java)|array,binary-search|Medium
82|[Remove Duplicates from Sorted List II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)|[java](#remove-duplicates-from-sorted-list-ii-java)|linked-list,two-pointers|Medium
83|[Remove Duplicates from Sorted List](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)|[java](#remove-duplicates-from-sorted-list-java)|linked-list|Easy
84|[Largest Rectangle in Histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram)|[rust](#largest-rectangle-in-histogram-rust),[java](#largest-rectangle-in-histogram-java)|stack,array,monotonic-stack|Hard
85|[Maximal Rectangle](https://leetcode-cn.com/problems/maximal-rectangle)|[rust](#maximal-rectangle-rust),[java](#maximal-rectangle-java)|stack,array,dynamic-programming,matrix,monotonic-stack|Hard
86|[Partition List](https://leetcode-cn.com/problems/partition-list)|[java](#partition-list-java)|linked-list,two-pointers|Medium
87|[Scramble String](https://leetcode-cn.com/problems/scramble-string)|[java](#scramble-string-java)|string,dynamic-programming|Hard
88|[Merge Sorted Array](https://leetcode-cn.com/problems/merge-sorted-array)|[java](#merge-sorted-array-java)|array,two-pointers,sorting|Easy
89|[Gray Code](https://leetcode-cn.com/problems/gray-code)|[java](#gray-code-java)|bit-manipulation,math,backtracking|Medium
90|[Subsets II](https://leetcode-cn.com/problems/subsets-ii)|[java](#subsets-ii-java)|bit-manipulation,array,backtracking|Medium
91|[Decode Ways](https://leetcode-cn.com/problems/decode-ways)|[java](#decode-ways-java)|string,dynamic-programming|Medium
92|[Reverse Linked List II](https://leetcode-cn.com/problems/reverse-linked-list-ii)|[java](#reverse-linked-list-ii-java)|linked-list|Medium
93|[Restore IP Addresses](https://leetcode-cn.com/problems/restore-ip-addresses)|[java](#restore-ip-addresses-java)|string,backtracking|Medium
94|[Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)|[rust](#binary-tree-inorder-traversal-rust),[java](#binary-tree-inorder-traversal-java)|stack,tree,depth-first-search,binary-tree|Easy
95|[Unique Binary Search Trees II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii)|[java](#unique-binary-search-trees-ii-java)|tree,binary-search-tree,dynamic-programming,backtracking,binary-tree|Medium
96|[Unique Binary Search Trees](https://leetcode-cn.com/problems/unique-binary-search-trees)|[java](#unique-binary-search-trees-java),[rust](#unique-binary-search-trees-rust)|tree,binary-search-tree,math,dynamic-programming,binary-tree|Medium
97|[Interleaving String](https://leetcode-cn.com/problems/interleaving-string)|[java](#interleaving-string-java)|string,dynamic-programming|Medium
98|[Validate Binary Search Tree](https://leetcode-cn.com/problems/validate-binary-search-tree)|[java](#validate-binary-search-tree-java),[rust](#validate-binary-search-tree-rust)|tree,depth-first-search,binary-search-tree,binary-tree|Medium
99|[Recover Binary Search Tree](https://leetcode-cn.com/problems/recover-binary-search-tree)|[java](#recover-binary-search-tree-java)|tree,depth-first-search,binary-search-tree,binary-tree|Medium
100|[Same Tree](https://leetcode-cn.com/problems/same-tree)|[java](#same-tree-java)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
101|[Symmetric Tree](https://leetcode-cn.com/problems/symmetric-tree)|[rust](#symmetric-tree-rust),[java](#symmetric-tree-java)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
102|[Binary Tree Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)|[rust](#binary-tree-level-order-traversal-rust),[java](#binary-tree-level-order-traversal-java)|tree,breadth-first-search,binary-tree|Medium
103|[Binary Tree Zigzag Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal)|[java](#binary-tree-zigzag-level-order-traversal-java)|tree,breadth-first-search,binary-tree|Medium
104|[Maximum Depth of Binary Tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree)|[java](#maximum-depth-of-binary-tree-java),[rust](#maximum-depth-of-binary-tree-rust)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
105|[Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)|[java](#construct-binary-tree-from-preorder-and-inorder-traversal-java),[rust](#construct-binary-tree-from-preorder-and-inorder-traversal-rust)|tree,array,hash-table,divide-and-conquer,binary-tree|Medium
106|[Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal)|[java](#construct-binary-tree-from-inorder-and-postorder-traversal-java)|tree,array,hash-table,divide-and-conquer,binary-tree|Medium
107|[Binary Tree Level Order Traversal II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii)|[java](#binary-tree-level-order-traversal-ii-java)|tree,breadth-first-search,binary-tree|Medium
108|[Convert Sorted Array to Binary Search Tree](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree)|[java](#convert-sorted-array-to-binary-search-tree-java)|tree,binary-search-tree,array,divide-and-conquer,binary-tree|Easy
109|[Convert Sorted List to Binary Search Tree](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree)|[java](#convert-sorted-list-to-binary-search-tree-java)|tree,binary-search-tree,linked-list,divide-and-conquer,binary-tree|Medium
111|[Minimum Depth of Binary Tree](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)|[java](#minimum-depth-of-binary-tree-java)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
112|[Path Sum](https://leetcode-cn.com/problems/path-sum)|[java](#path-sum-java)|tree,depth-first-search,binary-tree|Easy
113|[Path Sum II](https://leetcode-cn.com/problems/path-sum-ii)|[java](#path-sum-ii-java)|tree,depth-first-search,backtracking,binary-tree|Medium
114|[Flatten Binary Tree to Linked List](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list)|[rust](#flatten-binary-tree-to-linked-list-rust),[java](#flatten-binary-tree-to-linked-list-java)|stack,tree,depth-first-search,linked-list,binary-tree|Medium
115|[Distinct Subsequences](https://leetcode-cn.com/problems/distinct-subsequences)|[java](#distinct-subsequences-java)|string,dynamic-programming|Hard
116|[Populating Next Right Pointers in Each Node](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node)|[java](#populating-next-right-pointers-in-each-node-java)|tree,depth-first-search,breadth-first-search,binary-tree|Medium
117|[Populating Next Right Pointers in Each Node II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii)|[java](#populating-next-right-pointers-in-each-node-ii-java)|tree,depth-first-search,breadth-first-search,binary-tree|Medium
118|[Pascal's Triangle](https://leetcode-cn.com/problems/pascals-triangle)|[java](#pascals-triangle-java)|array,dynamic-programming|Easy
119|[Pascal's Triangle II](https://leetcode-cn.com/problems/pascals-triangle-ii)|[java](#pascals-triangle-ii-java)|array,dynamic-programming|Easy
121|[Best Time to Buy and Sell Stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)|[java](#best-time-to-buy-and-sell-stock-java),[rust](#best-time-to-buy-and-sell-stock-rust)|array,dynamic-programming|Easy
124|[Binary Tree Maximum Path Sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum)|[java](#binary-tree-maximum-path-sum-java),[rust](#binary-tree-maximum-path-sum-rust)|tree,depth-first-search,dynamic-programming,binary-tree|Hard
126|[Word Ladder II](https://leetcode-cn.com/problems/word-ladder-ii)|[java](#word-ladder-ii-java)|breadth-first-search,hash-table,string,backtracking|Hard
127|[Word Ladder](https://leetcode-cn.com/problems/word-ladder)|[java](#word-ladder-java)|breadth-first-search,hash-table,string|Hard
128|[Longest Consecutive Sequence](https://leetcode-cn.com/problems/longest-consecutive-sequence)|[java](#longest-consecutive-sequence-java),[rust](#longest-consecutive-sequence-rust)|union-find,array,hash-table|Medium
129|[Sum Root to Leaf Numbers](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers)|[java](#sum-root-to-leaf-numbers-java)|tree,depth-first-search,binary-tree|Medium
135|[Candy](https://leetcode-cn.com/problems/candy)|[java](#candy-java)|greedy,array|Hard
136|[Single Number](https://leetcode-cn.com/problems/single-number)|[c](#single-number-c),[rust](#single-number-rust)|bit-manipulation,array|Easy
137|[Single Number II](https://leetcode-cn.com/problems/single-number-ii)|[java](#single-number-ii-java)|bit-manipulation,array|Medium
138|[Copy List with Random Pointer](https://leetcode-cn.com/problems/copy-list-with-random-pointer)|[java](#copy-list-with-random-pointer-java)|hash-table,linked-list|Medium
139|[Word Break](https://leetcode-cn.com/problems/word-break)|[rust](#word-break-rust),[java](#word-break-java)|trie,memoization,hash-table,string,dynamic-programming|Medium
141|[Linked List Cycle](https://leetcode-cn.com/problems/linked-list-cycle)|[java](#linked-list-cycle-java)|hash-table,linked-list,two-pointers|Easy
142|[Linked List Cycle II](https://leetcode-cn.com/problems/linked-list-cycle-ii)|[java](#linked-list-cycle-ii-java)|hash-table,linked-list,two-pointers|Medium
144|[Binary Tree Preorder Traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal)|[java](#binary-tree-preorder-traversal-java)|stack,tree,depth-first-search,binary-tree|Easy
145|[Binary Tree Postorder Traversal](https://leetcode-cn.com/problems/binary-tree-postorder-traversal)|[java](#binary-tree-postorder-traversal-java)|stack,tree,depth-first-search,binary-tree|Easy
146|[LRU Cache](https://leetcode-cn.com/problems/lru-cache)|[java](#lru-cache-java),[rust](#lru-cache-rust)|design,hash-table,linked-list,doubly-linked-list|Medium
147|[Insertion Sort List](https://leetcode-cn.com/problems/insertion-sort-list)|[java](#insertion-sort-list-java)|linked-list,sorting|Medium
148|[Sort List](https://leetcode-cn.com/problems/sort-list)|[rust](#sort-list-rust),[java](#sort-list-java)|linked-list,two-pointers,divide-and-conquer,sorting,merge-sort|Medium
149|[Max Points on a Line](https://leetcode-cn.com/problems/max-points-on-a-line)|[java](#max-points-on-a-line-java)|geometry,hash-table,math|Hard
151|[Reverse Words in a String](https://leetcode-cn.com/problems/reverse-words-in-a-string)|[java](#reverse-words-in-a-string-java)|two-pointers,string|Medium
152|[Maximum Product Subarray](https://leetcode-cn.com/problems/maximum-product-subarray)|[java](#maximum-product-subarray-java),[rust](#maximum-product-subarray-rust)|array,dynamic-programming|Medium
155|[Min Stack](https://leetcode-cn.com/problems/min-stack)|[rust](#min-stack-rust),[java](#min-stack-java)|stack,design|Easy
160|[Intersection of Two Linked Lists](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)|[java](#intersection-of-two-linked-lists-java)|hash-table,linked-list,two-pointers|Easy
164|[Maximum Gap](https://leetcode-cn.com/problems/maximum-gap)|[java](#maximum-gap-java)|array,bucket-sort,radix-sort,sorting|Hard
165|[Compare Version Numbers](https://leetcode-cn.com/problems/compare-version-numbers)|[java](#compare-version-numbers-java)|two-pointers,string|Medium
166|[Fraction to Recurring Decimal](https://leetcode-cn.com/problems/fraction-to-recurring-decimal)|[java](#fraction-to-recurring-decimal-java)|hash-table,math,string|Medium
168|[Excel Sheet Column Title](https://leetcode-cn.com/problems/excel-sheet-column-title)|[java](#excel-sheet-column-title-java),[rust](#excel-sheet-column-title-rust)|math,string|Easy
169|[Majority Element](https://leetcode-cn.com/problems/majority-element)|[rust](#majority-element-rust),[java](#majority-element-java)|array,hash-table,divide-and-conquer,counting,sorting|Easy
171|[Excel Sheet Column Number](https://leetcode-cn.com/problems/excel-sheet-column-number)|[java](#excel-sheet-column-number-java)|math,string|Easy
172|[Factorial Trailing Zeroes](https://leetcode-cn.com/problems/factorial-trailing-zeroes)|[java](#factorial-trailing-zeroes-java)|math|Easy
175|[Combine Two Tables](https://leetcode-cn.com/problems/combine-two-tables)|[mysql](#combine-two-tables-mysql)|database|Easy
176|[Second Highest Salary](https://leetcode-cn.com/problems/second-highest-salary)|[mysql](#second-highest-salary-mysql)|database|Easy
178|[Rank Scores](https://leetcode-cn.com/problems/rank-scores)|[mysql](#rank-scores-mysql)|database|Medium
179|[Largest Number](https://leetcode-cn.com/problems/largest-number)|[java](#largest-number-java)|greedy,string,sorting|Medium
180|[Consecutive Numbers](https://leetcode-cn.com/problems/consecutive-numbers)|[mysql](#consecutive-numbers-mysql)|database|Medium
181|[Employees Earning More Than Their Managers](https://leetcode-cn.com/problems/employees-earning-more-than-their-managers)|[mysql](#employees-earning-more-than-their-managers-mysql)|database|Easy
182|[Duplicate Emails](https://leetcode-cn.com/problems/duplicate-emails)|[mysql](#duplicate-emails-mysql)|database|Easy
183|[Customers Who Never Order](https://leetcode-cn.com/problems/customers-who-never-order)|[mysql](#customers-who-never-order-mysql)|database|Easy
185|[Department Top Three Salaries](https://leetcode-cn.com/problems/department-top-three-salaries)||database|Hard
190|[Reverse Bits](https://leetcode-cn.com/problems/reverse-bits)|[java](#reverse-bits-java)|bit-manipulation,divide-and-conquer|Easy
191|[Number of 1 Bits](https://leetcode-cn.com/problems/number-of-1-bits)|[java](#number-of-1-bits-java),[cpp](#number-of-1-bits-cpp),[c](#number-of-1-bits-c)|bit-manipulation|Easy
195|[Tenth Line](https://leetcode-cn.com/problems/tenth-line)||shell|Easy
197|[Rising Temperature](https://leetcode-cn.com/problems/rising-temperature)|[mysql](#rising-temperature-mysql)|database|Easy
198|[House Robber](https://leetcode-cn.com/problems/house-robber)|[rust](#house-robber-rust),[java](#house-robber-java)|array,dynamic-programming|Medium
200|[Number of Islands](https://leetcode-cn.com/problems/number-of-islands)|[java](#number-of-islands-java),[rust](#number-of-islands-rust)|depth-first-search,breadth-first-search,union-find,array,matrix|Medium
202|[Happy Number](https://leetcode-cn.com/problems/happy-number)|[java](#happy-number-java)|hash-table,math,two-pointers|Easy
203|[Remove Linked List Elements](https://leetcode-cn.com/problems/remove-linked-list-elements)|[java](#remove-linked-list-elements-java),[rust](#remove-linked-list-elements-rust)|recursion,linked-list|Easy
204|[Count Primes](https://leetcode-cn.com/problems/count-primes)|[java](#count-primes-java)|array,math,enumeration,number-theory|Easy
206|[Reverse Linked List](https://leetcode-cn.com/problems/reverse-linked-list)|[rust](#reverse-linked-list-rust),[java](#reverse-linked-list-java)|recursion,linked-list|Easy
207|[Course Schedule](https://leetcode-cn.com/problems/course-schedule)|[java](#course-schedule-java),[rust](#course-schedule-rust)|depth-first-search,breadth-first-search,graph,topological-sort|Medium
208|[Implement Trie (Prefix Tree)](https://leetcode-cn.com/problems/implement-trie-prefix-tree)|[java](#implement-trie-prefix-tree-java),[rust](#implement-trie-prefix-tree-rust)|design,trie,hash-table,string|Medium
209|[Minimum Size Subarray Sum](https://leetcode-cn.com/problems/minimum-size-subarray-sum)|[java](#minimum-size-subarray-sum-java)|array,binary-search,prefix-sum,sliding-window|Medium
213|[House Robber II](https://leetcode-cn.com/problems/house-robber-ii)|[java](#house-robber-ii-java)|array,dynamic-programming|Medium
215|[Kth Largest Element in an Array](https://leetcode-cn.com/problems/kth-largest-element-in-an-array)|[rust](#kth-largest-element-in-an-array-rust),[java](#kth-largest-element-in-an-array-java)|array,divide-and-conquer,quickselect,sorting,heap-priority-queue|Medium
217|[Contains Duplicate](https://leetcode-cn.com/problems/contains-duplicate)|[java](#contains-duplicate-java)|array,hash-table,sorting|Easy
218|[The Skyline Problem](https://leetcode-cn.com/problems/the-skyline-problem)|[java](#the-skyline-problem-java)|binary-indexed-tree,segment-tree,array,divide-and-conquer,ordered-set,line-sweep,heap-priority-queue|Hard
219|[Contains Duplicate II](https://leetcode-cn.com/problems/contains-duplicate-ii)|[java](#contains-duplicate-ii-java)|array,hash-table,sliding-window|Easy
221|[Maximal Square](https://leetcode-cn.com/problems/maximal-square)|[java](#maximal-square-java),[rust](#maximal-square-rust)|array,dynamic-programming,matrix|Medium
224|[Basic Calculator](https://leetcode-cn.com/problems/basic-calculator)||stack,recursion,math,string|Hard
225|[Implement Stack using Queues](https://leetcode-cn.com/problems/implement-stack-using-queues)|[java](#implement-stack-using-queues-java)|stack,design,queue|Easy
226|[Invert Binary Tree](https://leetcode-cn.com/problems/invert-binary-tree)|[rust](#invert-binary-tree-rust),[java](#invert-binary-tree-java)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
228|[Summary Ranges](https://leetcode-cn.com/problems/summary-ranges)|[java](#summary-ranges-java)|array|Easy
229|[Majority Element II](https://leetcode-cn.com/problems/majority-element-ii)|[java](#majority-element-ii-java)|array,hash-table,counting,sorting|Medium
230|[Kth Smallest Element in a BST](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst)|[java](#kth-smallest-element-in-a-bst-java)|tree,depth-first-search,binary-search-tree,binary-tree|Medium
231|[Power of Two](https://leetcode-cn.com/problems/power-of-two)|[c](#power-of-two-c),[java](#power-of-two-java)|bit-manipulation,recursion,math|Easy
232|[Implement Queue using Stacks](https://leetcode-cn.com/problems/implement-queue-using-stacks)|[java](#implement-queue-using-stacks-java)|stack,design,queue|Easy
234|[Palindrome Linked List](https://leetcode-cn.com/problems/palindrome-linked-list)|[java](#palindrome-linked-list-java),[rust](#palindrome-linked-list-rust)|stack,recursion,linked-list,two-pointers|Easy
235|[Lowest Common Ancestor of a Binary Search Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree)|[java](#lowest-common-ancestor-of-a-binary-search-tree-java)|tree,depth-first-search,binary-search-tree,binary-tree|Easy
236|[Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree)|[java](#lowest-common-ancestor-of-a-binary-tree-java),[rust](#lowest-common-ancestor-of-a-binary-tree-rust)|tree,depth-first-search,binary-tree|Medium
237|[Delete Node in a Linked List](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)|[java](#delete-node-in-a-linked-list-java)|linked-list|Easy
238|[Product of Array Except Self](https://leetcode-cn.com/problems/product-of-array-except-self)|[rust](#product-of-array-except-self-rust),[java](#product-of-array-except-self-java)|array,prefix-sum|Medium
239|[Sliding Window Maximum](https://leetcode-cn.com/problems/sliding-window-maximum)|[java](#sliding-window-maximum-java),[rust](#sliding-window-maximum-rust)|queue,array,sliding-window,monotonic-queue,heap-priority-queue|Hard
240|[Search a 2D Matrix II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii)|[java](#search-a-2d-matrix-ii-java),[rust](#search-a-2d-matrix-ii-rust)|array,binary-search,divide-and-conquer,matrix|Medium
241|[Different Ways to Add Parentheses](https://leetcode-cn.com/problems/different-ways-to-add-parentheses)|[java](#different-ways-to-add-parentheses-java)|recursion,memoization,math,string,dynamic-programming|Medium
242|[Valid Anagram](https://leetcode-cn.com/problems/valid-anagram)|[java](#valid-anagram-java)|hash-table,string,sorting|Easy
257|[Binary Tree Paths](https://leetcode-cn.com/problems/binary-tree-paths)|[java](#binary-tree-paths-java)|tree,depth-first-search,string,binary-tree|Easy
258|[Add Digits](https://leetcode-cn.com/problems/add-digits)|[java](#add-digits-java)|math,number-theory,simulation|Easy
260|[Single Number III](https://leetcode-cn.com/problems/single-number-iii)|[java](#single-number-iii-java)|bit-manipulation,array|Medium
263|[Ugly Number](https://leetcode-cn.com/problems/ugly-number)|[java](#ugly-number-java)|math|Easy
264|[Ugly Number II](https://leetcode-cn.com/problems/ugly-number-ii)|[java](#ugly-number-ii-java)|hash-table,math,dynamic-programming,heap-priority-queue|Medium
268|[Missing Number](https://leetcode-cn.com/problems/missing-number)|[java](#missing-number-java)|bit-manipulation,array,hash-table,math,sorting|Easy
273|[Integer to English Words](https://leetcode-cn.com/problems/integer-to-english-words)|[java](#integer-to-english-words-java)|recursion,math,string|Hard
274|[H-Index](https://leetcode-cn.com/problems/h-index)|[rust](#h-index-rust),[java](#h-index-java)|array,counting-sort,sorting|Medium
275|[H-Index II](https://leetcode-cn.com/problems/h-index-ii)|[rust](#h-index-ii-rust),[java](#h-index-ii-java)|array,binary-search|Medium
278|[First Bad Version](https://leetcode-cn.com/problems/first-bad-version)|[java](#first-bad-version-java)|binary-search,interactive|Easy
279|[Perfect Squares](https://leetcode-cn.com/problems/perfect-squares)|[java](#perfect-squares-java),[rust](#perfect-squares-rust)|breadth-first-search,math,dynamic-programming|Medium
283|[Move Zeroes](https://leetcode-cn.com/problems/move-zeroes)|[rust](#move-zeroes-rust),[java](#move-zeroes-java)|array,two-pointers|Easy
287|[Find the Duplicate Number](https://leetcode-cn.com/problems/find-the-duplicate-number)|[java](#find-the-duplicate-number-java),[rust](#find-the-duplicate-number-rust)|bit-manipulation,array,two-pointers,binary-search|Medium
289|[Game of Life](https://leetcode-cn.com/problems/game-of-life)|[java](#game-of-life-java)|array,matrix,simulation|Medium
292|[Nim Game](https://leetcode-cn.com/problems/nim-game)|[java](#nim-game-java)|brainteaser,math,game-theory|Easy
297|[Serialize and Deserialize Binary Tree](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree)|[rust](#serialize-and-deserialize-binary-tree-rust),[java](#serialize-and-deserialize-binary-tree-java)|tree,depth-first-search,breadth-first-search,design,string,binary-tree|Hard
300|[Longest Increasing Subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence)|[rust](#longest-increasing-subsequence-rust),[java](#longest-increasing-subsequence-java)|array,binary-search,dynamic-programming|Medium
301|[Remove Invalid Parentheses](https://leetcode-cn.com/problems/remove-invalid-parentheses)|[java](#remove-invalid-parentheses-java),[rust](#remove-invalid-parentheses-rust)|breadth-first-search,string,backtracking|Hard
303|[Range Sum Query - Immutable](https://leetcode-cn.com/problems/range-sum-query-immutable)|[java](#range-sum-query-immutable-java)|design,array,prefix-sum|Easy
309|[Best Time to Buy and Sell Stock with Cooldown](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)|[java](#best-time-to-buy-and-sell-stock-with-cooldown-java),[rust](#best-time-to-buy-and-sell-stock-with-cooldown-rust)|array,dynamic-programming|Medium
312|[Burst Balloons](https://leetcode-cn.com/problems/burst-balloons)|[java](#burst-balloons-java),[rust](#burst-balloons-rust)|array,dynamic-programming|Hard
316|[Remove Duplicate Letters](https://leetcode-cn.com/problems/remove-duplicate-letters)|[rust](#remove-duplicate-letters-rust)|stack,greedy,string,monotonic-stack|Medium
322|[Coin Change](https://leetcode-cn.com/problems/coin-change)|[java](#coin-change-java),[rust](#coin-change-rust)|breadth-first-search,array,dynamic-programming|Medium
337|[House Robber III](https://leetcode-cn.com/problems/house-robber-iii)|[rust](#house-robber-iii-rust),[java](#house-robber-iii-java)|tree,depth-first-search,dynamic-programming,binary-tree|Medium
338|[Counting Bits](https://leetcode-cn.com/problems/counting-bits)|[java](#counting-bits-java),[rust](#counting-bits-rust)|bit-manipulation,dynamic-programming|Easy
342|[Power of Four](https://leetcode-cn.com/problems/power-of-four)|[java](#power-of-four-java)|bit-manipulation,recursion,math|Easy
344|[Reverse String](https://leetcode-cn.com/problems/reverse-string)|[java](#reverse-string-java)|recursion,two-pointers,string|Easy
347|[Top K Frequent Elements](https://leetcode-cn.com/problems/top-k-frequent-elements)|[java](#top-k-frequent-elements-java),[rust](#top-k-frequent-elements-rust)|array,hash-table,divide-and-conquer,bucket-sort,counting,quickselect,sorting,heap-priority-queue|Medium
349|[Intersection of Two Arrays](https://leetcode-cn.com/problems/intersection-of-two-arrays)|[java](#intersection-of-two-arrays-java)|array,hash-table,two-pointers,binary-search,sorting|Easy
363|[Max Sum of Rectangle No Larger Than K](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k)|[java](#max-sum-of-rectangle-no-larger-than-k-java)|array,binary-search,dynamic-programming,matrix,ordered-set|Hard
365|[Water and Jug Problem](https://leetcode-cn.com/problems/water-and-jug-problem)|[java](#water-and-jug-problem-java)|depth-first-search,breadth-first-search,math|Medium
367|[Valid Perfect Square](https://leetcode-cn.com/problems/valid-perfect-square)|[java](#valid-perfect-square-java)|math,binary-search|Easy
368|[Largest Divisible Subset](https://leetcode-cn.com/problems/largest-divisible-subset)|[java](#largest-divisible-subset-java)|array,math,dynamic-programming,sorting|Medium
371|[Sum of Two Integers](https://leetcode-cn.com/problems/sum-of-two-integers)|[java](#sum-of-two-integers-java)|bit-manipulation,math|Medium
374|[Guess Number Higher or Lower](https://leetcode-cn.com/problems/guess-number-higher-or-lower)|[java](#guess-number-higher-or-lower-java)|binary-search,interactive|Easy
394|[Decode String](https://leetcode-cn.com/problems/decode-string)|[rust](#decode-string-rust),[java](#decode-string-java)|stack,recursion,string|Medium
399|[Evaluate Division](https://leetcode-cn.com/problems/evaluate-division)|[rust](#evaluate-division-rust),[java](#evaluate-division-java)|depth-first-search,breadth-first-search,union-find,graph,array,shortest-path|Medium
401|[Binary Watch](https://leetcode-cn.com/problems/binary-watch)|[java](#binary-watch-java)|bit-manipulation,backtracking|Easy
403|[Frog Jump](https://leetcode-cn.com/problems/frog-jump)|[java](#frog-jump-java)|array,dynamic-programming|Hard
406|[Queue Reconstruction by Height](https://leetcode-cn.com/problems/queue-reconstruction-by-height)|[rust](#queue-reconstruction-by-height-rust),[java](#queue-reconstruction-by-height-java)|greedy,array,sorting|Medium
416|[Partition Equal Subset Sum](https://leetcode-cn.com/problems/partition-equal-subset-sum)|[java](#partition-equal-subset-sum-java),[rust](#partition-equal-subset-sum-rust)|array,dynamic-programming|Medium
437|[Path Sum III](https://leetcode-cn.com/problems/path-sum-iii)|[java](#path-sum-iii-java),[rust](#path-sum-iii-rust)|tree,depth-first-search,binary-tree|Medium
438|[Find All Anagrams in a String](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string)|[java](#find-all-anagrams-in-a-string-java),[rust](#find-all-anagrams-in-a-string-rust)|hash-table,string,sliding-window|Medium
448|[Find All Numbers Disappeared in an Array](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array)|[rust](#find-all-numbers-disappeared-in-an-array-rust),[java](#find-all-numbers-disappeared-in-an-array-java)|array,hash-table|Easy
451|[Sort Characters By Frequency](https://leetcode-cn.com/problems/sort-characters-by-frequency)|[rust](#sort-characters-by-frequency-rust)|hash-table,string,bucket-sort,counting,sorting,heap-priority-queue|Medium
461|[Hamming Distance](https://leetcode-cn.com/problems/hamming-distance)|[rust](#hamming-distance-rust),[java](#hamming-distance-java)|bit-manipulation|Easy
474|[Ones and Zeroes](https://leetcode-cn.com/problems/ones-and-zeroes)|[java](#ones-and-zeroes-java)|array,string,dynamic-programming|Medium
477|[Total Hamming Distance](https://leetcode-cn.com/problems/total-hamming-distance)|[java](#total-hamming-distance-java)|bit-manipulation,array,math|Medium
483|[Smallest Good Base](https://leetcode-cn.com/problems/smallest-good-base)|[java](#smallest-good-base-java)|math,binary-search|Hard
494|[Target Sum](https://leetcode-cn.com/problems/target-sum)|[java](#target-sum-java),[rust](#target-sum-rust)|array,dynamic-programming,backtracking|Medium
518|[Coin Change 2](https://leetcode-cn.com/problems/coin-change-2)|[java](#coin-change-2-java)|array,dynamic-programming|Medium
523|[Continuous Subarray Sum](https://leetcode-cn.com/problems/continuous-subarray-sum)|[java](#continuous-subarray-sum-java)|array,hash-table,math,prefix-sum|Medium
525|[Contiguous Array](https://leetcode-cn.com/problems/contiguous-array)|[java](#contiguous-array-java)|array,hash-table,prefix-sum|Medium
538|[Convert BST to Greater Tree](https://leetcode-cn.com/problems/convert-bst-to-greater-tree)|[java](#convert-bst-to-greater-tree-java),[rust](#convert-bst-to-greater-tree-rust)|tree,depth-first-search,binary-search-tree,binary-tree|Medium
543|[Diameter of Binary Tree](https://leetcode-cn.com/problems/diameter-of-binary-tree)|[rust](#diameter-of-binary-tree-rust),[java](#diameter-of-binary-tree-java)|tree,depth-first-search,binary-tree|Easy
560|[Subarray Sum Equals K](https://leetcode-cn.com/problems/subarray-sum-equals-k)|[java](#subarray-sum-equals-k-java),[rust](#subarray-sum-equals-k-rust)|array,hash-table,prefix-sum|Medium
567|[Permutation in String](https://leetcode-cn.com/problems/permutation-in-string)|[java](#permutation-in-string-java)|hash-table,two-pointers,string,sliding-window|Medium
581|[Shortest Unsorted Continuous Subarray](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray)|[rust](#shortest-unsorted-continuous-subarray-rust),[java](#shortest-unsorted-continuous-subarray-java)|stack,greedy,array,two-pointers,sorting,monotonic-stack|Medium
595|[Big Countries](https://leetcode-cn.com/problems/big-countries)|[mysql](#big-countries-mysql)|database|Easy
596|[Classes More Than 5 Students](https://leetcode-cn.com/problems/classes-more-than-5-students)|[mysql](#classes-more-than-5-students-mysql)|database|Easy
600|[Non-negative Integers without Consecutive Ones](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones)|[java](#non-negative-integers-without-consecutive-ones-java)|dynamic-programming|Hard
617|[Merge Two Binary Trees](https://leetcode-cn.com/problems/merge-two-binary-trees)|[java](#merge-two-binary-trees-java),[rust](#merge-two-binary-trees-rust)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
620|[Not Boring Movies](https://leetcode-cn.com/problems/not-boring-movies)|[mysql](#not-boring-movies-mysql)|database|Easy
621|[Task Scheduler](https://leetcode-cn.com/problems/task-scheduler)|[rust](#task-scheduler-rust),[java](#task-scheduler-java)|greedy,array,hash-table,counting,sorting,heap-priority-queue|Medium
626|[Exchange Seats](https://leetcode-cn.com/problems/exchange-seats)|[mysql](#exchange-seats-mysql)|database|Medium
627|[Swap Salary](https://leetcode-cn.com/problems/swap-salary)|[mysql](#swap-salary-mysql)|database|Easy
633|[Sum of Square Numbers](https://leetcode-cn.com/problems/sum-of-square-numbers)|[java](#sum-of-square-numbers-java)|math,two-pointers,binary-search|Medium
645|[Set Mismatch](https://leetcode-cn.com/problems/set-mismatch)|[rust](#set-mismatch-rust)|bit-manipulation,array,hash-table,sorting|Easy
647|[Palindromic Substrings](https://leetcode-cn.com/problems/palindromic-substrings)|[java](#palindromic-substrings-java),[rust](#palindromic-substrings-rust)|string,dynamic-programming|Medium
692|[Top K Frequent Words](https://leetcode-cn.com/problems/top-k-frequent-words)|[java](#top-k-frequent-words-java)|trie,hash-table,string,bucket-sort,counting,sorting,heap-priority-queue|Medium
726|[Number of Atoms](https://leetcode-cn.com/problems/number-of-atoms)|[rust](#number-of-atoms-rust)|stack,hash-table,string|Hard
739|[Daily Temperatures](https://leetcode-cn.com/problems/daily-temperatures)|[java](#daily-temperatures-java),[rust](#daily-temperatures-rust)|stack,array,monotonic-stack|Medium
752|[Open the Lock](https://leetcode-cn.com/problems/open-the-lock)|[java](#open-the-lock-java)|breadth-first-search,array,hash-table,string|Medium
773|[Sliding Puzzle](https://leetcode-cn.com/problems/sliding-puzzle)|[java](#sliding-puzzle-java)|breadth-first-search,array,matrix|Hard
815|[Bus Routes](https://leetcode-cn.com/problems/bus-routes)|[java](#bus-routes-java)|breadth-first-search,array,hash-table|Hard
852|[Peak Index in a Mountain Array](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array)|[java](#peak-index-in-a-mountain-array-java)|array,binary-search|Easy
872|[Leaf-Similar Trees](https://leetcode-cn.com/problems/leaf-similar-trees)|[java](#leaf-similar-trees-java)|tree,depth-first-search,binary-tree|Easy
877|[Stone Game](https://leetcode-cn.com/problems/stone-game)|[java](#stone-game-java)|array,math,dynamic-programming,game-theory|Medium
879|[Profitable Schemes](https://leetcode-cn.com/problems/profitable-schemes)|[java](#profitable-schemes-java)|array,dynamic-programming|Hard
897|[Increasing Order Search Tree](https://leetcode-cn.com/problems/increasing-order-search-tree)|[java](#increasing-order-search-tree-java)|stack,tree,depth-first-search,binary-search-tree,binary-tree|Easy
909|[Snakes and Ladders](https://leetcode-cn.com/problems/snakes-and-ladders)|[java](#snakes-and-ladders-java)|breadth-first-search,array,matrix|Medium
930|[Binary Subarrays With Sum](https://leetcode-cn.com/problems/binary-subarrays-with-sum)|[rust](#binary-subarrays-with-sum-rust)|array,hash-table,prefix-sum,sliding-window|Medium
938|[Range Sum of BST](https://leetcode-cn.com/problems/range-sum-of-bst)|[java](#range-sum-of-bst-java)|tree,depth-first-search,binary-search-tree,binary-tree|Easy
980|[Unique Paths III](https://leetcode-cn.com/problems/unique-paths-iii)|[java](#unique-paths-iii-java)|bit-manipulation,array,backtracking,matrix|Hard
981|[Time Based Key-Value Store](https://leetcode-cn.com/problems/time-based-key-value-store)|[rust](#time-based-key-value-store-rust)|design,hash-table,string,binary-search|Medium
989|[Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer)|[java](#add-to-array-form-of-integer-java)|array,math|Easy
993|[Cousins in Binary Tree](https://leetcode-cn.com/problems/cousins-in-binary-tree)|[java](#cousins-in-binary-tree-java)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
1011|[Capacity To Ship Packages Within D Days](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days)||greedy,array,binary-search|Medium
1035|[Uncrossed Lines](https://leetcode-cn.com/problems/uncrossed-lines)|[java](#uncrossed-lines-java)|array,dynamic-programming|Medium
1049|[Last Stone Weight II](https://leetcode-cn.com/problems/last-stone-weight-ii)|[java](#last-stone-weight-ii-java)|array,dynamic-programming|Medium
1074|[Number of Submatrices That Sum to Target](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target)|[java](#number-of-submatrices-that-sum-to-target-java)|array,hash-table,matrix,prefix-sum|Hard
1114|[Print in Order](https://leetcode-cn.com/problems/print-in-order)|[java](#print-in-order-java)|concurrency|Easy
1115|[Print FooBar Alternately](https://leetcode-cn.com/problems/print-foobar-alternately)|[java](#print-foobar-alternately-java)|concurrency|Medium
1116|[Print Zero Even Odd](https://leetcode-cn.com/problems/print-zero-even-odd)|[java](#print-zero-even-odd-java)|concurrency|Medium
1190|[Reverse Substrings Between Each Pair of Parentheses](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses)|[java](#reverse-substrings-between-each-pair-of-parentheses-java)|stack,string|Medium
1239|[Maximum Length of a Concatenated String with Unique Characters](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters)|[java](#maximum-length-of-a-concatenated-string-with-unique-characters-java)|bit-manipulation,array,string,backtracking|Medium
1418|[Display Table of Food Orders in a Restaurant](https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant)|[rust](#display-table-of-food-orders-in-a-restaurant-rust)|array,hash-table,string,ordered-set,sorting|Medium
1449|[Form Largest Integer With Digits That Add up to Target](https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target)|[java](#form-largest-integer-with-digits-that-add-up-to-target-java)|array,dynamic-programming|Hard
1600|[Throne Inheritance](https://leetcode-cn.com/problems/throne-inheritance)|[java](#throne-inheritance-java)|tree,depth-first-search,design,hash-table|Medium
1711|[Count Good Meals](https://leetcode-cn.com/problems/count-good-meals)|[rust](#count-good-meals-rust)|array,hash-table|Medium
1720|[Decode XORed Array](https://leetcode-cn.com/problems/decode-xored-array)|[java](#decode-xored-array-java)|bit-manipulation,array|Easy
1734|[Decode XORed Permutation](https://leetcode-cn.com/problems/decode-xored-permutation)|[java](#decode-xored-permutation-java)|bit-manipulation,array|Medium
1738|[Find Kth Largest XOR Coordinate Value](https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value)|[java](#find-kth-largest-xor-coordinate-value-java)|bit-manipulation,array,divide-and-conquer,matrix,prefix-sum,quickselect,heap-priority-queue|Medium
1744|[Can You Eat Your Favorite Candy on Your Favorite Day?](https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day)|[java](#can-you-eat-your-favorite-candy-on-your-favorite-day-java)|array,prefix-sum|Medium
1818|[Minimum Absolute Sum Difference](https://leetcode-cn.com/problems/minimum-absolute-sum-difference)|[rust](#minimum-absolute-sum-difference-rust)|greedy,array,binary-search,ordered-set|Medium
1833|[Maximum Ice Cream Bars](https://leetcode-cn.com/problems/maximum-ice-cream-bars)|[rust](#maximum-ice-cream-bars-rust)|greedy,array,sorting|Medium
1838|[Frequency of the Most Frequent Element](https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element)|[java](#frequency-of-the-most-frequent-element-java),[rust](#frequency-of-the-most-frequent-element-rust)|array,binary-search,prefix-sum,sliding-window|Medium
1846|[Maximum Element After Decreasing and Rearranging](https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging)|[rust](#maximum-element-after-decreasing-and-rearranging-rust)|greedy,array,sorting|Medium
1877|[Minimize Maximum Pair Sum in Array](https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array)|[rust](#minimize-maximum-pair-sum-in-array-rust)|greedy,array,two-pointers,sorting|Medium
LCP 07|[ä¼ é€’ä¿¡æ¯](https://leetcode-cn.com/problems/chuan-di-xin-xi)|[rust](#chuan-di-xin-xi-rust)|depth-first-search,breadth-first-search,graph,dynamic-programming|Easy
å‰‘æŒ‡ Offer 15|[äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•° LCOF](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof)|[java](#er-jin-zhi-zhong-1de-ge-shu-lcof-java)|bit-manipulation|Easy
å‰‘æŒ‡ Offer 37|[åºåˆ—åŒ–äºŒå‰æ ‘  LCOF](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof)|[java](#xu-lie-hua-er-cha-shu-lcof-java)|tree,depth-first-search,breadth-first-search,design,string,binary-tree|Hard
å‰‘æŒ‡ Offer 38|[å­—ç¬¦ä¸²çš„æŽ’åˆ—  LCOF](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof)|[java](#zi-fu-chuan-de-pai-lie-lcof-java)|string,backtracking|Medium
å‰‘æŒ‡ Offer 42|[è¿žç»­å­æ•°ç»„çš„æœ€å¤§å’Œ  LCOF](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof)|[rust](#lian-xu-zi-shu-zu-de-zui-da-he-lcof-rust)|array,divide-and-conquer,dynamic-programming|Easy
å‰‘æŒ‡ Offer 53 - I|[åœ¨æŽ’åºæ•°ç»„ä¸­æŸ¥æ‰¾æ•°å­—  LCOF](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof)|[rust](#zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof-rust)|array,binary-search|Easy
é¢è¯•é¢˜ 10.02|[Group Anagrams LCCI](https://leetcode-cn.com/problems/group-anagrams-lcci)|[rust](#group-anagrams-lcci-rust)|hash-table,string,sorting|Medium
é¢è¯•é¢˜ 17.10|[Find Majority Element LCCI](https://leetcode-cn.com/problems/find-majority-element-lcci)|[rust](#find-majority-element-lcci-rust)|array,counting|Easy
### two sum rust

```rust
impl Solution {


    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
        let mut index: Vec<usize> = (0..nums.len() as usize).collect();
        // let nums = &nums;
        index.sort_by(|a, b| nums[*a].cmp(&nums[*b]));

        let mut left = 0;
        let mut right = nums.len() - 1;
        while left < right {
            let a = nums[index[left]] + nums[index[right]];
            match a.cmp(&target) {
                std::cmp::Ordering::Less => left += 1,
                std::cmp::Ordering::Greater => right -= 1,
                std::cmp::Ordering::Equal => return vec![index[left] as i32, index[right] as i32]
            }
        }
        return vec![-1, -1];
    }

}
```

### two sum java

```java
public class Solution {
    public int[] twoSum(int[] nums, int target) {
    	Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    	for(int i = 0; i < nums.length; i++){
    		int t = target - nums[i];
    		if(map.containsKey(t)){
    			return new int[]{Math.min(i, map.get(t)) + 1, Math.max(i, map.get(t)) + 1};
    		}
    		map.put(nums[i], i);
    	}
        return new int[]{0, 0};
    }
}
```

### add two numbers rust

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {

    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut ans = Some(Box::new(ListNode::new(-1)));
        let mut last = &mut ans;
        let mut l1 = &l1;
        let mut l2 = &l2;

        let mut p = 0;
        while l1.is_some() || l2.is_some() || p > 0 {
            let mut tmp = p;
            if let Some(n) = l1 {
                tmp += n.val;
                l1 = &n.next;
            }
            if let Some(n) = l2 {
                tmp += n.val;
                l2 = &n.next;
            }
            p = tmp / 10;
            tmp %= 10;
            last.as_mut()?.next = Some(Box::new(ListNode::new(tmp)));
            last = &mut last.as_mut()?.next;
        }
        ans?.next
    }


}
```

### add two numbers java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    	if(l1 == null) return l2;
    	if(l2 == null) return l1;
    	int array = 0;
    	ListNode head = null;
    	int tmp = l1.val + l2.val + array;
    	head = new ListNode(tmp % 10);
    	ListNode t = head;
    	array = tmp / 10;
    	l1 = l1.next;
    	l2 = l2.next;
    	while(l1 != null || l2 != null){
    		if(l1 == null){
    			t.next = l2;
    			while(array != 0){
    	        	tmp = l2.val + array;
    	        	l2.val = tmp % 10;
    	        	array = tmp / 10;
    	        	if(l2.next == null && array != 0){
    	        		l2.next = new ListNode(array);
    	        		break;
    	        	}
    	        	l2 = l2.next;
    			}
    			return head;
    		}
    		if(l2 == null){
    			t.next = l1;
    			while(array != 0){
    	        	tmp = l1.val + array;
    	        	l1.val = tmp % 10;
    	        	array = tmp / 10;
    	        	if(l1.next == null && array != 0){
    	        		l1.next = new ListNode(array);
    	        		break;
    	        	}
    	        	l1 = l1.next;
    			}
    			return head;
    		}
        	tmp = l1.val + l2.val + array;
        	t.next = new ListNode(tmp % 10);
        	t = t.next;
        	array = tmp / 10;
        	l1 = l1.next;
        	l2 = l2.next;
    	}
    	if(array != 0){
    		t.next = new ListNode(array);
    	}
    	return head;
    }
}
```

### longest substring without repeating characters rust

```rust
impl Solution {

    pub fn length_of_longest_substring(s: String) -> i32 {
        let mut pos = std::collections::HashMap::new();
        let mut ans = 0;
        let mut lst_pos = -1i32;

        for (idx, c) in s.chars().enumerate() {
            if let Some(&last) = pos.get(&c) {
                lst_pos = lst_pos.max(last);
            }
            ans = ans.max(idx as i32 - lst_pos);
            pos.insert(c, idx as i32);
        }
        ans
    }
}
```

### longest substring without repeating characters java

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> set = new HashMap<>();
        int cnt = 0;
        int last = -1;
        for (int i = 0; i < s.length(); i++) {
            Integer a = set.put(s.charAt(i), i);
            last = a != null? Math.max(a, last): last;
            cnt = Math.max(cnt, i - last);
        }
        return cnt;
    }
}
```

### median of two sorted arrays rust

```rust
impl Solution {

    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {
        fn find_k(nums1: &Vec<i32>, nums2: &Vec<i32>, kk: usize) -> i32 {
            let mut k = kk;
            let mut index1 = 0usize;
            let mut index2 = 0usize;
            loop {
                
                if index1 == nums1.len() {
                    return nums2[kk - index1 - 1];
                }
                if index2 == nums2.len() {
                    return nums1[kk - index2 - 1];
                }
                if k == 1 {
                    return std::cmp::min(nums1[index1], nums2[index2]);
                }

                let half = k >> 1;
                let n_index1 = std::cmp::min(half + index1, nums1.len()) - 1;
                let n_index2 = std::cmp::min(half + index2, nums2.len()) - 1;

                if nums1[n_index1] < nums2[n_index2] {
                    k -= n_index1 + 1 - index1;
                    index1 = n_index1 + 1;
                } else {
                    k -= n_index2 + 1 - index2;
                    index2 = n_index2 + 1;
                }
            }
        }
        let size = nums1.len() + nums2.len();
        if size & 1 > 0 {
            find_k(&nums1, &nums2, (size >> 1) + 1) as f64
        } else {
            (find_k(&nums1, &nums2, size >> 1) + find_k(&nums1, &nums2, (size >> 1) + 1)) as f64 / 2f64
        }

    }
}
```

### median of two sorted arrays java

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int left = 0, right = 0;

        int mid = (nums1.length + nums2.length) >> 1;
        boolean odd = ((nums1.length + nums2.length) & 1) > 0;
        mid += odd? 1: 0;
        int cnt = odd ? 1: 2;
        int cntBak = cnt;

        int sum = 0;
        while (cnt > 0){
            if (left < nums1.length && (right >= nums2.length || nums1[left] <= nums2[right])){
                mid--;
                if (mid <= 0 && cnt > 0){
                    cnt--;
                    sum += nums1[left];
                }
                left++;
            }

            if (right < nums2.length && (left >= nums1.length || nums1[left] >= nums2[right])){
                mid--;
                if (mid <= 0 && cnt > 0){
                    cnt--;
                    sum += nums2[right];
                }
                right++;
            }
        }

        return (double)sum / cntBak;
    }
}
```

### longest palindromic substring rust

```rust
impl Solution {


    pub fn longest_palindrome(s: String) -> String {
        let mut dp = vec![vec![false; s.len()]; s.len()];
        let bytes = s.as_bytes();
        let mut ans = s[0..1].to_string();
        for i in 0..s.len() {
            for j in i..s.len() {
                if i == 0 {
                    dp[j][j] = true;
                }else if i == 1 {
                    dp[j - i][j] = bytes[j - i] == bytes[j];
                }else{
                    dp[j - i][j] = dp[j - i + 1][j - 1] && bytes[j - i] == bytes[j];
                }
                if dp[j - i][j] && i + 1 > ans.len() {
                    ans = s[j-i..j+1].to_string();
                }
            }
        }
        ans
    }

}
```

### longest palindromic substring java

```java
class Solution {
    public String longestPalindrome(String s) {
        boolean[][] bk = new boolean[s.length()][s.length()];
        int m = 0;
        int bestleft = 0;
        for (int len = 0; len < s.length(); len++) {
            for (int left = 0; left + len < s.length(); left++) {
                int right = left + len;
                if (len == 0){
                    bk[left][right] = true;
                }else if (len == 1){
                    bk[left][right] = s.charAt(left) == s.charAt(right);
                }else{
                    bk[left][right] = s.charAt(left) == s.charAt(right) && bk[left + 1][right - 1];
                }
                if (bk[left][right] && len > m){
                    m = len;
                    bestleft = left;
                }
            }
        }
        return s.substring(bestleft, bestleft + m + 1);
    }
}
```

### zigzag conversion java

```java
public class Solution {
    public String convert(String s, int numRows) {
        
		if(numRows == 1) return s;
        StringBuilder[] builder = new StringBuilder[numRows];
        for(int i = 0; i < numRows; i++){
        	builder[i] = new StringBuilder();
        }
        int i = 0;
        int j = 0;
        int gap = numRows - 2;
        while(i < s.length()){
        	for(j = 0; i < s.length() && j < numRows; j++){
        		builder[j].append(s.charAt(i++));
        	}
        	for(j = gap; i < s.length() && j > 0; j--){
        		builder[j].append(s.charAt(i++));
        	}
        }
        StringBuilder res = new StringBuilder();
        for(StringBuilder sb: builder){
        	res.append(sb);
        }
        return res.toString();
    }
}
```

### reverse integer java

```java
public class Solution {
    public int reverse(int x) {
    	long y = 0;
    	while(x != 0){
    		y = y * 10 + x % 10;
    		x /= 10;
    		if(Math.abs(y) > Math.pow(2, 31) - 1) return 0;
    	}
    	
        return (int)y;
    }
}
```

### string to integer atoi java

```java
public class Solution {
    public int myAtoi(String str) {
    	if(str != null) str = str.trim(); else return 0;
    	if(str == null || str.equals("")) return 0;
    	int nOrp = 1;
    	if(str.charAt(0) == '-' || str.charAt(0) == '+'){
    		nOrp = ',' - str.charAt(0);
    		str = str.substring(1);
    	}
    	if(!str.equals("") && (str.charAt(0) < '0' || str.charAt(0) > '9')) return 0;
    	long res = 0;
    	int countBits = 0;
        for(char c: str.toCharArray()){
        	if(c < '0' || c > '9') break;
        	res = res * 10 + (int)(c - '0');
        	countBits++;
        }
        if(res > Integer.MAX_VALUE || countBits >= 11) return Integer.MAX_VALUE * nOrp - (1 - nOrp) / 2;
        return (int)res * nOrp;
    }
}
```

### palindrome number java

```java
class Solution {
    public boolean isPalindrome(int x) {
        String s = String.valueOf(x);
        return new StringBuilder(s).reverse().toString().equals(s);
    }
}
```

### regular expression matching rust

```rust
impl Solution {

    pub fn is_match(s: String, p: String) -> bool {
        let m = s.len();
        let n = p.len();
        let mut dp = vec![vec![false; n + 1]; m + 1];
        dp[0][0] = true;

        for i in 0..=m {
            for j in 1..=n {
                if p.as_bytes()[j - 1] == b'*' {
                    dp[i][j] = dp[i][j - 2];
                    if i > 0 && (s.as_bytes()[i - 1] == p.as_bytes()[j - 2] || p.as_bytes()[j - 2] == b'.') {
                        dp[i][j] = dp[i][j] || dp[i - 1][j];
                    }
                } else {
                    if i > 0 {
                        dp[i][j] = dp[i - 1][j - 1] && (s.as_bytes()[i - 1] == p.as_bytes()[j - 1] || p.as_bytes()[j - 1] == b'.');
                    }
                }
            }
        }

        dp[m][n]
    }
}
```

### regular expression matching java

```java
class Solution {

    public boolean isMatch(String s, String p) {
        HashMap<String, Boolean> map = new HashMap<>();
        boolean match = isMatch(s, p, map);
        return match;
    }
    public boolean isMatch(String s, String p, Map<String, Boolean> map) {
        if (p.length() <= 0){
            return s.isEmpty();
        }
        if (map.containsKey(s + "-" + p)){
            return map.get(s + "-" + p);
        }
        int cur = 0;
        for (int i = 0; i < p.length(); i++) {
            char c = p.charAt(i);
            boolean wild = i + 1 < p.length() && p.charAt(i + 1) == '*';
            if (wild){
                do {
                    if (isMatch(s.substring(cur), p.substring(i + 2))) {
                        map.put(s + "-" + p, true);
                        return true;
                    }else if (cur >= s.length()){
                        map.put(s + "-" + p, false);
                        return false;
                    }
                    if (c == '.' || c == s.charAt(cur)) {
                        cur++;
                    }else {
                        map.put(s + "-" + p, false);
                        return false;
                    }
                }while (true);
            }

            if (cur >= s.length()){
                return false;
            }
            if (c == '.' || c == s.charAt(cur)) {
                cur++;
            }else{
                break;
            }
        }
        boolean b = cur >= s.length();
        map.put(s + "-" + p, b);
        return b;
    }
}
```

### container with most water rust

```rust
impl Solution {
    pub fn max_area(height: Vec<i32>) -> i32 {
        let mut left = 0;
        let mut right = height.len() - 1;
        let mut ans = 0;
        while left < right {
            ans = ans.max((right - left) as i32 * height[left].min(height[right]));
            if height[right] > height[left] {
                left += 1;
            } else {
                right -= 1;
            }
        }
        ans
    }

}
```

### container with most water java

```java
public class Solution {
    public int maxArea(int[] height) {
    	if(height == null) return 0;
        int lo = 0;
        int hi = height.length - 1;
        int max = 0;
        while(lo < hi){
        	int h = Math.min(height[lo], height[hi]);
        	max = Math.max(max, h * (hi - lo));
        	if(height[lo] < height[hi]){
        		while(lo < height.length && height[lo] <= h){
        			lo++;
        		}
        	}else{
        		while(hi >= 0 && height[hi] <= h){
        			hi--;
        		}
        	}
        }
        return max;
    }
}
```

### integer to roman java

```java
class Solution {
    
    
    static int[] nums = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};
    static String[] name = {"I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M"};

    public String intToRoman(int num) {
        StringBuilder sb = new StringBuilder();
        int index = nums.length - 1;
        while (num > 0){
            for (int i = index; i >= 0; i--) {
                if (num >= nums[i]){
                    sb.append(name[i]);
                    index = i;
                    num -= nums[i];
                    break;
                }
            }
        }
        return sb.toString();
    }
}
```

### roman to integer java

```java
class Solution {

    private static Map<Integer, Integer> map = new HashMap<>();
    {
        map.put((int)'I', 1);
        map.put((int)'V', 5);
        map.put((int)'X', 10);
        map.put((int)'L', 50);
        map.put((int)'C', 100);
        map.put((int)'D', 500);
        map.put((int)'M', 1000);
    }

    public int romanToInt(String s) {
        int ans = s.chars().map(map::get).sum();
        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) == 'I' && (s.charAt(i + 1) == 'V' || s.charAt(i + 1) == 'X')) {
                ans -= 2;
            }else if (s.charAt(i) == 'X' && (s.charAt(i + 1) == 'L' || s.charAt(i + 1) == 'C')){
                ans -= 20;
            }else if (s.charAt(i) == 'C' && (s.charAt(i + 1) == 'D' || s.charAt(i + 1) == 'M')){
                ans -= 200;
            }
        }
        return ans;
    }

}
```

### longest common prefix java

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String ans = "";

        for (int i = 1; i <= strs[0].length(); i++) {
            String t = strs[0].substring(0, i);
            if (Arrays.stream(strs).allMatch(x -> x.startsWith(t))){
                ans = t;
            }else {
                return ans;
            }
        }
        
        return ans;
    }
}
```

### 3sum rust

```rust
impl Solution {
    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut ans = vec![];
        let mut nums = nums;

        if nums.len() < 3 {
            return ans;
        }
        nums.sort();
        for i in 0..nums.len()-2 {
            if i > 0 && nums[i] == nums[i - 1] {
                continue;
            }
            if nums[i] + nums[nums.len() - 1] + nums[nums.len() - 2] < 0 {
                continue;
            }
            if nums[i] + nums[i + 1] + nums[i + 2] > 0 {
                break;
            }
            let first = -nums[i];
            let (mut left, mut right) = (i + 1, nums.len() - 1);
            while left < right {
                if left > i + 1 && nums[left] == nums[left - 1] {
                    left += 1;
                    continue;
                }
                let a = nums[left] + nums[right];
                match a.cmp(&first) {
                    std::cmp::Ordering::Greater => right -= 1,
                    std::cmp::Ordering::Less => left += 1,
                    _ => {
                        ans.push(vec![nums[i], nums[left], nums[right]]);
                        right -= 1;
                        left += 1;
                    }
                }
            }
        }

        ans
    }
}
```

### 3sum java

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> r = new ArrayList<>();

        System.out.println(Arrays.toString(nums));
        for (int i = 0; i < nums.length - 2; i++) {
            if (nums[i] > 0){
                break;
            }
            for (int j = i + 1; j < nums.length - 1; j++) {
                if (!r.isEmpty()){
                    List<Integer> list = r.get(r.size() - 1);
                    if (list.get(0) == nums[i] && list.get(1) >= nums[j]){
                        continue;
                    }
                }
                int key = -nums[i] - nums[j];
                if (key < 0){
                    break;
                }
                int third = Arrays.binarySearch(nums, j + 1, nums.length, key);
                if (third > 0){
                    List<Integer> l = new ArrayList<>();
                    l.add(nums[i]);
                    l.add(nums[j]);
                    l.add(nums[third]);
                    r.add(l);
                }
            }
        }
        return r;
    }
}
```

### 3sum closest java

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int ans = 20002;
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            int left = i + 1;
            int right = nums.length - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum < target) {
                    left++;
                } else if (sum > target) {
                    right--;
                } else {
                    return sum;
                }
                ans = Math.abs(target - sum) < Math.abs(target - ans)? sum: ans;
            }
        }
        return ans;
    }
}
```

### letter combinations of a phone number rust

```rust
impl Solution {

    pub fn letter_combinations(digits: String) -> Vec<String> {
        let dict = vec![vec![],
            vec![], vec!["a", "b", "c"], vec!["d", "e", "f"],
            vec!["g", "h", "i"], vec!["j", "k", "l"], vec!["m", "n", "o"], 
            vec!["p", "q", "r", "s"], vec!["t", "u", "v"],vec!["w", "x", "y", "z"], 
        ];

        let mut ans: Vec<String> = vec![];
        let nums: Vec<usize>= digits.as_bytes().iter().map(|&i| (i - b'0') as usize).collect();
        for d in nums {
            let n = &dict[d];
            if ans.is_empty() {
                let mut a: Vec<String> = n.iter().map(|&x|x.to_string()).collect();
                ans.append(&mut a);
            } else {
                let len = ans.len();
                for i in 0..len {
                    let mut c = ans[i].clone();
                    ans[i] += n[0];
                    for j in 1..n.len() {
                        ans.push(c.clone() + n[j]);
                    }
                }
            }
        }

        ans
    }
}
```

### letter combinations of a phone number java

```java
public class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> list = new ArrayList<String>();
        String[] digitsMap = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        getString(list, digits, digitsMap);
        return list;
    }
    private void getString(List<String> list, String digits, String[] digitsMap){
        if(digits == null || digits.length() == 0) return;
        int i = digits.charAt(0) - '0';
        if(list.size() == 0){
            for(char c: digitsMap[i].toCharArray()){
                list.add("" + c);
            }
        }else{
            List<String> tmp = new ArrayList<>();
            for(char c: digitsMap[i].toCharArray()){
                for(String s: list){
                    tmp.add(s + c);
                }
            }
            list.clear();
            list.addAll(tmp);
        }
        getString(list, digits.substring(1), digitsMap);
    }
}
```

### 4sum java

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        if (nums.length < 4){
            return ans;
        }
        Arrays.sort(nums);
        int n = nums.length;
        long large = (long)nums[n - 1] + nums[n - 2] + nums[n - 3];
        for (int i = 0; i < n - 3; i++) {
            if (i > 0 && nums[i - 1] == nums[i]){
                continue;
            }
            if ((long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target){
                break;
            }
            if ((long)nums[i] + large < target){
                continue;
            }

            for (int j = n - 1; j > i + 2; j--) {
                if (j < n - 1 && nums[j + 1] == nums[j]){
                    continue;
                }
                int ll = i + 1;
                int rr = j - 1;
                long sum = (long)target - nums[i] - nums[j];
                while (ll < rr){
                    if (ll > i + 1 && nums[ll] == nums[ll - 1]){
                        ll++;
                        continue;
                    }
                    if (rr < j - 1 && nums[rr] == nums[rr + 1]){
                        rr--;
                        continue;
                    }
                    long a = (long)nums[ll] + nums[rr];
                    if (a > sum) {
                        rr--;
                    } else if (a < sum){
                        ll++;
                    } else {
                        ans.add(Arrays.asList(nums[i], nums[ll], nums[rr], nums[j]));
                        ll++;
                        rr--;
                    }
                }
            }
        }

        return ans;
    }
}
```

### remove nth node from end of list rust

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {
        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));

        let mut cnt = 0;

        let mut cur = &mut dummy;

        while let Some(_) = cur {
            cnt += 1;
            cur = &mut cur.as_mut()?.next;
        }

        cur = &mut dummy;

        for _ in 0..cnt-n-1 {
            cur = &mut cur.as_mut()?.next;
        }
        
        cur.as_mut()?.next = cur.as_mut()?.next.as_mut()?.next.take();

        dummy?.next
    }
}
```

### remove nth node from end of list java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    private int count = 0;
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(n == 0) return head;
        if(head == null) return head;
        head.next = removeNthFromEnd(head.next, n);
        count++;
        if(count == n){
            return head.next;
        }
        return head;
    }
}
```

### valid parentheses rust

```rust
impl Solution {

    pub fn is_valid(s: String) -> bool {
        if s.len() & 1 > 0 {
            return false;
        }
        let mut v: Vec<u8> = vec![];
        for i in s.bytes() {
            match i {
                b'(' | b'[' | b'{' => v.push(i),
                _ => {
                    if let Some(b) = v.pop() {
                        match (b, i) {
                            (b'[', b']') | (b'(', b')') | (b'{', b'}') => continue,
                            _ => return false,
                        }
                    }else{
                        return false;
                    }
                }
            };
        }

        v.len() == 0
    }
}
```

### valid parentheses java

```java
public class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<Character>();
        for (char c: s.toCharArray()){
            if(stack.size() == 0){
                stack.push(c);
            }else{
                char last = stack.peek();
                if(isMatch(last, c)){
                    stack.pop();
                }else{
                    stack.push(c);
                }
            }
        }
        return stack.size() == 0;
    }
    char[][] cs = new char[][]{{'[', ']'},{'{', '}'},{'(', ')'}};
    private boolean isMatch(char c1, char c2){
        for (char[] t: cs){
            if(c1 == t[0] && c2 == t[1]) return true;
        }
        return false;
    }
}
```

### merge two sorted lists rust

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn merge_two_lists(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut dummy = Some(Box::new(ListNode::new(-1)));
        let mut cur = &mut dummy;
        let mut l1 = l1;
        let mut l2 = l2;
        while l1.is_some() || l2.is_some() {
            if l2.is_none() {
                cur.as_mut().unwrap().next = l1;
                break;
            }else if l1.is_none(){
                cur.as_mut().unwrap().next = l2;
                break;
            }
            if l1.as_ref().unwrap().val < l2.as_ref().unwrap().val {
                let next = l1.as_mut().unwrap().next.take();
                cur.as_mut().unwrap().next = l1.take();
                l1 = next;
                cur = &mut cur.as_mut().unwrap().next;
            }else {
                let next = l2.as_mut().unwrap().next.take();
                cur.as_mut().unwrap().next = l2.take();
                l2 = next;
                cur = &mut cur.as_mut().unwrap().next;
            }
            

        }

        dummy.unwrap().next.take()
    }
}
```

### merge two sorted lists java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;
        ListNode head = null;
        ListNode res = null;
        if(l1.val < l2.val){
        	head = l1;
        	l1 = l1.next;
        }else{
        	head = l2;
        	l2 = l2.next;
        }
        res = head;
        while(l1 != null || l2 != null){
        	while(l1 == null && l2 != null){
        		head.next = l2;
        		head = head.next;
        		l2 = l2.next;
        	}
        	while(l2 == null && l1 != null){
        		head.next = l1;
        		head = head.next;
        		l1 = l1.next;
        	}
        	while(l1 != null && l2 != null){
        		if(l1.val < l2.val){
        			head.next = l1;
        			head = head.next;
        			l1 = l1.next;
        		}else{
        			head.next = l2;
        			head = head.next;
        			l2 = l2.next;
        		}
        	}
        }
        return res;
    }
}
```

### generate parentheses rust

```rust
impl Solution {

    pub fn generate_parenthesis(n: i32) -> Vec<String> {
        fn dfs(st:&mut String, open: i32, close: i32, max: i32, ans: &mut Vec<String>){
            if st.len() == max as usize * 2 {
                ans.push(st.clone());
                return;
            }
            if open < max {
                st.push('(');
                dfs(st, open + 1, close, max, ans);
                st.remove(st.len() - 1);
            }
            if close < open {
                st.push(')');
                dfs(st, open, close + 1, max, ans);
                st.remove(st.len() - 1);
            }

        }
        let mut st = String::new();
        let mut ans = vec![];
        dfs(&mut st, 0, 0, n, &mut ans);
        ans
    }
}
```

### generate parentheses java

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        Set<String> set = new HashSet<>();
        if (n == 0){
            return Collections.emptyList();
        }
        set.add("()");

        while (--n > 0) {
            Set<String> ss = new HashSet<>();
            for (String s : set) {
                for (int i = 0; i < s.length(); i++) {
                    int c = 0;
                    for (int j = i; j < s.length(); j++) {
                        if (c == 0){
                            String s1 = s.substring(0, i) + "(" + s.substring(i, j) + ")" + s.substring(j);
                            ss.add(s1);
                        }
                        if (s.charAt(j) == '(') c++;
                        if (s.charAt(j) == ')') c--;
                    }
                }

            }
            set = ss;
        }
        return new ArrayList<>(set);
    }
}
```

### merge k sorted lists rust

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {

    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {
        let mut m = std::collections::BinaryHeap::new();
        let n = lists.len();
        let mut lists = lists;
        for i in 0..n {
            if let Some(mut x) = lists[i].take() {
                m.push(std::cmp::Reverse((x.val, i)));
                lists[i] = x.next.take();
            }
        }
        let mut dummy = Box::new(ListNode::new(-1));
        let mut cur = &mut dummy;
        while !m.is_empty() {
            if let Some(std::cmp::Reverse((x, idx))) = m.pop() {
                cur.next = Some(Box::new(ListNode::new(x)));
                cur = cur.next.as_mut().unwrap();
                if let Some(mut x) = lists[idx].take() {
                    m.push(std::cmp::Reverse((x.val, idx)));
                    lists[idx] = x.next.take();
                }
            }
        }
        dummy.next
    }

}
```

### merge k sorted lists java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        Queue<ListNode> q = new PriorityQueue<ListNode>(new Comparator<ListNode>() {
            @Override
            public int compare(ListNode o1, ListNode o2) {
                return o1.val- o2.val;
            }
        });
        ListNode head = null;
        ListNode t = null;
        while(true) {
            for (int i = 0; i < lists.length; i++) {
                ListNode tmp = lists[i];
                if (tmp != null) {
                    q.add(tmp);
                    lists[i] = tmp.next;
                }
            }
            if (q.size() == 0) {
                if(t != null) t.next = null;
                break;
            }
            if (head == null) head = q.remove();
            if (t == null) t = head;
            else {
                t.next = q.remove();
                t = t.next;
            }
        }
        return head;
    }
}
```

### swap nodes in pairs rust

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));

        let mut cur = &mut dummy;
        while cur.as_ref()?.next.is_some(){
            if cur.as_ref()?.next.as_ref()?.next.is_some() {
                let mut tmp = cur.as_mut()?.next.as_mut()?.next.take();
                cur.as_mut()?.next.as_mut()?.next = tmp.as_mut()?.next.take();
                tmp.as_mut()?.next = cur.as_mut()?.next.take();
                cur.as_mut()?.next = tmp;
                cur = &mut cur.as_mut()?.next.as_mut()?.next;
            }else{
                break;
            }
        }

        return dummy?.next;
    }
}
```

### swap nodes in pairs java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode node = null;
        ListNode tmp = null;
        node = head.next;
        head.next = node.next;
        node.next = head;
        head = node;
        node = node.next;
        while(node.next != null && node.next.next != null){
        	tmp = node.next.next;
        	node.next.next = tmp.next;
        	tmp.next = node.next;
        	node.next = tmp;
        	node = node.next.next;
        }
        return head;
        
        
    }
}
```

### reverse nodes in k group java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(k == 1 || k == 0) return head;
        ListNode t = head;
        ListNode res = null;
        ListNode tHead = head;
        ListNode last = null;
        int count;
        while(true) {
            count = 0;
            while (t != null) {
                count++;
                if (count == k) break;
                t = t.next;
            }
            if(t == null){
                if(last == null) return head;
                last.next = tHead;
                break;
            }
            ListNode next = t.next;
            ListNode tmp = reserseNodes(tHead, k);
            if(last == null) last = tHead;
            else {
                last.next = tmp;
                last = tHead;
            }
            if(res == null) res = tmp;
            t = tHead = next;
        }
        return res;
    }
    private ListNode reserseNodes(ListNode head, int k){
        ListNode last = null;
        ListNode t = head;
        while(k-- > 0){
            ListNode tmp = t.next;
            t.next = last;
            last = t;
            t = tmp;
        }
        return last;
    }

}
```

### remove duplicates from sorted array rust

```rust
impl Solution {


    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {
        if nums.len() <= 0 {
            return 0;
        }
        let mut index = 1;
        for i in 1..nums.len() {
            if nums[i] != nums[i - 1] {
                nums[index] = nums[i];
                index += 1;
            }
        }
        index as i32
    }
}
```

### remove duplicates from sorted array java

```java
public class Solution {
    public int removeDuplicates(int[] nums) {
    	if(nums == null || nums.length == 0) return 0;
        int res = 0;
        for(int i = 1; i < nums.length; i++){
        	if(nums[i] != nums[res]){
        		nums[++res] = nums[i];
        	}
        }
        return ++res;
    }
}
```

### remove element rust

```rust
impl Solution {


    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {
        let mut index = 0;
        for i in 0..nums.len() {
            if nums[i] != val {
                nums[index] = nums[i];
                index += 1;
            }
        }
        index as i32
    }
}
```

### remove element java

```java
class Solution {
    public int removeElement(int[] nums, int val) {

        int i = 0;
        int last = nums.length;
        while (i < last){
            if (nums[i] == val){
                while (i < last && nums[--last] == val){}
                if (i < last){
                    nums[i] ^= nums[last];
                    nums[last] ^= nums[i];
                    nums[i] ^= nums[last];
                }else{
                    break;
                }
            }else {
                i++;
            }
        }
        return i;
    }
}
```

### implement strstr java

```java
class Solution {
    public int strStr(String haystack, String needle) {
        return haystack.indexOf(needle);
    }
}
```

### divide two integers java

```java
public class Solution {
    public int divide(int dividend, int divisor) {
        if(divisor == 1) return dividend;
        if(divisor == 0 || (divisor == -1 && dividend == Integer.MIN_VALUE)) return Integer.MAX_VALUE;
        int sign = (dividend < 0) ^ (divisor < 0)? -1: 1;
        int res = 0;
        long m = Math.abs((long)dividend);
        long n = Math.abs((long)divisor);
        if(m < n) return 0;
        if(m == n) return sign;
        while(m >= n){
        	long sub = n;
        	int subR = 1;
        	while(m >= (sub << 1)){
        		sub <<= 1;
        		subR <<= 1;
        	}
        	m -= sub;
        	res += subR;
        }
        return res * sign;
    }
}
```

### substring with concatenation of all words java

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> ans = new ArrayList<>();
        int n = words.length;
        int wlen = words[0].length();
        Map<String, Long> cnts = Arrays.stream(words).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));

        outer: for (int i = 0; i <= s.length() - n * wlen; i++) {
            HashMap<String, Long> copy = new HashMap<>(cnts);
            for (int j = i; j < i + n * wlen; j += wlen) {
                if (copy.computeIfPresent(s.substring(j, j + wlen), (k, v) -> v <= 0? null: --v) == null) {
                    continue outer;
                }
            }
            ans.add(i);
        }
        return ans;
    }
}
```

### next permutation rust

```rust
impl Solution {
    
    pub fn next_permutation(nums: &mut Vec<i32>) {
        let len = nums.len();
        let mut i = len;
        for j in (1..len).rev() {
            if nums[j] > nums[j - 1] {
                i = j - 1;
                break;
            }
        }
        if i == len {
            nums.reverse();
            return;
        }
        let mut p = nums.len() - 1;
        while p > i && nums[p] <= nums[i] {
            p -= 1;
        }
        nums.swap(i, p);
        (&mut nums[i+1..len]).reverse();

    }

}
```

### next permutation java

```java
public class Solution {
    public void nextPermutation(int[] nums) {
        int index = -1;
        for (int i = nums.length - 1; i > 0; i--) {
            if(nums[i] > nums[i - 1]){
                index = i - 1;
                break;
            }
        }
        if (index == -1){
            Arrays.sort(nums);
            return;
        }
        int minIndex = index + 1;
        for (int i = index + 1; i < nums.length; i++) {
            if(nums[i] < nums[minIndex] && nums[i] > nums[index]) minIndex = i;
        }
        int t = nums[minIndex];
        nums[minIndex] = nums[index];
        nums[index] = t;
        Arrays.sort(nums, index + 1, nums.length);
    }
}
```

### longest valid parentheses rust

```rust
impl Solution {
    
    pub fn longest_valid_parentheses(s: String) -> i32 {
        let n = s.len() as i32;
        let mut ans = 0;
        let mut dp =  vec![0; n as usize];
        for i in 1..n {
            if s.as_bytes()[i as usize] == b')' {
                if s.as_bytes()[i as usize - 1] == b'(' {
                    dp[i as usize] = 2 + if i >= 2 {dp[i as usize - 2]} else {0};
                } else {
                    if i - dp[i as usize - 1] - 1 >= 0 && s.as_bytes()[(i - dp[i as usize - 1] - 1) as usize] == b'(' {
                        dp[i as usize] = dp[i as usize - 1] + 2 + if i - dp[i as usize - 1] - 2 >= 0 {dp[(i - dp[i as usize - 1] - 2) as usize]} else {0};
                    }
                }
                ans = ans.max(dp[i as usize]);
            }
        }
        ans
    }

}
```

### longest valid parentheses java

```java
class Solution {
    public int longestValidParentheses(String s) {
        int ans = 0;
        Deque<Integer> deque = new LinkedList<>();
        deque.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '('){
                deque.push(i);
            }else {
                deque.pop();
                if (deque.isEmpty()){
                    deque.push(i);
                }else {
                    ans = Math.max(ans, i - deque.peek());
                }
            }
        }
        return ans;
    }
}
```

### search in rotated sorted array rust

```rust
impl Solution {

    pub fn search(nums: Vec<i32>, target: i32) -> i32 {
        let n = nums.len() as i32;
        let mut left = 0i32;
        let mut right = n - 1;

        while left <= right {
            let mid = left + (right - left) / 2;
            let (lv, rv, mv) = (nums[left as usize], nums[right as usize], nums[mid as usize]);
            if lv <= rv {
                match mv.cmp(&target) {
                    std::cmp::Ordering::Less => left = mid + 1,
                    std::cmp::Ordering::Greater => right = mid - 1,
                    _ => return mid,
                }
            } else {
                if right - left < 3 {
                    let a: Vec<&i32>= nums[left as usize..=right as usize].iter().collect();
                    match a.iter().enumerate().filter(|&(_, &&x)| x == target).next() {
                        Some((i, _)) => return i as i32 + left,
                        _ => return -1,
                    }
                }
                if (mv < rv && (target < mv || target >= lv))
                 || (mv > rv && target >= lv && target < mv) {
                    right = mid - 1;
                } else {
                    left = mid;
                }
            }
        }
        -1
    }
}
```

### search in rotated sorted array java

```java
class Solution {
    public int search(int[] nums, int target) {
        return aux(nums, target, 0, nums.length - 1);
    }

    private int aux(int[] nums, int target, int left, int right) {
        int mid = 0;
        while (left <= right){
            mid = (left + right) >> 1;
            if (nums[mid] == target){
                return mid;
            }
            if (nums[left] > nums[right]){
                if (target < nums[left] && target > nums[mid]){
                    left = mid + 1;
                }else if (target > nums[right] && target < nums[mid]){
                    right = mid - 1;
                }else {
                    int tleft = aux(nums, target, left, mid - 1);
                    if (tleft >= 0) {
                        return tleft;
                    }
                    int tright = aux(nums, target, mid + 1, right);
                    if (tright >= 0) {
                        return tright;
                    }
                    return -1;
                }
            }else{
                if (nums[mid] > target){
                    right = mid - 1;
                }else {
                    left = mid + 1;
                }
            }
        }
        return -1;
    }
}
```

### find first and last position of element in sorted array rust

```rust
impl Solution {

    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {
        let a: i32 = match nums.binary_search(&target) {
            Ok(n) => n as i32,
            _ => -1,
        };
        if a < 0 {
            return vec![-1, -1];
        }
        let mut ans = vec![];
        {
            let mut left = 0;
            let mut right = a;
            while left <= right {
                let mid = left + (right - left) / 2;
                if nums[mid as usize] == target {
                    right = mid - 1;
                }else{
                    left = mid + 1;
                }
            }
            ans.push(left);
        }
        {
            let mut left = a;
            let mut right = nums.len() as i32 - 1;
            while left <= right {
                let mid = left + (right - left) / 2;
                if nums[mid as usize] == target {
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }
            ans.push(right);
        }

        ans
    }
}
```

### find first and last position of element in sorted array java

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        return searchRange(nums, target, 0, nums.length - 1);
    }

    private int[] searchRange(int[] nums, int target, int left, int right) {
        int mid = 0;
        while (left <= right){
            mid = left + ((right - left) >> 1);
            if (target > nums[mid]){
                left = mid + 1;
            }else if (target < nums[mid]){
                right = mid - 1;
            }else {
                int[] ansl = searchRange(nums, target, left, mid - 1);
                int[] ansr = searchRange(nums, target, mid + 1, right);

                int[] ans = {mid, mid};
                if (ansl[0] >= 0){
                    ans[0] = ansl[0];
                }
                if (ansr[1] >= 0){
                    ans[1] = ansr[1];
                }
                return ans;
            }
        }
        return left > right? new int[]{-1, -1}: new int[]{left, right};
    }
}
```

### search insert position rust

```rust
impl Solution {

    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {
        let mut left: i32 = 0;
        let mut right= (nums.len() - 1) as i32;
        while left <= right {
            let mut mid = left + ((right - left) >> 1);
            match nums[mid as usize].cmp(&target) {
                std::cmp::Ordering::Greater => right = mid - 1,
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Equal => {
                    while mid >= 0 && nums[mid as usize] == target {
                        mid -= 1;
                    }
                    return mid + 1;
                },
            }
        }
        left as i32
    }

}
```

### search insert position java

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right){
            int mid = left + ((right - left) >> 1);
            if (nums[mid] > target){
                right = mid - 1;
            }else if (nums[mid] < target){
                left = mid + 1;
            }else {
                return mid;
            }
        }
        return left;
    }
}
```

### valid sudoku java

```java
public class Solution {
    public boolean isValidSudoku(char[][] board) {
        boolean[][] flagx = new boolean[9][10];
        boolean[][] flagy = new boolean[9][10];

        for(int i = 0; i < 9; i++){
            for (int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {
                    if (flagx[i][board[i][j] - '0']) {
                        return false;
                    } else {
                        flagx[i][board[i][j] - '0'] = true;
                    }
                    if (flagy[j][board[i][j] - '0']) {
                        return false;
                    } else {
                        flagy[j][board[i][j] - '0'] = true;
                    }
                }

            }
        }

        for (int i = 0; i < 9; i += 3) {
            for (int j = 0; j < 9; j += 3) {
                boolean[] flag = new boolean[10];
                for (int m = 0; m < 3; m++) {
                    for (int n = 0; n < 3; n++) {
                        if(board[i + m][j + n] == '.') continue;
                        if(flag[board[i + m][j + n] - '0']) return false;
                        flag[board[i + m][j + n] - '0'] = true;
                    }
                }
            }
        }
        return true;
    }
}
```

### sudoku solver java

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Solution {
    
    public void solveSudoku(char[][] board) {
        solve(board, 0, 0);
    }

    private List<Character> getValue(char[][] board, int i, int j){
        int x = i / 3 * 3;
        int y = j / 3 * 3;
        boolean[] flags = new boolean[10];
        Arrays.fill(flags, true);
        for(int k = 0; k < 9; k++){
            if(board[i][k] != '.') flags[board[i][k] - '0'] = false;
            if(board[k][j] != '.') flags[board[k][j] - '0'] = false;
        }
        for(int m = x; m < x + 3; m++){
            for(int n = y; n < y + 3; n++){
                if(board[m][n] != '.') flags[board[m][n] - '0'] = false;
            }
        }
        List<Character> list = new ArrayList<Character>();
        for(int k = 1; k < 10; k++){
            if(flags[k]) list.add((char) (k + '0'));
        }
        return list;
    }

    private boolean solve(char[][] board, int i, int j){
        if(i == 9) return true;
        if(board[i][j] == '.'){
            List<Character> list = getValue(board, i, j);
            if(list.size() != 0) {
                int jj = j + 1;
                for (char c : list) {
                    board[i][j] = c;
                    if (solve(board, i + jj / 9, jj % 9)) {
                        return true;
                    }
                }
                board[i][j] = '.';
            }
            return false;
        }
        j++;
        return solve(board, i + j / 9, j % 9);
    }
}
```

### count and say java

```java
class Solution {
    public String countAndSay(int n) {
        String s = "1";

        while (--n > 0){
            int cnt = 0;
            char last = s.charAt(0);
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < s.toCharArray().length; i++) {
                if (s.charAt(i) == last){
                    cnt++;
                }else{
                    builder.append(cnt).append(last);
                    last = s.charAt(i);
                    cnt = 1;
                }
            }
            builder.append(cnt).append(last);
            s = builder.toString();
        }

        return s;
    }
}
```

### combination sum rust

```rust
impl Solution {

    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        fn dfs(cs: & Vec<i32>, target: i32, from: usize, cur: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {
            if target < 0 || from >= cs.len() {
                return;
            } else if target == 0{
                ans.push(cur.clone());
                return;
            }
            dfs(cs, target, from + 1, cur, ans);
            cur.push(cs[from]);
            dfs(cs, target - cs[from], from, cur, ans);
            cur.remove(cur.len() - 1);
        }
        let mut ans = vec![];
        dfs(&candidates, target, 0, &mut vec![], &mut ans);
        ans
    }
}
```

### combination sum java

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        return combinationSum(candidates, 0, target);
    }


    public List<List<Integer>> combinationSum(int[] candidates, int from, int target) {
        if (target <= 0){
            return Collections.emptyList();
        }
        List<List<Integer>> lists = new ArrayList<>();
        for (int i = from; i < candidates.length; i++) {
            int t = candidates[i];
            if (target == t){
                List<Integer> inner = new ArrayList<>();
                inner.add(t);
                lists.add(inner);
            }else {
                List<List<Integer>> tmp = combinationSum(candidates, i, target - t);
                tmp.forEach(x -> x.add(t));
                lists.addAll(tmp);
            }
        }
        return lists;
    }
}
```

### combination sum ii java

```java
class Solution {
    

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> ans = new ArrayList<>();
        dfs(candidates, new ArrayList<>(), 0, target, ans);
        return ans;
    }

    private void dfs(int[] candidates, List<Integer> cur, int from, int target, List<List<Integer>> ans) {
        if (target == 0){
            ans.add(new ArrayList<>(cur));
            return;
        }
        if (from >= candidates.length || target < 0){
            return;
        }
        for (int i = from; i < candidates.length; i++) {
            if (i > from && candidates[i] == candidates[i - 1]){
                continue;
            }
            if (target >= candidates[i]) {
                cur.add(candidates[i]);
                dfs(candidates, cur, i + 1, target - candidates[i], ans);
                cur.remove(cur.size() - 1);
            }
        }
    }

}
```

### first missing positive java

```java
public class Solution {
    public int firstMissingPositive(int[] nums) {
    	int n = nums.length;
    	int fillNum = n + 1;
    	for(int i = 0; i < n; i++){
    		if(nums[i] < 1 || nums[i] > n){
    			nums[i] = fillNum;
    		}
    	}
    	for(int i = 0; i < n; i++){
    		int t = Math.abs(nums[i]);
    		if(t == fillNum) continue;
    		int val = Math.abs(nums[t - 1]);
    		nums[t - 1] = -val;
    	}
    	for(int i = 0; i < n; i++){
    		if(nums[i] > 0) return i + 1;
    	}
    	return fillNum;
    }
}
```

### trapping rain water rust

```rust
impl Solution {

    pub fn trap(height: Vec<i32>) -> i32 {
        let n = height.len();
        let mut q = vec![];
        let mut ans = 0;
        for i in 0..n {
            if q.is_empty() {
                q.push(i);
                continue;
            }
            if height[*q.last().unwrap() as usize] <= height[i] {
                let last = q.pop().unwrap();
                for j in last+1..i {
                    ans += height[last] - height[j];
                }
                q.push(i);
            }
        }
        if let Some(end) = q.pop() {
            for i in (end..n).rev() {
                if q.is_empty() {
                    q.push(i);
                    continue;
                }
                if height[*q.last().unwrap() as usize] <= height[i] {
                    let last = q.pop().unwrap();
                    for j in i+1..last {
                        ans += height[last] - height[j];
                    }
                    q.push(i);
                }
            }
        }

        ans

    }

}
```

### trapping rain water java

```java
class Solution {
    public int trap(int[] height) {
        int ret = 0;
        int start = 0;
        List<Integer> q = new LinkedList<>();
        for (int i = start + 1; i < height.length; i++) {
            if (height[i] >= height[start]){
                for (int j = start + 1; j < i; j++) {
                    ret += height[start] - height[j];
                }
                start = i;
                q.clear();
            } else if (q.isEmpty()){
                q.add(i);
            } else {
                int size = q.size();
                for (int j = 0; j <= size; j++) {
                    if (j == size){
                        q.add(i);
                    }else if (height[i] >= height[q.get(j)]) {
                        q.set(j, i);
                        for (int k = j + 1; k < q.size();) {
                            q.remove(k);
                        }
                        break;
                    }
                }
            }
        }
        q.add(0, start);
        for (int i = 0; i < q.size() - 1; i++) {
            int h = height[q.get(i + 1)];
            for (int j = q.get(i) + 1; j < q.get(i + 1); j++) {
                ret += h - height[j];
            }
        }

        return ret;
    }
}
```

### multiply strings java

```java
class Solution {
    public String multiply(String num1, String num2) {
        if (Objects.equals(num1, "0") || Objects.equals(num2, "0")){
            return "0";
        }
        int[] ans = new int[num1.length() + num2.length()];
        char[] n1 = num1.toCharArray();
        char[] n2 = num2.toCharArray();

        for (int i = n1.length - 1; i >= 0; i--) {
            for (int j = n2.length - 1; j >= 0; j--) {
                ans[i + j + 1] += (n1[i] - '0') * (n2[j] - '0');
            }
        }

        for (int i = ans.length - 1; i >= 1; i--) {
            ans[i - 1] += ans[i] / 10;
            ans[i] %= 10;
        }

        int index = ans[0] == 0? 1: 0;
        StringBuilder sb = new StringBuilder();
        while (index < ans.length){
            sb.append(ans[index++]);
        }
        return sb.toString();
    }
}
```

### wildcard matching java

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int n = s.length();
        int m = p.length();
        boolean[][] dp = new boolean[n + 1][m + 1];
        dp[0][0] = true;
        for (int j = 1; j <= m; j++) {
            if ('*' == p.charAt(j - 1)){
                dp[0][j] = dp[0][j - 1];
            }
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if ('?' == p.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }else if ('*' == p.charAt(j - 1)){
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j - 1] || dp[i - 1][j];
                }else {
                    dp[i][j] = dp[i - 1][j - 1] && s.charAt(i - 1) == p.charAt(j - 1);
                }
            }
        }
        return dp[n][m];
    }
}
```

### jump game ii java

```java
class Solution {
    public int jump(int[] nums) {

        if (nums.length <= 1){
            return 0;
        }
        int maxstep = 0;
        int curend = 0;
        int step = 0;

        int n = nums.length;
        for (int i = 0; i < n; i++) {
            maxstep = Math.max(maxstep, i + nums[i]);
            if (curend == i){
                curend = maxstep;
                maxstep = 0;
                step++;
                if (curend >= n - 1){
                    break;
                }
            }
        }

        return step;
    }
}
```

### permutations rust

```rust
impl Solution {

    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {
        fn dfs(nums: &mut Vec<i32>, cur: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>, vist: &mut Vec<bool>) {
            if cur.len() == nums.len() {
                ans.push(cur.clone());
                return;
            }
            for i in 0..nums.len() {
                if !vist[i] {
                    vist[i] = true;
                    cur.push(nums[i]);
                    dfs(nums, cur, ans, vist);
                    cur.remove(cur.len() - 1);
                    vist[i] = false;
                }
            }
        }
        let n = nums.len();
        let mut nums = nums;
        let mut ans = vec![];
        dfs(&mut nums, &mut vec![], &mut ans, &mut vec![false; n]);
        ans
    }
}
```

### permutations java

```java
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        List<List<Integer>> tmp = new ArrayList<List<Integer>>();
        List<Integer> res = new ArrayList<Integer>();
        for (int i: nums) res.add(i);
        recu(ans, tmp, res);
        return ans;
    }

    private void recu(List<List<Integer>> ans, List<List<Integer>> tmp, List<Integer> res){
        if(res.size() == 0){
            ans.addAll(tmp);
        }
        for(int i: res){
            List<List<Integer>> term = new ArrayList<List<Integer>>();
            if(tmp.size() == 0){
                List<Integer> list = new ArrayList<Integer>();
                list.add(i);
                term.add(list);
            }else{
                for (List<Integer> l: tmp){
                    List<Integer> t = new ArrayList<Integer>(l);
                    t.add(i);
                    term.add(t);
                }
            }
            List<Integer> next = new ArrayList<Integer>(res);
            next.remove(new Integer(i));
            recu(ans, term, next);
        }
    }

}
```

### permutations ii java

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        if (nums.length == 1){
            List<List<Integer>> list = new ArrayList<>();
            List<Integer> e = new ArrayList<>();
            e.add(nums[0]);
            list.add(e);
            return list;
        }
        List<List<Integer>> result = new ArrayList<>();
        Set<Integer> c = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (c.contains(num)){
                continue;
            }
            c.add(num);
            int[] ret = Arrays.copyOf(nums, nums.length - 1);
            System.arraycopy(nums, i + 1, ret, i, ret.length - i);
            List<List<Integer>> lists = permuteUnique(ret);
            for (List<Integer> list : lists) {
                list.add(num);
            }
            result.addAll(lists);
        }
        return result;

    }
}
```

### rotate image rust

```rust
impl Solution {
    
    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {
        let n = matrix.len();
        let n1 = n - 1;
        for i in 0..n/2 {
            for j in 0..(n+1)/2 {
                let (a, b, c, d) = (matrix[i][j], matrix[j][n1-i], matrix[n1-i][n1-j], matrix[n1-j][i]);
                matrix[i][j] = d;
                matrix[j][n1-i] = a;
                matrix[n1-i][n1-j] = b;
                matrix[n1-j][i] = c;
            }
        }
    }
}
```

### rotate image java

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int m = n - 1;
        for (int i = 0; i < (n + 1) / 2; i++) {
            for (int j = 0; j < n / 2; j++) {
                int a = matrix[i][j];
                matrix[i][j] = matrix[m - j][i];
                matrix[m - j][i] = matrix[m - i][m - j];
                matrix[m - i][m - j] = matrix[j][m - i];
                matrix[j][m - i] = a;
            }
        }
    }
}
```

### group anagrams rust

```rust
use std::iter::FromIterator;
impl Solution {
    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {
        let mut map: std::collections::HashMap<String, usize>= std::collections::HashMap::new();
        let mut ans = vec![];
        for st in strs {
            let mut a: Vec<char> = st.chars().collect();
            a.sort_unstable();
            let a = String::from_iter(a.iter());
            let i = *map.entry(a).or_insert_with(|| {
                ans.push(vec![]);
                ans.len() - 1
            });
            ans[i].push(st);
        }
        ans
    }
}
```

### group anagrams java

```java
public class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        
        List<List<String>> res = new ArrayList<>();
        Map<String, List<String>> map = new HashMap<>();
        Arrays.sort(strs);
        for(String s: strs){
            char[] cs = s.toCharArray();
            Arrays.sort(cs);
            String tmp = new String(cs);
            if(map.containsKey(tmp)){
                map.get(tmp).add(s);
            }else{
                List<String> list = new ArrayList<>();
                list.add(s);
                map.put(tmp, list);
            }
        }
        return new ArrayList<>(map.values());
    }
}
```

### powx n java

```java
public class Solution {
    public double myPow(double x, int n) {
    	if(x == 1) return 1;
    	if(x == -1) return (n & 1) != 0? -1: 1;
    	if(x == 0) return 0;
        if(n < 0){return myPow(1 / x, -n);}
        if(n == 0) return 1;
        if(n == 1) return x;
        if(n == 2) return x * x;
        if(n == 3) return x * x * x;
        double res = myPow(x, n / 2);
        return res * res * (n % 2 == 1? x: 1);
    }
}
```

### n queens java

```java
public class Solution {
    public List<List<String>> solveNQueens(int n) {
        int term = (1 << n) - 1;
        int[] coo = new int[n];
        solve(term, 0, coo, 0, 0);
        System.out.println(res);
        return res;
    }
    private List<List<String>> res = new ArrayList<List<String>>();
    private int getCode(int[] co){
        int s =0;
        for (int i: co) s |= i;
        return s;
    }
    private void solve(int term, int index, int[] coo, int rl, int ll){
        int co = getCode(coo);
        if(term == co){
            List<String> l = new ArrayList<String>();
            for(int i: coo) {
                StringBuilder sb = new StringBuilder();
                sb.append(Integer.toBinaryString(i));
                while(sb.length() < index){
                    sb.insert(0, "0");
                }
                l.add(sb.toString().replace("1", "Q").replace("0", "."));
            }
            res.add(l);
        }else{
            int res = term & ~(co | rl | ll);
            while(res > 0){
                int p = res & -res;
                coo[index] = p;
                solve(term, index + 1, coo, (rl | p) >> 1, (ll | p) << 1);
                coo[index] = 0;
                res &= ~p;
            }
        }
    }

}
```

### n queens ii java

```java
class Solution {
    
    private int ans = 0;
    public int totalNQueens(int n) {
        int target = (1 << n) - 1;
        dfs(target, 0, 0, 0);
        return ans;
    }

    private void dfs(int target, int from, int left, int right) {
        if (target == 0){
            ans++;
        }
        int avail = target & (~left) & (~right);
        while (avail > 0){
            int c = Integer.lowestOneBit(avail);
            dfs(target & ~c, from + 1, (left | c) << 1, (right | c) >> 1);
            avail &= ~c;
        }
    }
}
```

### maximum subarray rust

```rust
impl Solution {

    pub fn max_sub_array(nums: Vec<i32>) -> i32 {
        let mut ans = nums[0];
        let mut ret = ans;
        for idx in 1..nums.len() {
            let i = nums[idx];
            if ans + i < i {
                ans = i;
            } else {
                ans += i;
            }
            ret = std::cmp::max(ans, ret);
        }
        ret
    }


}
```

### maximum subarray java

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int s = 0;
        int ans = nums[0];
        for (int num : nums) {
            s = s > 0? s + num: num;
            ans = Math.max(s, ans);
        }

        return ans;
    }
}
```

### spiral matrix java

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> ans = new ArrayList<>();
        int l = 0, r = matrix[0].length - 1;
        int up = 0, down = matrix.length - 1;
        while (l <= r && up <= down) {
            for (int i = l; i <= r; i++) {
                ans.add(matrix[up][i]);
            }
            up++;
            if (up > down){
                break;
            }
            for (int i = up; i <= down; i++) {
                ans.add(matrix[i][r]);
            }
            r--;
            if (l > r){
                break;
            }
            for (int i = r; i >= l; i--) {
                ans.add(matrix[down][i]);
            }
            down--;
            if (up > down){
                break;
            }
            for (int i = down; i >= up; i--) {
                ans.add(matrix[i][l]);
            }
            l++;
        }
        return ans;
    }    
}
```

### jump game rust

```rust
impl Solution {

    pub fn can_jump(nums: Vec<i32>) -> bool {
        let mut end = nums[0] as usize;
        let mut dep = nums[0] as usize;

        let mut i = 0;
        while i <= end as usize {
            if i == end {
                dep = dep.min(nums.len() - 1);
                end = dep + nums[dep] as usize;
            }
            dep = dep.max(i + nums[i] as usize);
            if dep >= nums.len() - 1 {
                return true;
            }
            i += 1;
        }

        false
    }

}
```

### jump game java

```java
public class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length == 1) return true;
        int max = 0;

        for (int i = 0; i < nums.length; i++) {
            if(i > max || (i == max && nums[i] == 0)) return false;
            if(i + nums[i] > max){
                max = i + nums[i];
            }
            if(max >= nums.length - 1) return true;
        }
        return true;
    }
}
```

### merge intervals rust

```rust
impl Solution {
    pub fn merge(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut t = intervals;
        t.sort_unstable_by(|a, b| a[0].cmp(&b[0]).then(a[1].cmp(&b[1])));
        let mut ans = vec![];
        let mut last_max = 0;
        for i in &t {
            if ans.is_empty() {
                ans.push(i.clone());
                last_max = ans[0][1];
            }else {

                let tmp = last_max.max(i[1]);
                if i[0] > last_max {
                    ans.push(i.clone());
                } else {
                    ans.last_mut().unwrap()[1] = tmp;
                }
                last_max = tmp;
            }
        }
        ans
    }
}
```

### merge intervals java

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparing(x -> x[0]));
        List<int[]> ans = new ArrayList<>();

        for (int[] interval : intervals) {
            if (ans.isEmpty() || ans.get(ans.size() - 1)[1] < interval[0]){
                ans.add(interval);
            }else{
                ans.get(ans.size() - 1)[1] = Math.max(interval[1], ans.get(ans.size() - 1)[1]);
            }
        }
        return ans.toArray(new int[0][0]);
    }
}
```

### insert interval java

```java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
        if(intervals.size() == 0){
            intervals.add(newInterval);
            return intervals;
        }
        int sIndex = search(intervals, newInterval.start, true);
        int eIndex = search(intervals, newInterval.end, false);
        if(sIndex == intervals.size()){
            intervals.add(newInterval);
            return intervals;
        }
        if(eIndex == -1){
            intervals.add(0, newInterval);
            return intervals;
        }
        int newStart = sIndex == -1? newInterval.start: Math.min(intervals.get(sIndex).start, newInterval.start);
        int newEnd = eIndex == intervals.size()? newInterval.end: Math.max(intervals.get(eIndex).end, newInterval.end);
        sIndex = Math.max(sIndex, 0);
        eIndex = Math.min(eIndex, intervals.size() - 1);
        int count = eIndex - sIndex + 1;
        newInterval = new Interval(newStart, newEnd);
        while(count-- > 0){
            intervals.remove(sIndex);
        }
        intervals.add(sIndex, newInterval);
        return intervals;
    }

    private int search(List<Interval> intervals, int value, boolean before){
        int hi = intervals.size() - 1;
        int lo = 0;
        int mid = 0;
        while(lo <= hi){
            mid = lo + (hi - lo) / 2;
            Interval t = intervals.get(mid);
            if(t.start <= value && t.end >= value) return mid;
            if(value < t.start) hi = mid - 1;
            if(value > t. end) lo = mid + 1;
        }
        if(value < intervals.get(0).start) return -1;
        if(value > intervals.get(intervals.size() - 1).end) return intervals.size();
        if(before) return hi + 1;
        else return lo - 1;
    }
}
```

### length of last word java

```java
public class Solution {
    public int lengthOfLastWord(String s) {
        if(s == null) return 0;
        s = s.trim();
        if(s.contains(" ")){
            return s.substring(s.lastIndexOf(' ') + 1).length();
        }else return s.length();
    }
}
```

### spiral matrix ii java

```java
class Solution {
    public int[][] generateMatrix(int n) {
        List<Integer> ans = new ArrayList<>();
        int[][] matrix = new int[n][n];
        int l = 0, r = matrix[0].length - 1;
        int up = 0, down = matrix.length - 1;
        int num = 0;
        while (l <= r || up <= down) {
            for (int i = l; i <= r; i++) {
                matrix[up][i] = ++num;
            }
            up++;
            if (up > down){
                break;
            }
            for (int i = up; i <= down; i++) {
                matrix[i][r] = ++num;
            }
            r--;
            if (l > r){
                break;
            }
            for (int i = r; i >= l; i--) {
                matrix[down][i] = ++num;
            }
            down--;
            if (up > down){
                break;
            }
            for (int i = down; i >= up; i--) {
                matrix[i][l] = ++num;
            }
            l++;
        }
        return matrix;
    }
}
```

### permutation sequence java

```java
public class Solution {
    public String getPermutation(int n, int k) {
        List<Integer> list = new LinkedList<Integer>();
        for (int i = 1; i <= n; i++) {
            list.add(i);
        }
        k--;
        StringBuilder sb = new StringBuilder();
        for (int i = n; i > 0; i--) {
            int j = calA(i - 1);
            sb.append(list.remove(k / j));
            k %= j;
        }
        return sb.toString();
    }
    private int calA(int n){
        return n == 1 || n == 0? 1: n * calA(n - 1);
    }

}
```

### rotate list java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null || k == 0){
            return head;
        }

        int n = 1;
        ListNode m = head;
        while (m.next != null){
            n++;
            m = m.next;
        }
        k %= n;
        if (k == 0){
            return head;
        }
        
        k = n - k;
        ListNode mm = head;
        while (--k > 0){
            mm = mm.next;
        }
        ListNode ans = mm.next;
        mm.next = null;
        m.next = head;
        return ans;

    }
}
```

### unique paths rust

```rust
impl Solution {
    pub fn unique_paths(m: i32, n: i32) -> i32 {
        let mut c = m + n - 2;
        let mut a = m.min(n) - 1;

        let mut ans = 1i64;
        let mut down = 1;
        while down <= a {
            ans = ans * c as i64 / down as i64;
            c -= 1;
            down += 1;
        }
        ans as i32
    }
}
```

### unique paths java

```java
class Solution {
    public int uniquePaths(int m, int n) {
      int[] s = new int[m + 1];
      s[1] = 1;
        for (int j = 0; j < n; j++) {
            for (int i = 1; i < s.length; i++) {
                s[i] += s[i - 1];
            }
        }
        return s[m];
    }
}
```

### unique paths ii java

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;

        int[] s = new int[m + 1];
        s[1] = 1;
        for (int j = 0; j < n; j++) {
            for (int i = 1; i < s.length; i++) {
                if (obstacleGrid[i - 1][j] == 1){
                    s[i] = 0;
                }else {
                    s[i] += s[i - 1];
                }
            }
        }
        return s[m];
    }
}
```

### minimum path sum rust

```rust
impl Solution {

pub fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 {
    let mut grid = grid;
    let m = grid.len();
    let n = grid[0].len();
    for i in 0..m {
        for j in 0..n {
            let mut c = 0;
            if i > 0 {
                if c == 0 {c = grid[i - 1][j]} else {c = c.min(grid[i - 1][j]);}
            }
            if j > 0 {
                if c == 0 {c = grid[i][j - 1]} else {c = c.min(grid[i][j - 1]);}
            }
            grid[i][j] += c;
        }
    }
    grid[m - 1][n - 1]
}
}
```

### minimum path sum java

```java
class Solution {
    public int minPathSum(int[][] grid) {
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (i + j == 0){
                    continue;
                }
                int t = Integer.MAX_VALUE;
                if (i > 0){
                    t = Math.min(t, grid[i - 1][j]);
                }
                if (j > 0){
                    t = Math.min(t, grid[i][j - 1]);
                }
                grid[i][j] += t;
            }
        }
        return grid[grid.length - 1][grid[0].length - 1];
    }
}
```

### valid number java

```java
class Solution {
    public boolean isNumber(String s) {
        return s.matches("[+-]?(\\d+|\\d+\\.|\\.\\d+|\\d+\\.\\d+)([eE][+-]?\\d+)?$");
    }
}
```

### plus one rust

```rust
impl Solution {

    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {
        let mut ds = digits;
        let mut p = 1;

        for i in (0..ds.len()).rev() {
            ds[i] += p;
            if ds[i] > 9 {
                ds[i] = 0;
            }else {
                p = 0;
                break;
            }
        }

        if p > 0 {
            ds.insert(0, p);    
        }

        ds
    }

}
```

### plus one java

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int last = 1;
        int i = digits.length - 1;
        while (i >= 0 && last > 0) {
            if (digits[i] < 9){
                digits[i] += 1;
                last = 0;
            }else{
                digits[i] = 0;
            }
            i--;
        }
        if (last > 0){
            int[] ans = new int[digits.length + 1];
            System.arraycopy(digits, 0, ans, 1, digits.length);
            ans[0] = last;
            digits = ans;
        }
        return digits;
    }
}
```

### add binary java

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int m = a.length() - 1;
        int n = b.length() - 1;

        int last = 0;
        while (m >= 0 || n >= 0){
            int aa = m >= 0? a.charAt(m--) - '0': 0;
            int bb = n >= 0? b.charAt(n--) - '0': 0;
            int c = aa + bb + last;
            if (c >= 2){
                last = 1;
                sb.append(c - 2);
            }else {
                last = 0;
                sb.append(c);
            }
        }
        if (last > 0){
            sb.append(last);
        }
        sb.reverse();
        return sb.toString();

    }
}
```

### text justification java

```java
class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {

        int count = 0;
        int length = 0;
        int i = 0;
        List ret = new ArrayList();
        while(i < words.length) {
            int templen = length;
            length += words[i].length() + (count++ > 0? 1: 0);
            if (length < maxWidth){
                if (i < words.length - 1){
                    i++;
                    continue;
                }
            }
            if (length > maxWidth){
                length = templen;
                count--;
            }else{
                i++;
            }

            int space = 0;
            int leftSpace = 0;
            boolean end = i >= words.length;
            if (count > 1) {
                space = (maxWidth - length) / (count - 1);
            }
            leftSpace = maxWidth - length - (count - 1) * space;
            StringBuilder sb = new StringBuilder();
            for (int j = count; j > 0; j--) {
                sb.append(words[i - j]);
                if (j > 1) {
                    sb.append(" ");
                    if (!end) {
                        int s = space;
                        while (s-- > 0) {
                            sb.append(" ");
                        }
                        if (leftSpace-- > 0) {
                            sb.append(" ");
                        }
                    }
                }
            }
            while (sb.length() < maxWidth){
                sb.append(" ");
            }
            if (sb.length() > 0){
                ret.add(sb.toString());
            }

            count = length = 0;
        }
        return ret;
    }
}
```

### sqrtx java

```java
public class Solution {
    public int mySqrt(int x) {
    	if(x == 0) return 0;
        if(x < 4) return 1;
        double p;
        double cur = 2;
        do{
        	p = cur;
        	cur = x / (2 * p) + p / 2.0;
        }while(Math.abs(cur - p) > .1);
        return (int)cur;
    }
}
```

### climbing stairs rust

```rust
impl Solution {
    pub fn climb_stairs(n: i32) -> i32 {
        let mut v = vec![1, 1];
        for i in 2..=n as usize {
            v.push(v[i - 1] + v[i - 2]);
        }
        return v[n as usize];
    }
}
```

### climbing stairs java

```java
public class Solution {
    public int climbStairs(int n) {
        if(n <= 0) return 0;
        if(n <= 2) return n;
        int a = 1;
        int b = 2;
        n -= 2;
        while(n-- > 0){
        	b = a + b;
        	a = b - a;
        }
        return b;
    }
}
```

### simplify path java

```java
public class Solution {
    public String simplifyPath(String path) {
        String[] paths = path.split("/");
        List<String> list = new ArrayList<String>();
        for(String s: paths){
            if(s.equals("..")){
                if (list.size() == 0) continue;
                list.remove(list.size() - 1);
            }else
            if(s.length() > 0 && !s.equals(".")){
                list.add(s);
            }
        }
        if(list.size() == 0) return "/";
        StringBuilder sb = new StringBuilder();
        for(String s: list){
            sb.append("/").append(s);
        }

        return sb.toString();
    }
}
```

### edit distance rust

```rust
impl Solution {
    pub fn min_distance(word1: String, word2: String) -> i32 {
        let m = word1.len();
        let n = word2.len();
        let mut dp = vec![vec![0; n + 1]; m + 1];
        for i in 1..=n {
            dp[0][i] = i;
        }
        for i in 1..=m {
            dp[i][0] = i;
        }

        for i in 1..=m {
            for j in 1..=n {
                if word1.as_bytes()[i - 1] == word2.as_bytes()[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + dp[i - 1][j - 1].min(dp[i][j - 1]).min(dp[i - 1][j]);
                }
            }
        }
        dp[m][n]as i32
    }

}
```

### edit distance java

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];

        IntStream.rangeClosed(1, word1.length()).forEach(i -> dp[i][0] = i);
        IntStream.rangeClosed(1, word2.length()).forEach(i -> dp[0][i] = i);

        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                int same = word1.charAt(i - 1) == word2.charAt(j - 1) ? 1 : 0;
                dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1] - same) + 1;
            }
        }
        return dp[word1.length()][word2.length()];
    }
}
```

### set matrix zeroes java

```java
public class Solution {
    public void setZeroes(int[][] matrix) {
        int[] ns = new int[matrix.length];
        int[] ms = new int[matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if(matrix[i][j] == 0){
                    ns[i] = 1;
                    ms[j] = 1;
                }
            }
        }
        for (int i = 0; i < ns.length; i++) {
            if(ns[i] == 1)
            for (int j = 0; j < matrix[0].length; j++) {
                matrix[i][j] = 0;
            }
        }
        for (int i = 0; i < ms.length; i++) {
            if(ms[i] == 1)
            for (int j = 0; j < matrix.length; j++) {
                matrix[j][i] = 0;
            }
        }
    }
}
```

### search a 2d matrix java

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int i = matrix.length - 1;
        int j = 0;
        int n = matrix[0].length;
        while (i >= 0 && j < n){
            if (matrix[i][j] > target){
                i--;
            }else if (matrix[i][j] < target){
                j++;
            }else{
                return true;
            }
        }
        return false;
    }
}
```

### sort colors rust

```rust
impl Solution {

    pub fn sort_colors(nums: &mut Vec<i32>) {
        let mut cnts = [0usize; 3];
        for i in nums.iter() {
            cnts[*i as usize] += 1;
        }
        let mut i = 0;
        for (c, num) in cnts.iter().enumerate() {
            let mut num = *num;
            while num > 0 {
                nums[i] = c as i32;
                num -= 1;
                i += 1;
            }
        }
    }
}
```

### sort colors java

```java
public class Solution {
    public void sortColors(int[] nums) {
        int lt = 0;
        int gt = nums.length - 1;
        int i = lt;
        while(i <= gt){
            if(nums[i] < 1) exchange(nums, lt++, i++);
            else if(nums[i] > 1) exchange(nums, i, gt--);
            else i++;
        }
    }
    public void exchange(int[] nums, int i, int j){
        int tmp = nums[j];
        nums[j] = nums[i];
        nums[i] = tmp;
    }
}
```

### minimum window substring rust

```rust
impl Solution {

    pub fn min_window(s: String, t: String) -> String {
        let mut map  = std::collections::HashMap::new();
        for i in t.as_bytes() {
            *map.entry(*i).or_insert(0) += 1;
        }
        let mut left = 0;
        let mut right = 0;
        let mut ans = s.len() + 1;
        let mut start = 0;
        
        let mut cnts: std::collections::HashMap<u8, i32> = std::collections::HashMap::new();
        let mut clen = map.len();
        while right < s.len() {
            let k = s.as_bytes()[right];
            if let Some(a) = map.get(&k) {
                let b = cnts.entry(k).or_insert(0);
                *b += 1;
                if b == a {
                    clen -= 1;
                }
            }
            while clen == 0 {
                let k = s.as_bytes()[left];
                left += 1;
                if let Some(&a) = map.get(&k) {
                    let b = cnts.entry(k).or_insert(0);
                    *b -= 1;
                    if *b < a {
                        clen += 1;
                        let len = right + 2 - left;
                        if len < ans {
                            ans = len;
                            start = left - 1;
                        }
                        break;
                    }
                }
            }
            right += 1;
        }

        if ans > s.len() {String::new()}else {s[start..start + ans].to_string()}
    }
}
```

### minimum window substring java

```java
public class Solution {
    public String minWindow(String s, String t) {
        if(s == null || t == null || s.length() == 0 || t.length() == 0) return "";
        Map<Character, Integer> map = new HashMap<>();
        int min = -1;
        int max = -1;
        for(char c: t.toCharArray()){
            if(!map.containsKey(c)) map.put(c, 1);
            else map.put(c, map.get(c) + 1);
        }
        int count = 0;
        int begin = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if(map.containsKey(c)){
                if(map.get(c) > 0) count++;
                map.put(c, map.get(c) - 1);
                if(count == t.length()) {
                    while (begin <= i) {
                        char cc = s.charAt(begin);
                        if (map.containsKey(cc)) {
                            map.put(cc, map.get(cc) + 1);
                            if (map.get(cc) > 0) {
                                count--;
                                if ((min == -1 && max == -1) || (max - min > i - begin)) {
                                    max = i;
                                    min = begin;
                                }
                                begin++;
                                break;
                            }
                        }
                        begin++;
                    }
                }
            }
        }
        return (min >= 0 && max >= 0)? s.substring(min, max + 1): "";
    }
}
```

### combinations java

```java
public class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        return combineNum(res, 1, n, k);
    }
    private List<List<Integer>> combineNum(List<List<Integer>> list, int from, int end, int num){
        if(num == 0) return list;
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        for(int i = from; i <= end - num + 1; i++){
            List<List<Integer>> tmp = new ArrayList<List<Integer>>();
            if(list.size() == 0){
                List<Integer> l = new ArrayList<Integer>();
                l.add(i);
                tmp.add(l);
            }else {
                for (List<Integer> l : list) {
                    List<Integer> t = new ArrayList<Integer>(l);
                    t.add(i);
                    tmp.add(t);
                }
            }
            res.addAll(combineNum(tmp, i + 1, end, num - 1));
        }
        return res;
    }
}
```

### subsets rust

```rust
impl Solution {

    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut ans = Vec::with_capacity(2usize.pow(nums.len() as u32));

        ans.push(vec![]);

        for i in nums {
            let l = ans.len();
            for j in 0..l {
                let mut c = ans[j].clone();
                c.push(i);
                ans.push(c);
            }
        }
        ans

    }
}
```

### subsets java

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        ans.add(new ArrayList<>());
        for (int num : nums) {
            List<List<Integer>> tmp = new ArrayList<>();
            for (List<Integer> an : ans) {
                ArrayList<Integer> e = new ArrayList<>(an);
                e.add(num);
                tmp.add(e);
            }
            ans.addAll(tmp);
        }
        
        return ans;
    }
}
```

### word search rust

```rust
impl Solution {

    pub fn exist(board: Vec<Vec<char>>, word: String) -> bool {
        fn dfs(board: &Vec<Vec<char>>, flags: &mut Vec<Vec<bool>>, word: &String, cur: (usize, usize), idx: usize) -> bool {
            if board[cur.0][cur.1] != word.as_bytes()[idx] as char {
                return false;
            }
            if word.len() - 1 == idx {
                return true;
            }
            flags[cur.0][cur.1] = true;
            for (x, y) in [(-1, 0), (1, 0), (0, -1), (0, 1)].iter() {
                let (xx, yy) = (cur.0 as i32 + x, cur.1 as i32 + y);
                if xx < 0 || yy < 0 || xx >= board.len() as i32 || yy >= board[0].len() as i32 || flags[xx as usize][yy as usize]{
                    continue;
                }
                if dfs(board, flags, word, (xx as usize, yy as usize), idx + 1) {
                    return true;
                }
            }
            flags[cur.0][cur.1] = false;
            false
        }
        let mut flags = vec![vec![false; board[0].len()]; board.len()];
        for i in 0..board.len() {
            for j in 0..board[0].len() {
                if dfs(&board, &mut flags, &word, (i, j), 0) {
                    return true;
                }
            }
        }
        false
    }
}
```

### word search java

```java
class Solution {
    
    public boolean exist(char[][] board, String word) {
        boolean[][] f = new boolean[board.length][board[0].length];
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == word.charAt(0)){
                    if (exist(board, i, j, f, word)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public boolean exist(char[][] board, int x, int y, boolean[][] f, String word) {
        String substring = word.substring(1);
        if (substring.isEmpty()){
            return true;
        }
        f[x][y] = true;
        int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (int i = 0; i < steps.length; i++) {
            int xx = x + steps[i][0];
            int yy = y + steps[i][1];
            if ((xx < 0 || yy < 0 || xx >= board.length || yy >= board[0].length) || f[xx][yy] || board[xx][yy] != substring.charAt(0)){
                continue;
            }

            boolean exist = exist(board, xx, yy, f, substring);
            if (exist){
                return true;
            }
        }
        f[x][y] = false;
        return false;
    }

}
```

### remove duplicates from sorted array ii java

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = 0;
        int lastIndex = 0;
        int last = nums[lastIndex];
        for (int i = 0; i < nums.length; i++) {
            if (last != nums[i] || lastIndex + 1 >= i){
                nums[n++] = nums[i];
            }
            if (last != nums[i]){
                lastIndex = i;
                last = nums[lastIndex];
            }
        }

        return n;
    }
}
```

### search in rotated sorted array ii java

```java
class Solution {
    public boolean search(int[] nums, int target) {
        return aux(nums, target, 0, nums.length - 1)>-1;
    }

    private int aux(int[] nums, int target, int left, int right) {
        int mid = 0;
        while (left <= right){
            mid = (left + right) >> 1;
            if (nums[mid] == target){
                return mid;
            }
            if (nums[left] >= nums[right]){
                if (target < nums[left] && target > nums[mid]){
                    left = mid + 1;
                }else if (target > nums[right] && target < nums[mid]){
                    right = mid - 1;
                }else {
                    int tleft = aux(nums, target, left, mid - 1);
                    if (tleft >= 0) {
                        return tleft;
                    }
                    int tright = aux(nums, target, mid + 1, right);
                    if (tright >= 0) {
                        return tright;
                    }
                    return -1;
                }
            }else{
                if (nums[mid] > target){
                    right = mid - 1;
                }else {
                    left = mid + 1;
                }
            }
        }
        return -1;
    }
}
```

### remove duplicates from sorted list ii java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode ans = null;
        ListNode cur = null;
        
        ListNode before = null;
        ListNode m = head;
        while (m != null){
            if ((before == null || before.val != m.val) && (m.next == null || m.val != m.next.val)) {
                if (ans == null) {
                    ans = m;
                    cur = m;
                } else {
                    cur.next = m;
                    cur = m;
                }
            }
            before = m;
            m = m.next;
        }
        if (cur != null){
            cur.next = null;
        }
        
        return ans;
    }
}
```

### remove duplicates from sorted list java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return null;
        ListNode res = head;
        ListNode tmp = head;
        while(head != null){
        	if(head.val != tmp.val){
        		tmp.next = head;
        		tmp = tmp.next;
        	}
        	head = head.next;
        }
        tmp.next = null;
        return res;
    }
}
```

### largest rectangle in histogram rust

```rust
impl Solution {

    pub fn largest_rectangle_area(heights: Vec<i32>) -> i32 {
        let mut ans = 0;
        let mut heights = heights;
        heights.push(0);
        let mut q: Vec<i32> = vec![];
        for i in 0..heights.len() {
            while !q.is_empty() && heights[*q.last().unwrap() as usize] > heights[i] {
                let last = q.pop().unwrap() as usize;
                let l: i32 = *q.last().unwrap_or(&-1);
                ans = ans.max((i as i32 - l - 1) * heights[last]);

            }
            q.push(i as i32);
        }

        ans
    }
}
```

### largest rectangle in histogram java

```java
class Solution {
    public int largestRectangleArea(int[] heights) {

        int r = 0;
        int[] h = new int[heights.length + 2];
        System.arraycopy(heights, 0, h, 1, heights.length);
        List<Integer> q = new ArrayList<>();
        for (int i = 0; i < h.length; i++) {
            while (!q.isEmpty() && h[q.get(q.size() - 1)] > h[i]){
                Integer last = q.remove(q.size() - 1);
                r = Math.max(r, (i - q.get(q.size() - 1) - 1) * h[last]);
            }
            q.add(i);
        }
        return r;
    }
}
```

### maximal rectangle rust

```rust
impl Solution {

    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {
        let m = matrix.len();
        if m == 0 {
            return 0;
        }
        let n = matrix[0].len();
        let mut dp = vec![vec![0; n + 1]; m + 1];
        let mut ans = 0;

        for r in 1..=m {
            for c in 1..=n {
                if matrix[r - 1][c - 1] == '1' {
                    dp[r][c] = dp[r][c - 1] + 1;
                    let mut w = dp[r][c];
                    let mut h = 1;
                    while h <= r {
                        w = w.min(dp[r - h + 1][c]);
                        if w == 0 {
                            break;
                        }
                        ans = ans.max(w * h);
                        h += 1;
                    }
                }
            }
        }

        ans as i32
    }

}
```

### maximal rectangle java

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {

        int ans = 0;
        if (matrix.length == 0){
            return ans;
        }
        int[][] dp = new int[matrix.length][matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            int t = 0;
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == '0'){
                    t = 0;
                    continue;
                }
                t++;
                dp[i][j] = t;

                int w = t;
                for (int k = i; k >= 0 && dp[k][j] > 0; k--) {
                    w = Math.min(w, dp[k][j]);
                    ans = Math.max(ans, (i - k + 1) * w);
                }
            }
        }

        return ans;
    }
}
```

### partition list java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode small = null;
        ListNode big = null;
        ListNode sTmp = null;
        ListNode bTmp = null;
        while(head != null){
            if(head.val < x){
                if(small == null){
                    small = head;
                    sTmp = head;
                }else{
                    sTmp.next = head;
                    sTmp = sTmp.next;
                }
             }else{
                if(big == null){
                    big = head;
                    bTmp = head;
                }else{
                    bTmp.next = head;
                    bTmp = bTmp.next;
                }
            }
            head = head.next;
        }
        if(small == null) return big;
        if(big == null) return small;
        sTmp.next = big;
        bTmp.next = null;
        return small;
    }
}
```

### scramble string java

```java
class Solution {
    public boolean isScramble(String s1, String s2) {
        int n = s1.length();
        boolean[][][] dp = new boolean[n + 1][n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dp[0][i], true);
            dp[i][0][0] = true;
        }

        for (int k = 1; k <= n; k++) {
            for (int i = k; i <= n; i++) {
                for (int j = k; j <= n; j++) {
                    dp[k][i][j] = dp[k - 1][i - 1][j - 1] && s1.charAt(i - 1) == s2.charAt(j - 1);
                    for (int l = 1; l < k; l++) {
                        boolean t = dp[l][i][j - k + l] && dp[k - l][i - l][j] || dp[l][i - k + l][j - k + l] && dp[k - l][i][j];
                        if (t) {
                            dp[k][i][j] = true;
                            break;
                        }
                    }
                }
            }
        }

        return dp[n][n][n];
    }
}
```

### merge sorted array java

```java
class Solution {
    
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int k = m + n;
        m--;
        n--;
        while (--k >= 0){
            if (m >= 0 && n >= 0){
                if (nums1[m] > nums2[n]){
                    nums1[k] = nums1[m--];
                }else {
                    nums1[k] = nums2[n--];
                }
            }else if (m >= 0){
                nums1[k] = nums1[m--];
            }else {
                nums1[k] = nums2[n--];
            }
        }
    }
}
```

### gray code java

```java
class Solution {
    public List<Integer> grayCode(int n) {
        if (n == 0){
            return Arrays.asList(0);
        }
        List<Integer> ans = new ArrayList<>();
        ans.add(0);
        ans.add(1);
        int[][] num = {{0, 1}, {1, 0}};
        for (int i = 1; i < n; i++) {
            ArrayList<Integer> list = new ArrayList<>();
            int index = 0;
            for (Integer an : ans) {
                list.add((num[index][0] << i) + an);
                list.add((num[index][1] << i) + an);
                index = 1 - index;
            }
            ans = list;
        }
        return ans;
    }
}
```

### subsets ii java

```java
class Solution {


    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        dfs(nums, 0, new ArrayList<>(), ans, false);
        return ans;
    }

    private void dfs(int[] nums, int from, List<Integer> a, List<List<Integer>> ans, boolean lastNoPut) {
        if (from == nums.length){
            ans.add(new ArrayList<>(a));
            return;
        }

        dfs(nums, from + 1, a, ans, true);
        if (lastNoPut && nums[from] == nums[from - 1]) {
            return;
        }
        a.add(nums[from]);
        dfs(nums, from + 1, a, ans, false);
        a.remove(a.size() - 1);
    }
    
}
```

### decode ways java

```java
class Solution {

    public int numDecodings(String s) {
        int[] bak = new int[s.length()];
        Arrays.fill(bak, -1);
        int i = numDecodings(s, bak);
//        System.out.println(Arrays.toString(bak));
        return i;
    }

    public int numDecodings(String s, int[] bak) {
        if (s.startsWith("0")){
            return 0;
        }
        if (s.length() == 1 || s.isEmpty()){
            return 1;
        }
        if (bak[bak.length - s.length()] >= 0){
            return bak[bak.length - s.length()];
        }
        int sum = numDecodings(s.substring(1), bak);
        if (s.substring(0, 2).compareTo("26") <= 0) {
            sum += numDecodings(s.substring(2), bak);
        }
        bak[bak.length - s.length()] = sum;
        return sum;
    }

}
```

### reverse linked list ii java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (head == null || head.next == null || left >= right){
            return head;
        }
        ListNode dummy = new ListNode(-1);
        dummy.next = head;

        ListNode pre = dummy;
        int left1 = left;
        while (--left1 > 0){
            pre = pre.next;
        }
        ListNode cur = pre.next;

        for (int i = 0; i < right - left; i++) {
            ListNode next = cur.next;
            cur.next = next.next;
            next.next = pre.next;
            pre.next = next;
        }
        return dummy.next;
    }
}
```

### restore ip addresses java

```java
class Solution {

    public List<String> restoreIpAddresses(String s) {
        List<String> ans = new ArrayList<>();
        dfs(s.toCharArray(), new int[4], 0, true, 0, ans);
        return ans;
    }

    private void dfs(char[] s, int[] ip, int cur, boolean first, int from, List<String> ans) {
        if ((cur == 4 || cur == 3 && !first) && from == s.length){
            ans.add(Arrays.stream(ip).mapToObj(Objects::toString).collect(Collectors.joining(".")));
            return;
        }
        if (cur >= 4 || from >= s.length || (4 - cur) * 3 - (first? 0: 1) < s.length - from || 4 - cur - 1 > s.length - from){
            return;
        }
        if (first && s[from] == '0'){
            dfs(s, ip, cur + 1, true, from + 1, ans);
            return;
        }
        int a = ip[cur] * 10 + (s[from] - '0');
        if (a > 255){
            return;
        }
        ip[cur] = a;
        dfs(s, ip, cur + 1, true, from + 1, ans);
        if (a < 100 && from < s.length - 1){
            dfs(s, ip, cur, false, from + 1, ans);
        }
        ip[cur] /= 10;
    }
}
```

### binary tree inorder traversal rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {
        let mut ans: Vec<i32> = vec![];
        Solution::dfs(root, &mut ans);
        ans
    }

    fn dfs(root: Option<Rc<RefCell<TreeNode>>>, ans: &mut Vec<i32>) -> () {
        if let Some(node) = root {
            Solution::dfs(node.borrow_mut().left.take(), ans);
            ans.push(node.borrow_mut().val);
            Solution::dfs(node.borrow_mut().right.take(), ans);
        }
    }

}
```

### binary tree inorder traversal java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root == null) return list;
        inorderTraversal(root.left);
        list.add(root.val);
        inorderTraversal(root.right);
        return list;
    }
    
	private List<Integer> list = new ArrayList<Integer>();
}
```

### unique binary search trees ii java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    

    public List<TreeNode> generateTrees(int n) {
        return dfs(1, n);

    }

    private List<TreeNode> dfs(int from, int to) {
        if (from == to){
            return Arrays.asList(new TreeNode(from));
        }
        List<TreeNode> ans = new ArrayList<>();
        if (from > to){
            ans.add(null);
            return ans;
        }
        for (int i = from; i <= to; i++) {
            List<TreeNode> left = dfs(from, i - 1);
            List<TreeNode> right = dfs(i + 1, to);
            for (TreeNode l : left) {
                for (TreeNode r : right) {
                    ans.add(new TreeNode(i, l, r));
                }
            }
        }
        return ans;
    }
}
```

### unique binary search trees rust

```rust
impl Solution {
    
    pub fn num_trees(n: i32) -> i32 {
        let mut dp = vec![0; n as usize + 1];
        dp[0] = 1;
        dp[1] = 1;
        for i in 2..=n as usize {
            let mut s = 0;
            for j in 0..i {
                s += dp[j] * dp[i - j - 1];
            }
            dp[i] = s;
        }
        dp[n as usize]
    }

}
```

### unique binary search trees java

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```

### interleaving string java

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length();
        int n = s2.length();
        if (m + n != s3.length()){
            return false;
        }
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                int p = i + j - 1;
                if (i > 0) {
                    dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(p);
                }
                if (j > 0 && !dp[j]) {
                    dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(p);
                }
            }
        }
        return dp[n];
    }
}
```

### validate binary search tree rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        fn aux(root: &mut Option<Rc<RefCell<TreeNode>>>, min: Option<i32>, max: Option<i32>) -> bool {
            if let Some(v) = root {
                let me = v.borrow().val;
                if let Some(n) = &min {
                    if n >= &me {
                        return false;
                    }
                }
                if let Some(n) = &max {
                    if n <= &me {
                        return false;
                    }
                }
                if !aux(&mut v.borrow_mut().left.take(), min, Some(me)){
                    return false;
                }
                if !aux(&mut v.borrow_mut().right.take(), Some(me), max){
                    return false;
                }
            }
            true
        }
        let mut root = root;
        aux(&mut root, None, None)
    }
}
```

### validate binary search tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    private boolean isValidBST(TreeNode root, int min, int max){
        if(root == null) return true;
        if(root.left != null && (root.left.val >= root.val || root.left.val < min)) return false;
        if(root.right != null && (root.right.val <= root.val || root.right.val > max)) return false;
        boolean leftValid = isValidBST(root.left, min, root.val - 1);
        boolean rightValid = isValidBST(root.right, root.val + 1, max);
        return leftValid && rightValid;
    }
}
```

### recover binary search tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    
    public void recoverTree(TreeNode root) {
        ArrayList<TreeNode> treeNodes = new ArrayList<>();
        aux(root, treeNodes);
        List<Integer> l = new ArrayList<>();
        for (int i = 1; i < treeNodes.size(); i++) {
            if (treeNodes.get(i - 1).val > treeNodes.get(i).val){
                l.add(i - 1);
            }
        }
        if (l.size() > 1){
            swap(treeNodes.get(l.get(0)), treeNodes.get(l.get(1) + 1));
        }else{
            swap(treeNodes.get(l.get(0)), treeNodes.get(l.get(0) + 1));
        }
    }
    
    private void swap(TreeNode a, TreeNode b){
        a.val ^= b.val;
        b.val ^= a.val;
        a.val ^= b.val;
    }

    private void aux(TreeNode root, ArrayList<TreeNode> treeNodes) {
        if (root == null){
            return;
        }
        aux(root.left, treeNodes);
        treeNodes.add(root);
        aux(root.right, treeNodes);
    }

}
```

### same tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if((p == null) && p ==q){
        	return true;
        }else if((p != null && q != null) && p.val == q.val){
        	return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }else{
        	return false;
        }
    }
}
```

### symmetric tree rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        fn is_same(r1: &Option<Rc<RefCell<TreeNode>>>, r2: &Option<Rc<RefCell<TreeNode>>>) -> bool {
            match (r1, r2) {
                (None, None) => true,
                (Some(n1), Some(n2)) => {
                    n1.borrow().val == n2.borrow().val
                    && is_same(&n1.borrow().left, &n2.borrow().right)
                    && is_same(&n1.borrow().right, &n2.borrow().left)
                },
                _ => false,
            }
        }
        if let Some(n) = root {
            is_same(&n.borrow().left, &n.borrow().right)
        }else{
            true
        }
    }


}
```

### symmetric tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        if(root.left == null && root.right == null) return true;
        if(root.left != null && root.right != null){
            List<TreeNode> list = new LinkedList<>();
            list.add(root.left);
            list.add(root.right);
            return isSymmetric(list);
        }else return false;
    }
    public boolean isSymmetric(List<TreeNode> list) {
        if(list.size() == 0) return true;
        if(list.size() % 2 != 0) return false;
        List<TreeNode> next = new LinkedList<>();
        while(list.size() != 0){
            TreeNode left = list.remove(0);
            TreeNode right = list.remove(0);
            if(left.val != right.val) return false;
            if(!(left.left == null ^ right.right == null)){
                if(left.left != null) {
                    next.add(left.left);
                    next.add(right.right);
                }
            }else return false;
            if(!(left.right == null ^ right.left == null)){
                if(left.right != null) {
                    next.add(left.right);
                    next.add(right.left);
                }
            }else return false;
        }
        return isSymmetric(next);
    }
}
```

### binary tree level order traversal rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

pub fn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {
    fn dfs(root: Option<Rc<RefCell<TreeNode>>>, ans: &mut Vec<Vec<i32>>, level: usize) {
        if let Some(t) = root {
            if ans.len() <= level {
                ans.push(vec![]);
            }
            ans[level].push(t.borrow().val);
            dfs(t.borrow_mut().left.take(), ans, level + 1);
            dfs(t.borrow_mut().right.take(), ans, level + 1);
        }
    }
    let mut ans = vec![];
    dfs(root, &mut ans, 0);
    ans
}
}
```

### binary tree level order traversal java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(root == null) return res;
        List<TreeNode> tmp = new ArrayList<TreeNode>();
        tmp.add(root);
        List<TreeNode> tmp1 = new ArrayList<TreeNode>();
        while((tmp.size() > 0)) {
            List<Integer> list = new ArrayList<Integer>();
            for (TreeNode node : tmp) {
                list.add(node.val);
                if (node.left != null) tmp1.add(node.left);
                if (node.right != null) tmp1.add(node.right);
            }
            res.add(list);
            List<TreeNode> t = tmp;
            tmp = tmp1;
            tmp1 = t;
            t.clear();
        }
        return res;
    }
}
```

### binary tree zigzag level order traversal java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        List<TreeNode> stack = new LinkedList<>();
        List<TreeNode> tmp = new LinkedList<>();
        stack.add(root);
        boolean leftToright = true;
        while(stack.size() > 0){
            List<Integer> l = new ArrayList<>();
            for(TreeNode node: stack){
                if(node.left != null) tmp.add(node.left);
                if(node.right != null) tmp.add(node.right);
                if(leftToright) l.add(node.val);
                else l.add(0, node.val);
            }
            res.add(l);
            List<TreeNode> ex = tmp;
            tmp = stack;
            stack = ex;
            tmp.clear();
            leftToright = !leftToright;
        }
        return res;
    }
}
```

### maximum depth of binary tree rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {


    pub fn max_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        if let Some(n) = root {
            let mut a = 0;
            {
                a = a.max(Solution::max_depth(n.borrow_mut().left.take()));
            }
            {
                a = a.max(Solution::max_depth(n.borrow_mut().right.take()));
            }
            a + 1
        }else {
            0
        }
    }

}
```

### maximum depth of binary tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
        	return 0;
        }else{
        	return Math.max(1 + maxDepth(root.left), 1 + maxDepth(root.right));
        }
    }
}
```

### construct binary tree from preorder and inorder traversal rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

pub fn build_tree(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {
    fn divide(preorder: &Vec<i32>, idx: &mut usize, inorder: &[i32]) -> Option<Rc<RefCell<TreeNode>>>{
        if inorder.is_empty() {
            return None;
        }
        let val = preorder[*idx];
        let mut t = TreeNode::new(val);
        let d_idx = inorder.iter().enumerate().filter(|&(i, &x)| x == val).next().unwrap().0;
        *idx += 1;
        t.left = divide(preorder, idx, &inorder[..d_idx]);
        t.right = divide(preorder, idx, &inorder[d_idx + 1..]);
        Some(Rc::new(RefCell::new(t)))
    }
    divide(&preorder, &mut 0, &inorder[0..inorder.len()])
}

}
```

### construct binary tree from preorder and inorder traversal java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTree(inorder, 0, inorder.length - 1, preorder, 0, preorder.length - 1);
    }
    public TreeNode buildTree(int[] inorder, int iStart, int iEnd, int[] preorder, int pStart, int pEnd){
        if(iStart > iEnd) return null;
        TreeNode node = new TreeNode(preorder[pStart]);
        int pos = -1;
        for (int i = iStart; i <= iEnd; i++) {
            if(inorder[i] == node.val){
                pos = i;
                break;
            }
        }
        int rightNum = iEnd - pos;
        node.left = buildTree(inorder, iStart, pos - 1, preorder, pStart + 1, pEnd - rightNum);
        node.right = buildTree(inorder, pos + 1, iEnd, preorder, pEnd - rightNum + 1, pEnd);
        return node;
    }
}
```

### construct binary tree from inorder and postorder traversal java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }
    public TreeNode buildTree(int[] inorder, int iStart, int iEnd, int[] postorder, int pstart, int pEnd){
        if(iStart > iEnd) return null;
        TreeNode node = new TreeNode(postorder[pEnd]);
        int pos = -1;
        for (int i = iStart; i <= iEnd; i++) {
            if(inorder[i] == node.val){
                pos = i;
                break;
            }
        }
        int leftNum = pos - iStart;
        node.left = buildTree(inorder, iStart, pos - 1, postorder, pstart, pstart + leftNum - 1);
        node.right = buildTree(inorder, pos + 1, iEnd, postorder, pstart + leftNum, pEnd - 1);
        return node;
    }
}
```

### binary tree level order traversal ii java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(root == null) return res;
        List<TreeNode> tmp = new ArrayList<TreeNode>();
        tmp.add(root);
        List<TreeNode> tmp1 = new ArrayList<TreeNode>();
        while((tmp.size() > 0)) {
            List<Integer> list = new ArrayList<Integer>();
            for (TreeNode node : tmp) {
                list.add(node.val);
                if (node.left != null) tmp1.add(node.left);
                if (node.right != null) tmp1.add(node.right);
            }
            res.add(0, list);
            List<TreeNode> t = tmp;
            tmp = tmp1;
            tmp1 = t;
            t.clear();
        }
        return res;
    }
}
```

### convert sorted array to binary search tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums == null ||nums.length == 0) return null;
        return sortedArrayToBST(nums, 0, nums.length - 1);
    }
    private TreeNode sortedArrayToBST(int[] nums, int begin, int end) {
        if(end < begin) return null;
        if(end - begin == 0) return new TreeNode(nums[begin]);
        int mid = begin + (end - begin) / 2;
        TreeNode res = new TreeNode(nums[mid]);
        res.left = sortedArrayToBST(nums, begin, mid - 1);
        res.right = sortedArrayToBST(nums, mid + 1, end);
        return res;
    }
}
```

### convert sorted list to binary search tree java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        if(head == null) return null;
        if(head.next == null) return new TreeNode(head.val);
        ListNode midNode = getMid(head);
        ListNode rest = null;
        if(midNode == null){
            midNode = head;
            rest = midNode.next;
            midNode.next = null;
            head = null;
        }else{
            ListNode t = midNode;
            midNode = midNode.next;
            rest = midNode.next;
            t.next = null;
            midNode.next = null;
        }
        TreeNode res = new TreeNode(midNode.val);
        res.left = sortedListToBST(head);
        res.right = sortedListToBST(rest);
        return res;
    }
    private ListNode getMid(ListNode head){
        ListNode fast = head;
        ListNode slow = head;
        ListNode lastSlow = null;
        while(fast.next != null && fast.next.next != null){
            fast = fast.next.next;
            lastSlow = slow;
            slow = slow.next;
        }
        return lastSlow;
    }
}
```

### minimum depth of binary tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        List<TreeNode> list = new ArrayList<>();
        list.add(root);
        return minDepth(list, 1);
    }
    public int minDepth(List<TreeNode> list, int min) {
        if(list.size() == 0) return min;
        List<TreeNode> next = new ArrayList<>();
        for(TreeNode n: list){
            if(n.right == null && n.left == null) return min;
            if(n.right != null) next.add(n.right);
            if(n.left != null) next.add(n.left);
        }
        return minDepth(next, min + 1);
    }

}
```

### path sum java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        return hasPathSum(root, 0 ,sum);
    }
    public boolean hasPathSum(TreeNode root, int lastSum, int target) {
        if(root == null) return false;
        if(root.left == null && root.right == null){
            if(lastSum + root.val == target) return true;
            return false;
        }
        boolean left = false;
        boolean right = false;
        if(root.left != null) left = hasPathSum(root.left, lastSum + root.val, target);
        if(root.right != null) right = hasPathSum(root.right, lastSum + root.val, target);
        return left || right;
    }
}
```

### path sum ii java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {

    public List<List<Integer>> pathSum(TreeNode root, int target) {
		 List<List<Integer>> result = new ArrayList<List<Integer>>();
		 pathSum(result, new ArrayList<Integer>(), root, target);
		 return result;
	 }
	 private void pathSum(List<List<Integer>> list, List<Integer> items, TreeNode root, int target) {
		 if(root == null) return;
		 List<Integer> newItems = new ArrayList(items);
		 newItems.add(root.val);
		 int sum = sumList(newItems);
//		 if(sum > target) return;
		 if(root.left == null && root.right == null){
			 if(sum == target) list.add(newItems);
		 }else{
			 pathSum(list, newItems, root.left, target);
			 pathSum(list, newItems, root.right, target);
		 }
	 }
	private int sumList(List<Integer> items){
		int sum = 0;
		for(Integer i : items){
			sum += i;
		}
		return sum;
	}
}
```

### flatten binary tree to linked list rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    
    pub fn flatten(root: &mut Option<Rc<RefCell<TreeNode>>>) {
        if root.is_none() {
            return;
        }
        let mut q = vec![];
        q.push(root.as_mut().unwrap().borrow_mut().right.take());
        q.push(root.as_mut().unwrap().borrow_mut().left.take());
        let mut cur = root;
        while !q.is_empty() {
            let a = q.pop().unwrap();
            if let Some(x) = a {
                q.push(x.borrow_mut().right.take());
                q.push(x.borrow_mut().left.take());
                let c = cur.as_mut().unwrap();
                let d = Rc::get_mut(c).unwrap();
                let e = d.get_mut();
                e.right = Some(x);
                cur = &mut e.right;
            }
        }
    }
}
```

### flatten binary tree to linked list java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void flatten(TreeNode root) {
    	if(root == null || (root.left == null && root.right == null)) return;
    	Stack<TreeNode> stack = new Stack<TreeNode>();
    	if(root.right != null) stack.push(root.right);
    	if(root.left != null) stack.push(root.left);
    	root.left = null;
    	while(stack.size() != 0){
    		TreeNode node = stack.pop();
    		if(node.right != null) stack.push(node.right);
    		if(node.left != null) stack.push(node.left);
    		root.right = node;
    		root = root.right;
    		root.left = null;
    	}
    }
}
```

### distinct subsequences java

```java
class Solution {
    public int numDistinct(String s, String t) {
        if (s.length() < t.length()){
            return 0;
        }else if (s.equals(t)){
            return 1;
        }else if (s.length() == t.length()){
            return 0;
        }
        Map<Integer, Integer> cnt = new HashMap<>();
        Map<Integer, List<Integer>> pos = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            pos.computeIfAbsent((int)s.charAt(i), k -> new ArrayList<>()).add(i);
        }
        for (int i = 0; i < t.length(); i++) {
            int c = t.charAt(i);
            List<Integer> list = pos.get(c);
            if (list == null){
                return 0;
            }
            if (i == 0){
                for (Integer tp : list) {
                    cnt.put(tp, 1);
                }
            }else{
                Map<Integer, Integer> nnt = new HashMap<>();
                for (Integer tp : list) {
                    int sum = cnt.entrySet().stream().filter(x -> tp > x.getKey()).map(Map.Entry::getValue).mapToInt(Integer::intValue).sum();
                    nnt.put(tp, sum);
                }
                cnt = nnt;
            }
            if (cnt.isEmpty()){
                return 0;
            }
        }
        return cnt.values().stream().mapToInt(Integer::intValue).sum();
    }
}
```

### populating next right pointers in each node java

```java
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void connect(TreeLinkNode root) {
    	if(root == null || root.left == null) return; 
        List<TreeLinkNode> oneList = new ArrayList<TreeLinkNode>();
        List<TreeLinkNode> twoList = new ArrayList<TreeLinkNode>();
        oneList.add(root);
        int height = countHeight(root);
        while(--height > 0){
        	if(oneList.size() != 0){
        		releaseNode(oneList, twoList);
        		connect(twoList);
        		continue;
        	}
        	if(twoList.size() != 0){
        		releaseNode(twoList, oneList);
        		connect(oneList);
        		continue;
        	}
        }
    }
    private int countHeight(TreeLinkNode root){
    	int count = 0;
    	while(root != null){
    		count++;
    		root = root.left;
    	}
    	return count;
    }
    private void connect(List<TreeLinkNode> list){
    	for(int i = 0; i < list.size() - 1; i++){
    		list.get(i).next = list.get(i + 1);
    	}
    }
    private void releaseNode(List<TreeLinkNode> oneList, List<TreeLinkNode> twoList){
    	while(oneList.size() != 0){
    		TreeLinkNode tmp = oneList.remove(0);
    		twoList.add(tmp.left);
    		twoList.add(tmp.right);
    	}
    }
}
```

### populating next right pointers in each node ii java

```java
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void connect(TreeLinkNode root) {
        if(root == null) return;
        List<TreeLinkNode> oneList = new ArrayList<TreeLinkNode>();
        List<TreeLinkNode> twoList = new ArrayList<TreeLinkNode>();
        oneList.add(root);
        while(oneList.size() > 0){
            TreeLinkNode last = null;
            for(TreeLinkNode node: oneList) {
                if(node.left != null) twoList.add(node.left);
                if(node.right != null) twoList.add(node.right);
                if(last == null) last = node;
                else {
                    last.next = node;
                    last = node;
                }
            }
            List<TreeLinkNode> tmp = oneList;
            oneList = twoList;
            twoList = tmp;
            twoList.clear();
        }
    }
}
```

### pascals triangle java

```java
public class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> last = new ArrayList<>();
        while(numRows-- > 0){
            if(last.size() == 0){
                last.add(1);
            }else{
                List<Integer> cur = new ArrayList<>();
                cur.add(1);
                for (int i = 0; i < last.size() - 1; i++) {
                    cur.add(last.get(i) + last.get(i + 1));
                }
                cur.add(1);
                last = cur;
            }
            res.add(last);
        }
        return res;
    }
}
```

### pascals triangle ii java

```java
public class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> last = new ArrayList<>();
        while(rowIndex-- >= 0){
            if(last.size() == 0){
                last.add(1);
            }else{
                List<Integer> cur = new ArrayList<>();
                cur.add(1);
                for (int i = 0; i < last.size() - 1; i++) {
                    cur.add(last.get(i) + last.get(i + 1));
                }
                cur.add(1);
                last = cur;
            }
        }
        return last;
    }
}
```

### best time to buy and sell stock rust

```rust
impl Solution {

    pub fn max_profit(prices: Vec<i32>) -> i32 {
        if prices.len() == 0 {
            return 0;
        }
        let mut ans = 0;
        let mut lastmin = prices[0];
        for i in prices {
            ans = ans.max(i - lastmin);
            lastmin = lastmin.min(i);
        }
        ans
    }

}
```

### best time to buy and sell stock java

```java
public class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 0 || prices.length == 1) return 0;
        int res = 0;
        int curMin = prices[0];
        for (int i : prices) {
            if (i < curMin)
                curMin = i;
            else if (i - curMin > res)
                    res = i - curMin;
        }
        return res;
    }
}
```

### binary tree maximum path sum rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn max_path_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>, ans: &mut i32) -> i32{
            if let Some(n) = root {
                let left  = dfs(&n.borrow().left, ans).max(0);
                let right = dfs(&n.borrow().right, ans).max(0);
                let mut cur = left + n.borrow().val + right;
                *ans = *ans.max(&mut cur);
                n.borrow().val + left.max(right)
            }else{
                0
            }
        }
        let mut ans = i32::MIN;
        dfs(&root, &mut ans);
        ans
    }
}
```

### binary tree maximum path sum java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    private int res = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        if(root == null) return 0;
        maxPath(root);
        return res;
    }

    private int maxPath(TreeNode root){
        if(root == null) return 0;
        int leftMax = maxPath(root.left);
        int rightMax = maxPath(root.right);
        int value = root.val + leftMax + rightMax;
        if(value > res) res = value;
        return Math.max(root.val, 
                Math.max(0, 
                        Math.max(leftMax + root.val, rightMax + root.val)));
    }
}
```

### word ladder ii java

```java
class Solution {
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord)){
            return new ArrayList<>();
        }
        List<String> l = new ArrayList<String>();
        l.add(beginWord);

        List<List<String>> ret1 = new ArrayList<>();
        ret1.add(l);

        Map<String, List<String>> map = new HashMap<>();
        wordList = new ArrayList<>(wordList);
        wordList.add(beginWord);
        for (int i = 0; i < wordList.size(); i++) {
            map.put(wordList.get(i), new ArrayList<>());
            for (int j = 0; j < wordList.size(); j++) {
                if (i == j) {
                    continue;
                }
                int d = 0;
                for (int k = 0; k < wordList.get(i).length(); k++) {
                    if (wordList.get(i).charAt(k) != wordList.get(j).charAt(k)){
                        d++;
                    }
                    if (d > 1){
                        break;
                    }
                }
                if (d == 1){
                    map.get(wordList.get(i)).add(wordList.get(j));
                }
            }
        }
        
        List<List<String>> result = new ArrayList<>();
        List<List<String>> ret2 = new ArrayList<>();
        while (!ret1.isEmpty() && result.isEmpty()){
            for (List<String> list : ret1) {
                String s = list.get(list.size() - 1);
                for (String s1 : map.get(s)) {
                    if (s1.equals(endWord)){
                        List<String> tmp = new ArrayList<>(list);
                        tmp.add(s1);
                        result.add(tmp);
                    }else if (!list.contains(s1)) {
                        List<String> tmp = new ArrayList<>(list);
                        tmp.add(s1);
                        ret2.add(tmp);
                    }
                }
            }
            for (List<String> list : ret1) {
                map.get(list.get(list.size() - 1)).clear();
            }
            ret1 = ret2;
            ret2 = new ArrayList<>();
        }
        return result;
    }
}
```

### word ladder java

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord)){
            return 0;
        }
        wordList = new ArrayList<>(wordList);
        List<String> turn1 = new ArrayList<>();
        List<String> turn2 = new ArrayList<>();

        turn1.add(beginWord);

        int len = 1;
        while (!turn1.isEmpty()){
            for (String s : turn1) {
                Iterator<String> iterator = wordList.iterator();
                nextword: while (iterator.hasNext()){
                    String next = iterator.next();
                    boolean hasone = false;
                    for (int i = 0; i < s.length(); i++) {
                        if (s.charAt(i) != next.charAt(i)){
                            if (hasone){
                                continue nextword;
                            }
                            hasone = true;
                        }
                    }
                    if (next.equals(endWord)){
                        return len + 1;
                    }
                    turn2.add(next);
                    iterator.remove();
                }
            }
            len++;
            turn1 = turn2;
            turn2 = new ArrayList<>();
        }

        return 0;
    }
}
```

### longest consecutive sequence rust

```rust
impl Solution {
    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {
        let mut ans = 0;
        let mut h = std::collections::HashMap::new();
        for i in nums {
            if h.contains_key(&i) {
                continue;
            }
            let llen = *h.get(&(i - 1)).unwrap_or(&0);
            let rlen = *h.get(&(i + 1)).unwrap_or(&0);
            let len = llen + rlen + 1;
            h.insert(i, len);
            ans = ans.max(len);
            h.insert(i - llen, len);
            h.insert(i + rlen, len);
        }

        ans
    }

}
```

### longest consecutive sequence java

```java
public class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        Set<Integer> set = new HashSet<>();
        int res = 1;
        for(int i: nums) set.add(i);
        for (int i: nums){
            if(set.remove(i)){
                int tmp = i;
                int count = 1;
                while(set.remove(--tmp));
                count += i - tmp - 1;
                tmp = i;
                while(set.remove(++tmp));
                count += tmp - i - 1;
                res = Math.max(res, count);
            }
        }
        return res;
    }
}
```

### sum root to leaf numbers java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int sumNumbers(TreeNode root) {
        if(root == null) return 0;
        List<Integer> res = getNumbers(new ArrayList<Integer>(), root);
        int sum = 0;
        for(int i: res){
            sum += i;
        }
        return sum;
    }

    private List<Integer> getNumbers(List<Integer> list, TreeNode root){
        if(root == null) return list;
        List<Integer> res = new ArrayList<>();
        List<Integer> l = null;
        if(list.size() == 0){
            list.add(root.val);
            l = list;
        }else{
            l = new ArrayList<>();
            for(int i: list){
                l.add(i * 10 + root.val);
            }
        }
        if(root.left != null || root.right != null) {
            if(root.left != null) res.addAll(getNumbers(l, root.left));
            if(root.right != null) res.addAll(getNumbers(l, root.right));
        }else return l;
        return res;
    }
}
```

### candy java

```java
class Solution {
    public int candy(int[] ratings) {
        int[] ret = new int[ratings.length];

        Arrays.fill(ret, 1);

        for (int i = 1; i < ret.length; i++) {
            int j = i - 1;
            if (ratings[i] > ratings[j]){
                ret[i] = ret[j] + 1;
                continue;
            }else if (ratings[i] == ratings[j]){
                continue;
            }

            while (j >= 0 && ratings[j + 1] < ratings[j] && ret[j + 1] >= ret[j]){
                ret[j] = ret[j + 1] + 1;
                j--;
            }
        }

        int sum = 0;
        for (int i : ret) {
            sum += i;
        }
        return sum;
    }
}
```

### single number rust

```rust
impl Solution {
    pub fn single_number(nums: Vec<i32>) -> i32 {
        nums.iter().fold(0, |a, b| a^b)
    }
}
```

### single number c

```c
int singleNumber(int* nums, int numsSize) {
    int num = 0;
    for(int i = 0; i < numsSize; i++){
        num ^= nums[i];
    }
    return num;
}
```

### single number ii java

```java
public class Solution {
    public int singleNumber(int[] nums) {
        int zeros = 0;
        int ones = 0;
        for(int i: nums){
            zeros = (zeros ^ i) & ~ones;
            ones = (ones ^ i) & ~zeros;
        }
        return zeros;
    }
}
```

### copy list with random pointer java

```java
/**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
    public RandomListNode copyRandomList(RandomListNode head) {
        RandomListNode go = head;
        while(go != null){
            RandomListNode node = new RandomListNode(go.label);
            node.next = go.next;
            go.next = node;
            go = node.next;
        }
        go = head;
        while(go != null){
            RandomListNode tmp = go.next;
            if(go.random != null) {
                tmp.random = go.random.next;
            }else tmp.random = null;
            go = go.next.next;
        }
        RandomListNode res = null;
        RandomListNode last = null;
        RandomListNode lastGo = null;
        go = head;
        while(go != null){
            RandomListNode tmp = go.next;
            if(res == null){
                res = last = tmp;
                lastGo = go;
                go.next = null;
            }
            else{
                last.next = tmp;
                last = tmp;
                lastGo.next = go;
                lastGo = go;
            }
            go = tmp.next;
            if(go == null) lastGo.next = null;
        }
        return res;
    }
}
```

### word break rust

```rust
impl Solution {

    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {
        let mut dp = vec![false; s.len() + 1];
        dp[0] = true;
        for i in 1..=s.len() {
            for w in &word_dict {
                if i >= w.len(){
                    dp[i] = dp[i - w.len()] && s[i-w.len()..i].eq(w);
                }
                if dp[i] {
                    break;
                }
            }
        }
        *dp.last().unwrap()
    }
}
```

### word break java

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 0; i <= s.length(); i++) {
            for (String w : wordDict) {
                int from = i - w.length();
                if (from >= 0 && dp[from] && s.substring(from).startsWith(w)) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

### linked list cycle java

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
    	ListNode old = head;
    	ListNode tmp;
    	if(head == null) return false;
    	if(head.next != null) head = head.next;
    	else return false;
        while(head != null){
        	if(head.next == old) return true;
        	tmp = head;
        	head = head.next;
        	tmp.next = old;
        }
        return false;
    }
}
```

### linked list cycle ii java

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        Set<ListNode> nodes = new HashSet<>();
        while (head != null){
            if (nodes.contains(head)){
                return head;
            }
            nodes.add(head);
            head = head.next;
        }
        return null;
    }
}
```

### binary tree preorder traversal java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
	private List<Integer> list = new ArrayList<Integer>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root == null) return list;
        list.add(root.val);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        return list;
    }
}
```

### binary tree postorder traversal java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<Integer>();
        
        if(root == null) return list;
        else{
        	list.addAll(postorderTraversal(root.left));
        	list.addAll(postorderTraversal(root.right));
        	list.add(root.val);
        }
        return list;
        
    }
}
```

### lru cache rust

```rust
use std::rc::Rc;
use std::cell::RefCell;
struct LRUCache {
    map: std::collections::HashMap<i32, Rc<RefCell<Node>>>,
    capacity: usize,
    head: Rc<RefCell<Node>>,
    tail: Rc<RefCell<Node>>,
}
struct Node {
    key: i32,
    val: i32,
    pre: Option<Rc<RefCell<Node>>>,
    nxt: Option<Rc<RefCell<Node>>>,
}
impl Node {
    fn new(key: i32, val: i32) -> Node {
        Node {
            key,
            val,
            pre: None,
            nxt: None,
        }
    }
}


/**
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl LRUCache {

    fn new(capacity: i32) -> Self {
        
        let head = Rc::new(RefCell::new(Node::new(-1, -1)));
        let tail = Rc::new(RefCell::new(Node::new(-1, -1)));
        head.borrow_mut().nxt = Some(tail.clone());
        tail.borrow_mut().pre = Some(head.clone());
        LRUCache {
            map: std::collections::HashMap::new(),
            capacity: capacity as usize,
            head: head,
            tail: tail,
        }
    }
    
    fn get(&mut self, key: i32) -> i32 {
        if let Some(n) = self.map.get_mut(&key) {
            let pre = n.borrow_mut().pre.take().unwrap();
            let nxt = n.borrow_mut().nxt.take().unwrap();
            nxt.borrow_mut().pre = Some(pre.clone());
            pre.borrow_mut().nxt = Some(nxt.clone());
            
            let head = &mut self.head;
            
            n.borrow_mut().pre = Some(head.clone());
            n.borrow_mut().nxt = head.borrow_mut().nxt.take();
            head.borrow_mut().nxt = Some(n.clone());
            n.borrow_mut().nxt.as_mut().unwrap().borrow_mut().pre = Some(n.clone());
            n.borrow_mut().val
        }else{
            -1
        }
    }
    
    fn put(&mut self, key: i32, value: i32) {
        if let Some(n) = self.map.get_mut(&key) {
            n.borrow_mut().val = value;
            let pre = n.borrow_mut().pre.take().unwrap();
            let nxt = n.borrow_mut().nxt.take().unwrap();
            nxt.borrow_mut().pre = Some(pre.clone());
            pre.borrow_mut().nxt = Some(nxt.clone());
            
            let head = &mut self.head;
            
            n.borrow_mut().pre = Some(head.clone());
            n.borrow_mut().nxt = head.borrow_mut().nxt.take();
            head.borrow_mut().nxt = Some(n.clone());
            n.borrow_mut().nxt.as_mut().unwrap().borrow_mut().pre = Some(n.clone());
        }else{
            let n = Rc::new(RefCell::new(Node::new(key, value)));
            self.map.insert(key, n.clone());

            let head = &mut self.head;
            
            n.borrow_mut().pre = Some(head.clone());
            n.borrow_mut().nxt = head.borrow_mut().nxt.take();
            head.borrow_mut().nxt = Some(n.clone());
            n.borrow_mut().nxt.as_mut().unwrap().borrow_mut().pre = Some(n.clone());
            
            if self.map.len() > self.capacity {
                let remove = self.tail.borrow_mut().pre.take().unwrap();
                self.map.remove(&remove.borrow().key);
                self.tail.borrow_mut().pre = remove.borrow_mut().pre.take();
                self.tail.borrow_mut().pre.as_mut().unwrap().borrow_mut().nxt = Some(self.tail.clone());
            }

            
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * let obj = LRUCache::new(capacity);
 * let ret_1: i32 = obj.get(key);
 * obj.put(key, value);
 */
```

### lru cache java

```java
class LRUCache extends LinkedHashMap<Integer, Integer>{
    private int capacity;
    
    public LRUCache(int capacity) {
        super(capacity, 0.75F, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity; 
    }
}
```

### insertion sort list java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode last = null;
        ListNode go = head;
        while(go != null){
            if(last == null){
                last = go;
                go = go.next;
            }
            else{
                if(last.val > go.val){
                    ListNode node = go;
                    go = go.next;
                    last.next = go;
                    ListNode tmp = head;
                    ListNode tmpLast = null;
                    while(tmp != null){
                        if(tmp.val >= node.val){
                            if(tmpLast == null){
                                node.next = head;
                                head = node;
                                break;
                            }else{
                                node.next = tmpLast.next;
                                tmpLast.next = node;
                                break;
                            }
                        }
                        tmpLast = tmp;
                        tmp = tmp.next;
                    }
                }else{
                    last = go;
                    go = go.next;
                }
            }
        }
        return head;
    }
}
```

### sort list rust

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut rec = vec![];
        let mut head = head;
        while let Some(mut h) = head {
            head = h.next.take();
            rec.push(h);
        }

        rec.sort_by_key(|b| b.val);

        let mut head = Some(Box::new(ListNode::new(-1)));
        let mut cur = head.as_mut().unwrap();

        for b in rec {
            cur.next = Some(b);
            cur = cur.next.as_mut().unwrap();
        }
        head.unwrap().next
    }
}
```

### sort list java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        List<ListNode> list = new ArrayList<>();
        while (head != null){
            list.add(head);
            head = head.next;
        }
        if (!list.isEmpty()){
            list.sort(Comparator.comparing(x -> x.val));
            list.get(list.size() - 1).next = null;
            for (int i = 0; i < list.size() - 1; i++) {
                list.get(i).next = list.get(i + 1);
            }
            return list.get(0);
        }
        return null;
    }
}
```

### max points on a line java

```java
class Solution {
    public int maxPoints(int[][] points) {
        int n = points.length;
        if (n <= 2){
            return n;
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (n - i <= ans){
                break;
            }
            int[] p1 = points[i];
            Map<Integer, Integer> cnts = new HashMap<>();
            int cur = 1;
            for (int j = i + 1; j < n; j++) {
                if (cur + n - j <= ans){
                    break;
                }
                int[] p2 = points[j];
                int x = p2[0] - p1[0];
                int y = p2[1] - p1[1];

                int gcd = gcd(x, y);
                x /= gcd;
                y /= gcd;
                if (x < 0){
                    x = -x;
                    y = -y;
                }

                int c = 20001 * x + y;
                cur = Math.max(cnts.compute(c, (k, v) -> v == null? 2: ++v), cur);
            }
            ans = Math.max(ans, cur);
        }
        return ans;
    }
    
    int gcd(int x, int y){
        return y == 0? x: gcd(y, x % y);
    }
}
```

### reverse words in a string java

```java
public class Solution {
    public String reverseWords(String s) {
        String[] ss = s.split(" +");
        StringBuilder sb = new StringBuilder();
        for (int i = ss.length - 1; i >= 0; i--) {
            sb.append(ss[i]).append(" ");
        }
        return sb.toString().trim();
    }
}
```

### maximum product subarray rust

```rust
impl Solution {
    pub fn max_product(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut min = nums[0];
        let mut max = nums[0];
        let mut ans = nums[0];
        for i in 1..n {
            let a = nums[i];
            let (t_min, t_max) = (min, max);
            min = a.min(a * t_max).min(a * t_min);
            max = a.max(a * t_max).max(a * t_min);
            ans = ans.max(max);
        }
        ans
    }
}
```

### maximum product subarray java

```java
class Solution {
    public int maxProduct(int[] nums) {
        if (nums.length == 0) return 0;
        int r = nums[0];
        int s = 1;
        int lastNe = 1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0){
                s = lastNe = 1;
                r = Math.max(r, 0);
                continue;
            }
            if (s < 0 && nums[i] < 0 || s > 0 && nums[i] > 0) {
                s *= nums[i];
                r = Math.max(s, r);
            }else{
                if (lastNe > 0 && nums[i] < 0){
                    s *= nums[i];
                    lastNe = s;
                }else{
                    s *= nums[i];
                    if (lastNe < 0) {
                        int ss = s / lastNe;
                        r = Math.max(ss, r);
                    }
                }

            }
        }
        return r;
    }
}
```

### min stack rust

```rust

struct MinStack(Vec<i32>, Vec<i32>);


/**
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl MinStack {

    
    /** initialize your data structure here. */
    fn new() -> Self {
        MinStack(vec![], vec![])
    }
    
    fn push(&mut self, val: i32) {
        self.0.push(val);
        if self.1.is_empty() || *self.1.last().unwrap() >= val {
            self.1.push(val);
        }
    }
    
    fn pop(&mut self) {
        if *self.1.last().unwrap() == self.0.pop().unwrap() {
            self.1.pop();
        }
    }
    
    fn top(&self) -> i32 {
        *self.0.last().unwrap()
    }
    
    fn get_min(&self) -> i32 {
        *self.1.last().unwrap()
    }
}
```

### min stack java

```java
class MinStack {

    Deque<Integer> stack;
    Deque<Integer> minStack;

    public MinStack() {
        stack = new LinkedList<>();
        minStack = new LinkedList<>();
        minStack.push(Integer.MAX_VALUE);
    }

    public void push(int val) {
        stack.push(val);
        minStack.push(Math.min(minStack.peek(), val));
    }

    public void pop() {
        stack.pop();
        minStack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

### intersection of two linked lists java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        List<ListNode> la = new ArrayList<>();
        while (headA != null){
            la.add(headA);
            headA = headA.next;
        }
        List<ListNode> lb = new ArrayList<>();
        while (headB != null){
            lb.add(headB);
            headB = headB.next;
        }
        int i = 1;
        for (; i <= Math.min(la.size(), lb.size()); i++) {
            if (la.get(la.size() - i) != lb.get(lb.size() - i)){
                if (i == 1){
                    return null;
                }
                break;
            }
        }

        return la.get(la.size() - i + 1);

    }
}
```

### maximum gap java

```java
class Solution {
    
    final int mask = (1 << 16) - 1;
    public int maximumGap(int[] nums) {
        if (nums.length < 2){
            return 0;
        }
        int[] space = new int[mask + 1];
        int[] temp = new int[nums.length];

        for (int num : nums) {
            space[num & mask]++;
        }
        for (int i = 1; i < space.length; i++) {
            space[i] += space[i - 1];
        }
        for (int i = nums.length - 1; i >= 0; i--) {
            temp[--space[nums[i] & mask]] = nums[i];
        }
        Arrays.fill(space, 0);
        for (int num : temp) {
            space[num >> 16]++;
        }
        for (int i = 1; i < space.length; i++) {
            space[i] += space[i - 1];
        }
        for (int i = nums.length - 1; i >= 0; i--) {
            nums[--space[temp[i] >> 16]] = temp[i];
        }

        int ans = Integer.MIN_VALUE;
        for (int i = 1; i < nums.length; i++) {
            ans = Math.max(Math.abs(nums[i] - nums[i - 1]), ans);
        }
        return ans;
    }


}
```

### compare version numbers java

```java
public class Solution {
    
    public int compareVersion(String version1, String version2) {
        String[] v1 = version1.split("\\D*\\.+\\D*");
        String[] v2 = version2.split("\\D*\\.+\\D*");
        int minLen = Math.min(v1.length, v2.length);
        for(int i = 0; i < minLen; i++){
        	if(v1[i].compareTo(v2[i]) != 0){
        		int i1 = v1[i].length() != 0 ? Integer.parseInt(v1[i]) : 0;
        		int i2 = v2[i].length() != 0 ? Integer.parseInt(v2[i]) : 0;
        		if(i1 == i2) continue;
        		if(i1 > i2) return 1;
        		if(i1 < i2) return -1;
        	}
        }
        boolean isV1Zero = isZero(v1, minLen);
        boolean isV2Zero = isZero(v2, minLen);
        if(isV2Zero == isV1Zero) return 0;
        if(isV1Zero) return -1;
        if(isV2Zero) return 1;
        return 0;
    }
    private boolean isZero(String[] ss, int from){
    	for(int i = from; i < ss.length; i++){
    		if(Integer.parseInt(ss[i]) != 0) return false;
    	}
    	return true;
    }
    
}
```

### fraction to recurring decimal java

```java
public class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
    	if(numerator == 0) return "0";
    	long first = (long)numerator;
    	long second = (long)denominator;
    	String s = "" + (first / second);
    	if(((first < 0 && second > 0) || (first > 0 && second < 0)) && s.equals("0")){
    		s = "-" + s;
    	}
    	first = Math.abs(first);
    	second = Math.abs(second);
    	long rest = first % second;
    	if(rest == 0) return s;
    	StringBuilder sb = new StringBuilder();
    	HashMap<Long, Integer> map = new HashMap<Long, Integer>();
    	while(rest != 0){
    		if(map.containsKey(rest)){
    			int index = map.get(rest);
    			sb.insert(index, "(");
    			sb.append(")");
    			break;
    		}
    		map.put(rest, sb.length());
    		rest *= 10;
    		sb.append(rest / second);
    		rest %= second;
    	}
        return s + "." + sb.toString();
    }
}
```

### excel sheet column title rust

```rust
impl Solution {


    pub fn convert_to_title(column_number: i32) -> String {
        let mut ans = String::new();
        let mut num = column_number;
        while num > 0 {
            let last = (num - 1) % 26;
            let c = ('A' as u8) + (last as u8);
            ans.push(c as char);
            num = (num - 1) / 26;
        }
        return ans.chars().rev().collect();
    }

}
```

### excel sheet column title java

```java
public class Solution {
    public String convertToTitle(int n) {
        String s = "";
        while(n != 0){
        	s = (char)((n - 1) % 26 + 'A') + s;
        	n = (n - 1) / 26;
        }
        return s;
    }
}
```

### majority element rust

```rust
impl Solution {
    pub fn majority_element(nums: Vec<i32>) -> i32 {
        let mut map = std::collections::HashMap::new();
        let target = nums.len() >> 1;
        for i in nums {
            let v = map.entry(i).or_insert(0);
            *v += 1;
            if *v > target {
                return i;
            }
        }
        0
    }
}
```

### majority element java

```java
public class Solution {
    public int majorityElement(int[] nums) {
    	int len = nums.length;
        if(len == 1 || len == 2) return nums[0];
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        int count;
        int res = 0;
        for(int i: nums){
        	if(map.containsKey(i))
        		count = map.get(i) + 1;
        	else
        		count = 1;
        	if(count > len / 2) return i;
        	if(count == len / 2) res = i;
        	map.put(i, count);
        }
        return res;
    }
}
```

### excel sheet column number java

```java
public class Solution {
    public int titleToNumber(String s) {
        int res = 0;
        for(int i = 0; i < s.length(); i++){
        	res += res * 25 + (s.charAt(i) - 'A' + 1);
        }
        return res;
    }
}
```

### factorial trailing zeroes java

```java
public class Solution {
    public int trailingZeroes(int n) {
        if(n <= 0) return 0;
        int c = 0;
        while(n / 5 != 0){
            n /= 5;
            c += n;
        }
        return c;
    }
}
```

### combine two tables mysql

```mysql
# Write your MySQL query statement below
select FirstName, LastName, City, State from Person left join Address on Person.PersonId = Address.PersonId
```

### second highest salary mysql

```mysql
# Write your MySQL query statement below
(SELECT max(salary) AS SecondHighestSalary
FROM employee
WHERE salary < (SELECT MAX(salary) FROM employee)
LIMIT 1)
union all
(select null AS SecondHighestSalary)
limit 1
```

### rank scores mysql

```mysql
# Write your MySQL query statement below
select b.Score, (select count(1) from (select distinct Score from scores) a where a.Score >= b.Score) as Rank
from scores b
order by Score desc
```

### largest number java

```java
public class Solution {
    public String largestNumber(int[] nums) {
    	List<String> list = new ArrayList<String>();
    	for(int i: nums){
    		list.add(String.valueOf(i));
    	}
    	Collections.sort(list, new Comparator<String>() {
			@Override
			public int compare(String o1, String o2) {
				if(o1.length() == o2.length()){
					return o2.compareTo(o1);
				}
				if(o1.length() > o2.length()){
					int res = o2.compareTo(o1.substring(0, o2.length()));
					if(res == 0){
						return compare(o1.substring(o2.length()), o2);
					}
					return res;
				}
				return -compare(o2, o1);
			}
		});
    	StringBuilder sb = new StringBuilder();
    	for(String s: list){
    		sb.append(s);
    	}
    	if(sb.toString().matches("^0+$")) return "0";
    	return sb.toString();
    }
}
```

### consecutive numbers mysql

```mysql
# Write your MySQL query statement below
select distinct a.Num as ConsecutiveNums from Logs a join Logs b on a.Id = b.Id - 1 join Logs c on b.Id = c.Id - 1
where a.Num = b.Num and b.Num = c.Num;
```

### employees earning more than their managers mysql

```mysql
# Write your MySQL query statement below
select a.Name as Employee from employee a join employee b on a.ManagerId = b.Id
where a.Salary > b.Salary
```

### duplicate emails mysql

```mysql
# Write your MySQL query statement below
select Email from person group by Email having count(1) > 1
```

### customers who never order mysql

```mysql
# Write your MySQL query statement below
select Name as Customers from Customers where Customers.Id not in (select CustomerId from Orders);
```

### reverse bits java

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
    	String s = Integer.toBinaryString(n);
    	int tailZero = 32 - s.length();
    	System.out.println(s);
    	char[] chars = s.toCharArray();
    	List<Character> list = new ArrayList<Character>();
    	for(char c: chars){
    		list.add(c);
    	}
    	Collections.reverse(list);
    	Object[] array = list.toArray();
    	String t = "";
    	boolean begin = false;
    	for(Object c: array){
    		if((char)c != '0'){
    			begin = true;
    		}
    		if(begin){
    			t += (char)c;
    		}
    	}
    	while(tailZero-- > 0){
    		t += '0';
    	}
    	System.out.println(t);
    	return (int)Long.parseLong(t, 2);
    }

}
```

### number of 1 bits cpp

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        uint32_t t1 = ((n >> 1) & 0x55555555) + (n & 0x55555555);
        uint32_t t2 = ((t1 >> 2) & 0x33333333) + (t1 & 0x33333333);
        uint32_t t3 = ((t2 >> 4) & 0x0f0f0f0f) + (t2 & 0x0f0f0f0f);
        uint32_t t4 = (t3 >> 8) + t3;
        uint32_t t5 = (t4 >>16) + t4;
        return t5 & 0xff;
    }
};
```

### number of 1 bits java

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int t1 = ((n >> 1) & 0x55555555) + (n & 0x55555555);
        int t2 = ((t1 >> 2) & 0x33333333) + (t1 & 0x33333333);
        int t3 = ((t2 >> 4) & 0x0f0f0f0f) + (t2 & 0x0f0f0f0f);
        int t4 = (t3 >> 8) + t3;
        int t5 = (t4 >>16) + t4;
        return t5 & 0xff;
    }
}
```

### number of 1 bits c

```c
int hammingWeight(uint32_t n) {
        uint32_t t1 = ((n >> 1) & 0x55555555) + (n & 0x55555555);
        uint32_t t2 = ((t1 >> 2) & 0x33333333) + (t1 & 0x33333333);
        uint32_t t3 = ((t2 >> 4) & 0x0f0f0f0f) + (t2 & 0x0f0f0f0f);
        uint32_t t4 = (t3 >> 8) + t3;
        uint32_t t5 = (t4 >>16) + t4;
        return t5 & 0xff;
}
```

### rising temperature mysql

```mysql
# Write your MySQL query statement below
select b.Id
from Weather a join Weather b on b.RecordDate - interval 1 day = a.RecordDate
where b.Temperature > a.Temperature;
```

### house robber rust

```rust
impl Solution {
    pub fn rob(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut c = vec![vec![0; n + 1]; 2];
        for i in 1..=n {
            c[0][i] = c[0][i - 1].max(c[1][i - 1]);
            c[1][i] = c[0][i - 1] + nums[i - 1];
        }
        c[0][n].max(c[1][n])
    }
}
```

### house robber java

```java
class Solution {
    public int rob(int[] nums) {
        int[][] dp = new int[2][nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            dp[0][i + 1] = Math.max(dp[0][i], dp[1][i]);
            dp[1][i + 1] = dp[0][i] + nums[i];
        }
        return Math.max(dp[0][nums.length], dp[1][nums.length]);
    }
}
```

### number of islands rust

```rust
impl Solution {

    pub fn num_islands(grid: Vec<Vec<char>>) -> i32 {
        let mut g = grid;
        let m = g.len();
        let n = g[0].len();
        let mut q = vec![];
        let mut num = 0;
        for i in 0..m {
            for j in 0..n {

                if g[i][j] == '1' {
                    num += 1;
                    q.push((i, j));
                    while !q.is_empty() {
                        let (x, y) = q.pop().unwrap();
                        if g[x][y] == '1' {
                            g[x][y] = '0';
                            if x > 0 {
                                q.push((x - 1, y));
                            }
                            if y > 0 {
                                q.push((x, y - 1));
                            }
                            if x < m - 1 {
                                q.push((x + 1, y));
                            }
                            if y < n - 1 {
                                q.push((x, y + 1));
                            }
                        }
                    }

                }
            }
        }

        num
    }
}
```

### number of islands java

```java
public class Solution {
    public int numIslands(char[][] grid) {
    	int res = 0;
    	for(int i = 0; i < grid.length; i++){
    		for(int j = 0; j < grid[0].length; j++){
    			if(grid[i][j] == '1'){
    				res++;
    				flag(grid, i, j);
    			}
    		}
    	}
        return res;
    }
    private void flag(char[][] grid, int i, int j){
    	if(i >= grid.length || i < 0 || j >= grid[0].length || j < 0) return;
    	if(grid[i][j] == '1'){
    		grid[i][j] = '9';
        	flag(grid, i - 1, j);
        	flag(grid, i + 1, j);
        	flag(grid, i, j - 1);
        	flag(grid, i, j + 1);
    	}
    }
}
```

### happy number java

```java
public class Solution {
    public boolean isHappy(int n) {
    	if(n < 0) return false;
    	SortedSet<Integer> set = new TreeSet<Integer>();
    	int sum;
    	while(true){
    		if(n == 1) return true;
    		sum = 0;
    		while(n > 0){
    			sum += (n % 10) * (n % 10);
    			n /= 10;
    		}
    		n = sum;
    		if(set.contains(n)) return false;
    		set.add(n);
    	}
    }
}
```

### remove linked list elements rust

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {

    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {

        let mut dummy = Some(Box::new(ListNode{val: -1, next: head}));

        let mut h = &mut dummy;

        while h.as_ref().is_some() {
            if h.as_mut().unwrap().next.is_some() {
                if h.as_ref().unwrap().next.as_ref().unwrap().val == val {
                    h.as_mut().unwrap().next = h.as_mut().unwrap().next.as_mut().unwrap().next.take();
                }else{
                    h = &mut h.as_mut().unwrap().next;
                }
            }else{
                break;
            }
        }
        dummy.unwrap().next
    }
}
```

### remove linked list elements java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode last = null;
        ListNode go = head;
        while(go != null){
            if(go.val != val)
                if(last == null){
                    last = go;
                    head = go;
                }
                else{
                    last.next = go;
                    last = go;
                }
            go = go.next;
        }
        if(last == null) return null;
        last.next = null;
        return head;
    }
}
```

### count primes java

```java
public class Solution {
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        for(int i = 2; i * i < n; i++){
        	if(!isPrime[i]) continue;
        	for(int j = i * i; j < n; j += i){
        		isPrime[j] = false;
        	}
        }
        int count = 0;
        for(int i = 2; i < n; i++){
        	if(isPrime[i]) count++;
        }
        return count;
    }
}
```

### reverse linked list rust

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        if head.is_none() {
            return None;
        }
        let mut last: Option<Box<ListNode>> = None;
        let mut m = head;
        while m.is_some() {
            let mut node = m.take().unwrap();
            m = node.next;
            node.next = last;
            last = Some(node);
        }
        return last;
    }
}
```

### reverse linked list java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null){
            return head;
        }
        ListNode next = head.next;
        head.next = null;
        ListNode end = reverseList(next);
        next.next = head;
        return end;
    }
}
```

### course schedule rust

```rust
impl Solution {

pub fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {
    fn dfs(i: i32, map: &mut std::collections::HashMap<i32, Vec<i32>>, rec: &mut Vec<bool>) -> bool{
        if rec[i as usize] {
           return false;
        }
        rec[i as usize] = true;
        if let Some(v) = map.remove(&i) {
            for j in v {
                if !dfs(j, map, rec) {
                    return false;
                }
            }
        }
        rec[i as usize] = false;
        return true;
    }
    let mut map = std::collections::HashMap::new();
    for p in prerequisites{
        let v = map.entry(p[0]).or_insert(vec![]);
        v.push(p[1]);
    }
    let mut rec = vec![false; num_courses as usize];
    while !map.is_empty() {
        if !dfs(*map.keys().next().unwrap(), &mut map, &mut rec) {
            return false;
        }
    }
    true
}
}
```

### course schedule java

```java
class Solution {


    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if (prerequisites.length == 0){
            return true;
        }
        Map<Integer, Set<Integer>> map = Arrays.stream(prerequisites).collect(Collectors.groupingBy(x -> x[0], Collectors.mapping(x -> x[1], Collectors.toSet())));
        int[] mem = new int[numCourses];

        Iterator<Map.Entry<Integer, Set<Integer>>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            if (circle(mem, map, iterator.next().getKey())) {
                return false;
            }
        }
        return true;
    }

    private boolean circle(int[] mem, Map<Integer, Set<Integer>> map, Integer next) {

        if (mem[next] == 1){
            return true;
        }else if (mem[next] == 2){
            return false;
        }
        mem[next] = 1;
        Set<Integer> integers = map.get(next);
        if (integers != null){
            for (Integer n : integers) {
                if (circle(mem, map, n)){
                    return true;
                }
            }
        }
        mem[next] = 2;
        return false;
    }


}
```

### implement trie prefix tree rust

```rust
struct Trie {
    map: Map,
}

struct Map {
    map: std::collections::HashMap<u8, Map>,
}


/**
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl Trie {

    /** Initialize your data structure here. */
    fn new() -> Self {
        Trie {
            map: Map {map: std::collections::HashMap::new()}
        }
    }
    
    /** Inserts a word into the trie. */
    fn insert(&mut self, word: String) {
        let mut m = &mut self.map;
        for &u in word.as_bytes() {
            m = m.map.entry(u).or_insert(Map { map: std::collections::HashMap::new()});
        }
        m.map.insert(0, Map { map: std::collections::HashMap::new()});
    }
    
    /** Returns if the word is in the trie. */
    fn search(&self, word: String) -> bool {
        let mut m = &self.map;
        for u in word.as_bytes() {
            if let Some(n) = m.map.get(u) {
                m = n;
            }else{
                return false;
            }
        }
        m.map.get(&0).is_some()
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    fn starts_with(&self, prefix: String) -> bool {
        let mut m = &self.map;
        for u in prefix.as_bytes() {
            if let Some(n) = m.map.get(u) {
                m = n;
            }else{
                return false;
            }
        }
        true
    }
}


/**
 * Your Trie object will be instantiated and called as such:
 * let obj = Trie::new();
 * obj.insert(word);
 * let ret_2: bool = obj.search(word);
 * let ret_3: bool = obj.starts_with(prefix);
 */
```

### implement trie prefix tree java

```java
class Trie {

    Map<Integer, Map> tree;

    /** Initialize your data structure here. */
    public Trie() {
        tree = new HashMap<>();
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        Map<Integer, Map> temp = this.tree;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i);
            temp = temp.compute(c, (k, v) -> v  == null? new HashMap<>(): v);
        }
        temp.put(0, Collections.EMPTY_MAP);
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Map<Integer, Map> temp = this.tree;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i);
            temp = temp.get(c);
            if (temp == null){
                return false;
            }
        }
        return temp.containsKey(0);
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Map<Integer, Map> temp = this.tree;
        for (int i = 0; i < prefix.length(); i++) {
            int c = prefix.charAt(i);
            temp = temp.get(c);
            if (temp == null){
                return false;
            }
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

### minimum size subarray sum java

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {

        int left = 0;
        int sum = nums[left];
        int ret = sum >= target? 1: Integer.MAX_VALUE;
        for (int i = left + 1; i < nums.length; i++) {
            sum += nums[i];
            while (sum >= target){
                ret = Math.min(ret, i - left + 1);
                sum -= nums[left];
                left++;
            }
        }
        return ret == Integer.MAX_VALUE? 0: ret;
    }
}
```

### house robber ii java

```java
class Solution {

    public int rob(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }else if (nums.length == 1){
            return nums[0];
        }
        return Math.max(rob1(Arrays.copyOfRange(nums, 0, nums.length - 1)), rob1(Arrays.copyOfRange(nums, 1, nums.length)));
    }
    public int rob1(int[] nums) {
        int[][] dp = new int[2][nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            dp[0][i + 1] = Math.max(dp[0][i], dp[1][i]);
            dp[1][i + 1] = dp[0][i] + nums[i];
        }
        return Math.max(dp[0][nums.length], dp[1][nums.length]);
    }

}
```

### kth largest element in an array rust

```rust
use std::time::{SystemTime, UNIX_EPOCH};
impl Solution {

    pub fn find_kth_largest(nums: Vec<i32>, k: i32) -> i32 {
        fn rand(most: usize) -> usize {
            SystemTime::now().duration_since(UNIX_EPOCH)
            .unwrap()
            .subsec_nanos() as usize
            % most
        }
        let mut nums = nums;
        let mut left = 0;
        let mut right = nums.len() - 1;
        let k = k as usize;

        loop {
            nums.swap(left, left + rand(right + 1 - left));
            let flag = nums[left];
            let mut i = left + 1;
            while i <= right {
                match nums[i].cmp(&flag) {
                    std::cmp::Ordering::Less => {
                        nums.swap(i, right);
                        right -= 1;
                    },
                    _ => i += 1,
                }
            }
            nums.swap(right, left);
            if right == k - 1 {
                return nums[right];
            }else if right < k - 1 {
                left = right + 1;
                right = nums.len() - 1;
            }else{
                right = right - 1;
                left = 0;
            }
        }
    }
}
```

### kth largest element in an array java

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        k--;
        int l = 0, r = nums.length - 1;
        while (true){
            if (r - l < 10){
                Arrays.sort(nums, l, r + 1);
                return nums[l + r - k];
            }

            int rand = new Random().nextInt(r - l + 1) + l;
            swap(nums, l, rand);
            int ll = l, rr = r;
            while (ll <= rr){
                if (nums[l] <= nums[ll]){
                    ll++;
                }else{
                    swap(nums, ll, rr--);
                }
            }
            swap(nums, l, rr);
            if (k < rr){
                r = rr;
            }else if (k > rr){
                l = rr;
            }else{
                return nums[rr];
            }
        }

    }
    private void swap(int[] nums, int aIdx, int bIdx){
        if (aIdx != bIdx) {
            nums[aIdx] ^= nums[bIdx];
            nums[bIdx] ^= nums[aIdx];
            nums[aIdx] ^= nums[bIdx];
        }
    }
}
```

### contains duplicate java

```java
public class Solution {
    public boolean containsDuplicate(int[] nums) {
        
    	if(nums.length == 0) return false;
    	TreeSet<Integer> set = new TreeSet<Integer>();
    	set.add(nums[0]);
      for(int i = 1; i < nums.length; i++){
    	  if(set.contains(nums[i])){
    		  return true;
    	  }else set.add(nums[i]);
      }
    return false;
    }
}
```

### the skyline problem java

```java
class Solution {

    public List<List<Integer>> getSkyline(int[][] buildings) {
        int n = buildings.length;
        List<Integer> scans = Arrays.stream(buildings).flatMap(x -> Stream.of(x[0], x[1])).sorted().collect(Collectors.toList());
        List<List<Integer>> ans = new ArrayList<>();
        Queue<int[]> q = new PriorityQueue<>(Comparator.<int[]>comparingInt(x -> x[1]).reversed());
        int idx = 0;
        for (Integer x : scans) {
            while (idx < n && buildings[idx][0] <= x) {
                q.add(new int[]{buildings[idx][1], buildings[idx][2]});
                idx++;
            }
            while (!q.isEmpty() && q.peek()[0] <= x) {
                q.poll();
            }
            int maxn = q.isEmpty()? 0: q.peek()[1];
            if (ans.isEmpty() || ans.get(ans.size() - 1).get(1) != maxn){
                ans.add(Arrays.asList(x, maxn));
            }
        }
        return ans;
    }

}
```

### contains duplicate ii java

```java
public class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(nums[i])){
                int index = map.get(nums[i]);
                if(i - index <= k) return true;
            }
            map.put(nums[i], i);
        }
        return false;
    }
}
```

### maximal square rust

```rust
impl Solution {
pub fn maximal_square(matrix: Vec<Vec<char>>) -> i32 {
    let m = matrix.len();
    let n = matrix[0].len();
    let mut dp = vec![vec![0; n + 1]; m + 1];
    let mut ans = 0;

    for i in 1..=m {
        for j in 1..=n {
            if matrix[i - 1][j - 1] == '1' {
                dp[i][j] = dp[i][j - 1].min(dp[i - 1][j]).min(dp[i - 1][j - 1]) + 1;
                ans = ans.max(dp[i][j]);
            }
        }
    }

    (ans * ans) as i32
}

}
```

### maximal square java

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int[][] dp = new int[matrix.length + 1][matrix[0].length + 1];
        int ans = 0;
        for (int i = 1; i <= matrix.length; i++) {
            for (int j = 1; j <= matrix[0].length; j++) {
                if (matrix[i - 1][j - 1] == '1'){
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    ans = Math.max(dp[i][j], ans);
                }
            }
        }
        return ans * ans;
    }
}
```

### implement stack using queues java

```java
class MyStack {
    private Queue<Integer> master = new ArrayDeque<>();
    private Queue<Integer> aux = new ArrayDeque<>();
    private int size = 0;
    // Push element x onto stack.
    public void push(int x) {
        master.add(x);
    }

    // Removes the element on top of the stack.
    public void pop() {
        if(master.size() == 1){
            master.remove();
            return;
        }
        while(master.size() != 1){
            aux.add(master.remove());
        }
        master.remove();
        exchange();
    }

    private void exchange() {
        Queue<Integer> tmp = master;
        master = aux;
        aux = tmp;
    }

    // Get the top element.
    public int top() {
        if(master.size() == 1) return master.peek();
        while(master.size() != 1){
            aux.add(master.remove());
        }
        int res = master.peek();
        aux.add(master.remove());
        exchange();
        return res;
    }

    // Return whether the stack is empty.
    public boolean empty() {
        return master.size() == 0;
    }

}

```

### invert binary tree rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn invert_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        if let Some(n) = root {
            let left = Solution::invert_tree(n.borrow_mut().left.take());
            let right = Solution::invert_tree(n.borrow_mut().right.take());
            n.borrow_mut().left = right;
            n.borrow_mut().right = left;
            Some(n)
        }else{
            None
        }
    }

}
```

### invert binary tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        TreeNode tmp = invertTree(root.left);
        root.left = invertTree(root.right);
        root.right = tmp;
        return root;
    }
}
```

### summary ranges java

```java
public class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> res = new ArrayList<>();
        if(nums.length == 0) return res;
        if(nums.length == 1){
            res.add(nums[0] + "");
            return res;
        }
        int last = nums[0];
        for (int i = 1; i <= nums.length; i++) {
            if(i == nums.length || nums[i] != nums[i - 1] + 1){
                if(nums[i - 1] == last){
                    res.add(last + "");
                }else{
                    res.add(last + "->" + nums[i - 1]);
                }
                if(i < nums.length) last = nums[i];
            }
        }
        return res;
    }
}
```

### majority element ii java

```java
public class Solution {
    public List<Integer> majorityElement(int[] nums) {
    	int len = nums.length;
    	List<Integer> res = new ArrayList<Integer>();
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        int count;
        for(int i: nums){
        	if(res.contains(i)) continue;
        	if(map.containsKey(i))
        		count = map.get(i) + 1;
        	else
        		count = 1;
        	if(count > len / 3) res.add(i);
        	map.put(i, count);
        }
        return res;
    }
}
```

### kth smallest element in a bst java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int kthSmallest(TreeNode root, int k) {
        fakeCount(root, k);
        return res;
    }
    private int res = 0;
    private boolean found = false;
    private int fakeCount(TreeNode root, int k){
        if(found || root == null) return 0;
        int left = fakeCount(root.left, k);
        int right = fakeCount(root.right, k - left - 1);
        if(!found && k == left + 1){
            res = root.val;
            found = true;
        }
        return left + right + 1;
    }
}
```

### power of two c

```c
bool isPowerOfTwo(int n) {
    
        if(n <= 0) return false;
        return n == (-n & n);
}
```

### power of two java

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
         return n > 0 && (n & (n - 1)) == 0;
    }
}
```

### implement queue using stacks java

```java
class MyQueue {
    	private Stack<Integer> pushStack = new Stack<Integer>();
    	private Stack<Integer> popStack = new Stack<Integer>();
    	private boolean isPush = true;
        // Push element x to the back of queue.
        public void push(int x) {
            if(!isPush){
            	exchange(popStack, pushStack);
            	isPush = true;
            }
            pushStack.add(x);
        }

        // Removes the element from in front of queue.
        public void pop() {
            if(isPush){
            	exchange(pushStack, popStack);
            	isPush = false;
            }
            popStack.pop();
        }

        // Get the front element.
        public int peek() {
            if(isPush){
            	exchange(pushStack, popStack);
            	isPush = false;
            }
            return popStack.peek();
        }

        // Return whether the queue is empty.
        public boolean empty() {
            return (popStack.size() + pushStack.size()) == 0;
        }
        
        private void exchange(Stack<Integer> one, Stack<Integer> two){
        	while(!one.isEmpty()){
        		two.add(one.pop());
        	}
        }
}
```

### palindrome linked list rust

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {

    pub fn is_palindrome(head: Option<Box<ListNode>>) -> bool {
        let mut v = vec![];
        let mut head = head;
        while let Some(n) = head.take() {
            v.push(n.val);
            head = n.next;
        }
        for i in 0..v.len() >> 1 {
            if v[i] != v[v.len() - 1 - i] {
                return false;
            }
        }
        true
    }
}
```

### palindrome linked list java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
//     public boolean isPalindrome(ListNode head) {
//     	ListNode reverseNode = reverse(head);
// 		while(head != null && reverseNode != null){
// 			if(head.val != reverseNode.val){
// 				return false;
// 			}
// 			head = head.next;
// 			reverseNode = reverseNode.next;
// 		}
// 		return true;
//     }
    
//     private ListNode reverse(ListNode head){
//     	ListNode newHead = null;
//     	ListNode nextNode = null;
//     	while(head != null){
//     		newHead = new ListNode(head.val);
//         	newHead.next = nextNode;
//         	nextNode = newHead;
//         	head = head.next;
//     	}
//     	return newHead;
//     }
    public boolean isPalindrome(ListNode head) {
    	if(head == null) return true;
    	List<ListNode> list = new ArrayList<ListNode>();
    	ListNode tmp = head;
    	while(tmp != null){
    		list.add(tmp);
    		tmp = tmp.next;
    	}
    	int len = list.size();
    	for(int i = 0; i < len / 2; i++)
			if(list.get(i).val != list.get(len - i - 1).val){
			return false;
		}
    	return true;
    }
}
```

### lowest common ancestor of a binary search tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        
		if(root == null) return null;
		if(p.val < root.val && q.val < root.val){
			return lowestCommonAncestor(root.left, p,  q);
		}
		if(p.val > root.val && q.val > root.val){
			return lowestCommonAncestor(root.right, p,  q);
		}
		return root;
    }
}
```

### lowest common ancestor of a binary tree rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>, p: i32, q: i32) -> (bool, bool, Option<Rc<RefCell<TreeNode>>>) {
            let (mut a, mut b) = (false, false);
            if let Some(me) = root {
                let val = me.borrow().val;
                if  val == p{
                    a = true;
                }
                if  val == q{
                    b = true;
                }
                let (la, lb, lo) = dfs(& me.borrow().left, p, q);
                if lo.is_some() {
                    return (true, true, lo);
                }
                let (ra, rb, ro) = dfs(& me.borrow().right, p, q);
                if ro.is_some() {
                    return (true, true, ro);
                }
                let (aa, bb) = (a || la || ra, b || lb || rb);
                if aa && bb {
                    return (aa, bb, Some(Rc::new(RefCell::new(TreeNode::new(val)))));
                }
                return (aa, bb, None);
            }
            (false, false, None)
        }
        dfs(&root, p.unwrap().borrow().val, q.unwrap().borrow().val).2
    }

}
```

### lowest common ancestor of a binary tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || p == root || q == root) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null) return right;
        if(right == null) return left;
        return root;
    }
}
```

### delete node in a linked list java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

### product of array except self rust

```rust
impl Solution {
    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {
        let mut left = vec![1; nums.len() + 2];
        let mut right = vec![1; nums.len() + 2];

        for i in 0..nums.len() {
            left[i + 1] = left[i] * nums[i];
            right[nums.len() - i] = right[nums.len() - i + 1] * nums[nums.len() - 1 - i];
        }

        let mut ans = vec![0; nums.len()];
        for i in 0..nums.len() {
            ans[i] = left[i] * right[i + 2];
        }

        ans
    }
}
```

### product of array except self java

```java
public class Solution {
    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        if(len <= 1) return nums;
        int[] res = new int[len];
        int countZero = 0;
        int indexZero = -1;
        for(int i = 0; i < len; i++){
        	if(nums[i] == 0){
        		indexZero = i;
        		countZero++;
        	}
        }
        if(countZero >= 2){
        	Arrays.fill(res, 0);
        	return res;
        }
        if(countZero == 1){
        	Arrays.fill(res, 0);
        	int t = multiExceptOne(nums, indexZero);
        	res[indexZero] = t;
        	return res;
        }
        int lastRes = multiExceptOne(nums, 0) * nums[0];
        for(int i = 0; i < len; i++){
        	res[i] = lastRes / nums[i];
        }
        return res;
    }
    private int multiExceptOne(int[] nums, int index){
    	int res = 1;
        for(int i = 0; i < nums.length; i++){
        	if(i != index){
        		res *= nums[i];
        	}
        }
        return res;
    }
    
}
```

### sliding window maximum rust

```rust
impl Solution {

pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {
    let mut a: std::collections::BinaryHeap<(i32, usize)> = std::collections::BinaryHeap::new();
    let k = k as usize;
    for i in 0..k-1 {
        a.push((nums[i], i));
    }
    let mut ans = vec![];
    for i in k-1..nums.len() {
        a.push((nums[i], i));
        let start = i + 1 - k;
        loop {
            let b = a.peek().unwrap();
            if b.1 >= start {
                ans.push(b.0);
                break;
            } else {
                a.pop();
            }
        }
    }
    ans
}

}
```

### sliding window maximum java

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        PriorityQueue<int[]> q = new PriorityQueue<>(Comparator.<int[]>comparingInt(x -> x[0]).reversed());
        int kk = k - 1;
        IntStream.range(0, kk).mapToObj(i -> new int[]{nums[i], i}).forEach(q::add);
        for (int i = 0; i < ans.length; i++) {
            int num = nums[kk + i];
            q.add(new int[]{num, kk + i});
            int[] peek = q.peek();
            while (peek[1] < i){
                q.poll();
                peek = q.peek();
            }
            ans[i] = peek[0];
        }
        return ans;
    }
}
```

### search a 2d matrix ii rust

```rust
impl Solution {

pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {
    let mut i = matrix.len() as i32 - 1;
    let mut j = 0i32;

    while i >= 0 && j < matrix[0].len() as i32 {
        match matrix[i as usize][j as usize].cmp(&target) {
            std::cmp::Ordering::Equal => return true,
            std::cmp::Ordering::Less => j += 1,
            _ => i -= 1
        }
    }
    false
}
}
```

### search a 2d matrix ii java

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int i = matrix.length - 1, j = 0;
        
        while (i >= 0 && j < matrix[0].length){
            if (matrix[i][j] < target){
                j++;
            }else if(matrix[i][j] > target){
                i--;
            }else {
                return true;
            }
        }
        return false;
    }
}
```

### different ways to add parentheses java

```java
public class Solution {
    public List<Integer> diffWaysToCompute(String input) {
    	List<Integer> list = new ArrayList<Integer>();
    	String[] nums = input.split("\\*|-|\\+");
        if(nums.length == 1 || (nums.length == 2 && nums[0].equals("") && (input.contains("+") || input.contains("-")))){
        	list.add(Integer.parseInt(input));
        	return list;
        }
        int len = 0;
        for(int i = 0; i < nums.length - 1; i++){
        	len += nums[i].length();
        	List<Integer> left = diffWaysToCompute(input.substring(0, len));
        	List<Integer> right = diffWaysToCompute(input.substring(1 + len));
        	switch(input.charAt(len)){
        	case '+':
        		for(Integer v: left){
        			for(Integer w: right){
        				list.add(v + w);
        			}
        		}
        		break;
        	case '-':
        		for(Integer v: left){
        			for(Integer w: right){
        				list.add(v - w);
        			}
        		}
        		break;
        	case '*':
        		for(Integer v: left){
        			for(Integer w: right){
        				list.add(v * w);
        			}
        		}
        		break;
    		default:
        		break;
        	}
        	len++;
        }
        return list;
    }
}
```

### valid anagram java

```java
import java.util.*;
public class Solution {
    
	public boolean isAnagram(String s, String t) {
		Hashtable<Character, Integer> table = new Hashtable<Character, Integer>();
		List<Integer> counts = new ArrayList<Integer>();
		int charNum = 0;
		for(int i = 0; i < s.length(); i++){
			Character c = s.charAt(i);
			if(table.containsKey(c)){
				int index = table.get(c);
				int val = counts.get(index);
				counts.set(index, val + 1);
			}else{
				table.put(c, charNum++);
				counts.add(1);
			}
		}
		for(int i = 0; i < t.length(); i++){
			Character c = t.charAt(i);
			if(table.containsKey(c)){
				int index = table.get(c);
				int val = counts.get(index) - 1;
				counts.set(index, val);
				if(val <= 0) table.remove(c);
			}else{
				return false;
			}
		}
		return table.isEmpty();
    }
}
```

### binary tree paths java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    
	 public List<String> binaryTreePaths(TreeNode root) {
		 List<String> result = new ArrayList<String>();
		 binaryTreePaths(result, "", root);
		 return result;
	 }
	 private void binaryTreePaths(List<String> list, String pref, TreeNode root) {
		 if(root == null) return;
		 pref += root.val + "->";
		 if(root.left == null && root.right == null){
			 list.add(pref.substring(0, pref.lastIndexOf("->")));
		 }else{
			 binaryTreePaths(list, pref, root.left);
			 binaryTreePaths(list, pref, root.right);
		 }
	 }
}
```

### add digits java

```java
public class Solution {
    public int addDigits(int num) {
        if(num == 0) return 0;
        int res = num % 9;
        
        return res == 0? 9: res;
    }
}
```

### single number iii java

```java
public class Solution {
    public int[] singleNumber(int[] nums) {
        IntStream s = Arrays.stream(nums);
        int n = s.reduce(0, (sum, x) -> (sum ^= x));
        int[] res = new int[2];
        final int bit = n & -n;
        s = Arrays.stream(nums);
        res[0] = s.filter(x -> (x & bit) == 0).reduce(0, (sum, x) -> (sum ^= x));
        s = Arrays.stream(nums);
        res[1] = s.filter(x -> (x & bit) != 0).reduce(0, (sum, x) -> (sum ^= x));
        return res;
    }
}
```

### ugly number java

```java
public class Solution {
    public boolean isUgly(int num) {
        if(num == 1) return true;
        if(num <= 0) return false;
        while(num % 2 == 0) num /= 2;
        while(num % 3 == 0) num /= 3;
        while(num % 5 == 0) num /= 5;
        return num == 1;
    }
}
```

### ugly number ii java

```java
public class Solution {
    public int nthUglyNumber(int n) {
        
    	int c2 = 0;
    	int c3 = 0;
    	int c5 = 0;
    	
    	List<Integer> list = new ArrayList<Integer>();
    	list.add(1);
    	while(list.size() < n){
    		int min = Math.min(list.get(c2) * 2, Math.min(list.get(c3) * 3, list.get(c5) * 5));
    		if(min == list.get(c2) * 2){
    			c2++;
    		}
    		if(min == list.get(c3) * 3){
    			c3++;
    		}
    		if(min == list.get(c5) * 5){
    			c5++;
    		}
    		list.add(min);
    	}
        return list.get(list.size() - 1);
    }
}
```

### missing number java

```java
public class Solution {
    public int missingNumber(int[] nums) {
        int len = nums.length;
        long sum = 0;
        for(int i : nums){
        	sum += i;
        }
        return (int)((len + 1) * len / 2 - sum);
    }
}
```

### integer to english words java

```java
public class Solution {
	private int billion = 1_000_000_000;
	private int million = 1_000_000;
	private int thousand = 1_000;
	private int hundred = 100;
	
    public String numberToWords(int num) {
    	if(num == 0) return "Zero";
    	return getAns(num).trim();
    }
	
    private String getAns(int num){
        if(num >= billion){
        	return getAns(num / billion) + "Billion " + getAns(num % billion);
        }
        if(num >= million){
        	return getAns(num / million) + "Million " + getAns(num % million);
        }
        if(num >= thousand){
        	return getAns(num / thousand) + "Thousand " + getAns(num % thousand);
        }
        if(num >= hundred){
        	return getAns(num / hundred) + "Hundred " + getAns(num % hundred);
        }
        String s = "";
        if(num >= 20){
        	s += getMoreTen(num / 10);
            if(num % 10 > 0){
            	s += getDigit(num % 10);
            }
        }else if(10 <= num && num <= 19){
        	s += getTen(num);
        }else{
        	s += getDigit(num % 10);
        }
        return s;
    }
    
    private String getDigit(int digit) {
        switch (digit) {
            case 1:
                return "One ";
            case 2:
                return "Two ";
            case 3:
                return "Three ";
            case 4:
                return "Four ";
            case 5:
                return "Five ";
            case 6:
                return "Six ";
            case 7:
                return "Seven ";
            case 8:
                return "Eight ";
            case 9:
                return "Nine ";
            default:
                return "";
        }
    }

    private String getMoreTen(int ten) {
        switch (ten) {
            case 1:
                return "Ten ";
            case 2:
                return "Twenty ";
            case 3:
                return "Thirty ";
            case 4:
                return "Forty ";
            case 5:
                return "Fifty ";
            case 6:
                return "Sixty ";
            case 7:
                return "Seventy ";
            case 8:
                return "Eighty ";
            case 9:
                return "Ninety ";
            default:
                return "";
        }
    }

    private String getTen(int ten) {
        switch (ten) {
            case 10:
                return "Ten ";
            case 11:
                return "Eleven ";
            case 12:
                return "Twelve ";
            case 13:
                return "Thirteen ";
            case 14:
                return "Fourteen ";
            case 15:
                return "Fifteen ";
            case 16:
                return "Sixteen ";
            case 17:
                return "Seventeen ";
            case 18:
                return "Eighteen ";
            case 19:
                return "Nineteen ";
            default:
                return "";
        }
    }

}
```

### h index rust

```rust
impl Solution {

    pub fn h_index(citations: Vec<i32>) -> i32 {
        let n = citations.len();
        let mut cnts = vec![0; n + 1];
        for i in citations {
            cnts[i.min(n as i32) as usize] += 1;
        }
        let mut h = n + 1;
        let mut s = 0;
        for &i in cnts.iter().rev() {
            s += i;
            h -= 1;
            if s >= h {
                break;
            }
        }
        h as i32
    }
}
```

### h index java

```java
public class Solution {
    public int hIndex(int[] citations) {
    	int len = citations.length;
        int[] cs = Arrays.copyOf(citations, len);
        Arrays.sort(cs);
        int best = 0;
        int lo = 0;
        int hi = len - 1;
        int mid;
        while(lo <= hi){
        	mid = lo + (hi - lo) / 2;
        	int num = len - mid;
        	if(cs[mid] >= num){
        		best = num;
        		hi = mid - 1;
        	}else{
        		lo = mid + 1;
        	}
        }
        return best;
    }
}
```

### h index ii rust

```rust
impl Solution {

    pub fn h_index(citations: Vec<i32>) -> i32 {
        let n = citations.len() as i32;
        let mut left = 0i32;
        let mut right = n - 1;
        while left <= right {
            let mid = left + (right - left) / 2;
            match citations[mid as usize].cmp(&(n as i32 - mid as i32)) {
                std::cmp::Ordering::Greater => right = mid - 1,
                std::cmp::Ordering::Less => left = mid + 1,
                _ => return (n - mid) as i32
            }
        }
        n - left
    }
}
```

### h index ii java

```java
public class Solution {
    public int hIndex(int[] citations) {
    	int len = citations.length;
        int[] cs = Arrays.copyOf(citations, len);
        Arrays.sort(cs);
        int best = 0;
        int lo = 0;
        int hi = len - 1;
        int mid;
        while(lo <= hi){
        	mid = lo + (hi - lo) / 2;
        	int num = len - mid;
        	if(cs[mid] >= num){
        		best = num;
        		hi = mid - 1;
        	}else{
        		lo = mid + 1;
        	}
        }
        return best;
    }
}
```

### first bad version java

```java
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int l = 1;
        int r = n;
        while (l <= r){
            int mid = l + (r - l) / 2;
            boolean badVersion = isBadVersion(mid);
            System.out.println(mid + " " + badVersion);
            if (badVersion){
                r = mid - 1;
            }else{
                l = mid + 1;
            }
        }
        return l;
    }
}
```

### perfect squares rust

```rust
impl Solution {

    pub fn num_squares(n: i32) -> i32 {
        let mut dp = vec![n; n as usize + 1];
        dp[0] = 0;
        for i in 1..=n as usize {
            for j in 1..=i {
                let x = j * j;
                if x > i {
                    break;
                }
                dp[i] = dp[i].min(dp[i - x] + 1);
            }
        }
        dp[n as usize]
    }
}
```

### perfect squares java

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        int end = (int)Math.sqrt(n);
        for (int i = 1; i <= n; i++) {
            dp[i] = i;
        }
        for (int i = 2; i <= end; i++) {
            int t = i * i;
            for (int j = t; j <= n; j++) {
                dp[j] = Math.min(dp[j], dp[j - t] + 1);
            }
        }
        return dp[n];
    }
}
```

### move zeroes rust

```rust
impl Solution {

    pub fn move_zeroes(nums: &mut Vec<i32>) {
        let mut last = 0usize;
        for i in 0..nums.len() {
            if nums[i] != 0 {
                nums.swap(last, i);
                last += 1;
            }
        }
    }

}
```

### move zeroes java

```java
public class Solution {
    public void moveZeroes(int[] nums) {
    	int len = nums.length;
    	if(len == 0 || len == 1) return;
        int lo = 0;
        int hi = 1;
        while(hi < len || lo < len){
        	while(hi < len && nums[hi] == 0) hi++;
        	while(lo < len && nums[lo] != 0) lo++;
        	if(hi == len || lo == len) break;
        	if(hi > lo){
	        	nums[lo] = nums[hi];
	        	nums[hi] = 0;
        	}else{
        		hi = lo;
        	}
        }
    }
}
```

### find the duplicate number rust

```rust
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        let mut ans = 0;
        let mut p = 0;
        let n = nums.len();
        loop {
            let n_cnt = nums.iter().filter(|&x| x & (1 << p) > 0).count();
            let i_cnt = (1..n).filter(|x| x & (1 << p) > 0).count();
            if n_cnt > i_cnt {
                ans = ans | (1 << p);
            }
            p += 1;
            if i_cnt == 0 {
                break;
            }
        }
        ans
    }
}
```

### find the duplicate number java

```java
public class Solution {
    public int findDuplicate(int[] nums) {
        int res = 0;
        int pad = 1;
        int i = 31;
        int exp = 0;
        int rea = 0;
        do{
            exp = 0;
            rea = 0;
            for (int j = 1; j < nums.length; j++) {
                if ((pad & j) > 0) exp++;
            }
            for(int n: nums){
                if ((pad & n) > 0) rea++;
            }
            if (rea > exp) res |= pad;
            pad <<= 1;
        }while (i-- > 0);
        return res;
    }
}
```

### game of life java

```java
public class Solution {    
    public void gameOfLife(int[][] board) {
        int m = board.length;
        int n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int live = 0;
                for (int k = -1; k <= 1; k++) {
                    if(i + k < 0 || i + k >= m) continue;
                    for (int l = -1; l <= 1; l++) {
                        if(j + l < 0 || j + l >= n || (k == 0 && l == 0)) continue;
                        live += board[i + k][j + l] & 0b1;
                    }
                }
                if(board[i][j] == 0 && live == 3) board[i][j] |= 0b10;
                else if(board[i][j] == 1 && (live == 2 || live == 3)) board[i][j] |= 0b10;
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i][j] >>>= 1;
            }
        }
    }
}
```

### nim game java

```java
public class Solution {
    public boolean canWinNim(int n) {
        if(n % 4 == 0) return false;
        return true;
    }
}
```

### serialize and deserialize binary tree rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
struct Codec {
	
}

/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl Codec{
    fn new() -> Self {
        Codec{}
    }

    fn serialize(&self, root: Option<Rc<RefCell<TreeNode>>>) -> String {
        let mut q = vec![root];
        let mut ans = String::new();
        while let Some(n) = q.pop() {
            if let Some(w) = n {
                q.push(w.borrow_mut().right.take());
                q.push(w.borrow_mut().left.take());
                ans.push_str(format!("{},", w.borrow_mut().val).as_str());
            }else{
                ans.push_str("nil,");
            }
        }
        ans.remove(ans.len() - 1);
        ans
    }
    
    fn deserialize(&self, data: String) -> Option<Rc<RefCell<TreeNode>>> {
        let v: Vec<&str> = data.split(",").collect();
        self.aux(&v, &mut 0)
    }
    fn aux(&self, v: &Vec<&str>, idx: &mut usize) -> Option<Rc<RefCell<TreeNode>>> {
        match v[*idx] {
            "nil" => None,
            _ => {
                let n: i32 = v[*idx].parse().unwrap();
                let mut n = Some(Rc::new(RefCell::new(TreeNode::new(n))));
                *idx += 1;
                n.as_mut().unwrap().borrow_mut().left = self.aux(v, idx);
                *idx += 1;
                n.as_mut().unwrap().borrow_mut().right = self.aux(v, idx);
                n
            }
        }
    }
}
/**
 * Your Codec object will be instantiated and called as such:
 * let obj = Codec::new();
 * let data: String = obj.serialize(strs);
 * let ans: Option<Rc<RefCell<TreeNode>>> = obj.deserialize(data);
 */
```

### serialize and deserialize binary tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

        // Encodes a tree to a single string.
        public String serialize(TreeNode root) {
            if (root == null){
                return "null";
            }
            String left = serialize(root.left);
            String right = serialize(root.right);
            return root.val + "," + left + "," + right;
        }

        // Decodes your encoded data to tree.
        public TreeNode deserialize(String data) {
            String[] split = data.split(",");
            List<String> list = Arrays.stream(split).collect(Collectors.toList());
            return deserialize(list);
        }

        private TreeNode deserialize(List<String> list) {
            String s = list.remove(0);
            if (s.equals("null")){
                return null;
            }
            TreeNode node = new TreeNode(Integer.parseInt(s));
            node.left = deserialize(list);
            node.right = deserialize(list);
            return node;
        }

    }

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```

### longest increasing subsequence rust

```rust
impl Solution {

    pub fn length_of_lis(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut ans = 1;
        let mut dp = vec![0; n];
        dp[0] = 1;
        for i in 1..n {
            let mut cur = 0;
            for j in 0..i {
                if nums[i] > nums[j] && cur < dp[j] {
                    cur = dp[j];
                }
            }
            dp[i] = cur + 1;
            ans = ans.max(dp[i]);
        }
        ans
    }
}
```

### longest increasing subsequence java

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
      int[] dp = new int[nums.length];
      Arrays.fill(dp, 1);
      int ans = 1;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]){
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```

### remove invalid parentheses rust

```rust
impl Solution {


    pub fn remove_invalid_parentheses(s: String) -> Vec<String> {
        fn dfs(bys: &[u8], ans: &mut std::collections::HashSet<String>, idx: usize, cnt: usize, dleft: usize, dright: usize, cur: &mut String){
            if idx == bys.len() && dleft == 0 && dright == 0 {
                ans.insert(cur.clone());
                return;
            }
            if idx == bys.len() {
                return;
            }
            match bys[idx] {
                b'(' => {
                    if dleft > 0 {
                        dfs(bys, ans, idx + 1, cnt, dleft - 1, dright, cur);
                    }
                    cur.push('(');
                    dfs(bys, ans, idx + 1, cnt + 1, dleft, dright, cur);
                    cur.remove(cur.len() - 1);
                },
                b')' => {
                    if cnt > 0 {
                        cur.push(')');
                        dfs(bys, ans, idx + 1, cnt - 1, dleft, dright, cur);
                        cur.remove(cur.len() - 1);
                    }
                    if dright > 0{
                        dfs(bys, ans, idx + 1, cnt, dleft, dright - 1, cur);
                    }
                },
                _ => {
                    cur.push(bys[idx] as char);
                    dfs(bys, ans, idx + 1, cnt, dleft, dright, cur);
                    cur.remove(cur.len() - 1);
                },
            }
        }
        let mut cnt = 0i32;
        let mut dright =  0;
        let mut dleft = 0;
        for &i in s.as_bytes() {
            match i {
                b'(' => cnt += 1,
                b')' => cnt -= 1,
                _ => continue,
            }
            if cnt < 0{
                dright += 1;
                cnt += 1;
            }
        }
        if cnt > 0{
            dleft = cnt as usize;
        }
        let mut ans = std::collections::HashSet::new();
        dfs(s.as_bytes(), &mut ans, 0, 0, dleft, dright, &mut String::new());
        let a = ans.into_iter().collect();
        a
    }
}
```

### remove invalid parentheses java

```java
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        int n = s.length();
        int left = 0, right = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '('){
                left++;
            }else if (s.charAt(i) == ')'){
                if (left > 0){
                    left--;
                }else {
                    right++;
                }
            }
        }
        HashSet<String> ans = new HashSet<>();
        dfs(s.toCharArray(), 0, 0, 0, left, right, new StringBuilder(), ans);
        return new ArrayList<>(ans);
    }

    private void dfs(char[] chars, int idx, int leftCnt, int rightCnt, int left, int right, StringBuilder sb, HashSet<String> ans) {
        if (chars.length == idx){
            if (left == 0 && right == 0){
                ans.add(sb.toString());
            }
            return;
        }
        if (chars[idx] == '(') {
            if (left > 0){
                dfs(chars, 1 + idx, leftCnt, rightCnt, left - 1, right, sb, ans);
            }
            sb.append('(');
            dfs(chars, 1 + idx, leftCnt + 1, rightCnt, left, right, sb, ans);
            sb.deleteCharAt(sb.length() - 1);
        }else if (chars[idx] == ')') {
            if (right > 0){
                dfs(chars, 1 + idx, leftCnt, rightCnt, left, right - 1, sb, ans);
            }
            if (leftCnt >= 1) {
                sb.append(')');
                dfs(chars, 1 + idx, leftCnt - 1, rightCnt, left, right, sb, ans);
                sb.deleteCharAt(sb.length() - 1);
            }
        }else {
            sb.append(chars[idx]);
            dfs(chars, 1 + idx, leftCnt, rightCnt, left, right, sb, ans);
            sb.deleteCharAt(sb.length() - 1);
        }

    }
}
```

### range sum query immutable java

```java
public class NumArray {
    private int[] sum;
    public NumArray(int[] nums) {
        sum = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            sum[i + 1] = sum[i] + nums[i];
        }
    }

    public int sumRange(int i, int j) {
        if(i < 0 || j >= sum.length - 1 || i > j) return 0;
        else return sum[j + 1] - sum[i];
    }
}


// Your NumArray object will be instantiated and called as such:
// NumArray numArray = new NumArray(nums);
// numArray.sumRange(0, 1);
// numArray.sumRange(1, 2);
```

### best time to buy and sell stock with cooldown rust

```rust
impl Solution {

    pub fn max_profit(prices: Vec<i32>) -> i32 {
        if prices.is_empty() {
            return 0;
        }
        let mut dp = vec![0; 3];
        dp[0] = -prices[0];
        for &i in &prices[1..prices.len()] {
            let (a, b, c) = (dp[0], dp[1], dp[2]);
            dp[0] = a.max(c - i);
            dp[1] = a + i;
            dp[2] = b.max(c);
        }
        dp[1].max(dp[2])
    }
}
```

### best time to buy and sell stock with cooldown java

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][3];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][0]);
            dp[i][1] = dp[i - 1][0] + prices[i];
            dp[i][2] = Math.max(dp[i - 1][1], dp[i - 1][2]);
        }
        return Math.max(dp[prices.length - 1][1], dp[prices.length - 1][2]);
    }
}
```

### burst balloons rust

```rust
impl Solution {

    pub fn max_coins(nums: Vec<i32>) -> i32 {
        let mut nums = nums;
        let n = nums.len();
        nums.insert(0, 1);
        nums.push(1);
        let mut dp = vec![vec![0; n + 2]; n + 2];

        for len in 1..=n {
            for start in 1..=n-len+1 {
                let left = nums[start -1];
                let right = nums[start + len];
                let mut max = 0;
                for i in start..start+len {
                    let mut f = 0;
                    if start <= i - 1 {
                        f += dp[start][i-1];
                    }
                    if i + 1 <= start + len - 1 {
                        f += dp[i+1][start + len - 1];
                    }
                    max = max.max(left * right * nums[i] + f);
                }
                dp[start][start + len - 1] = max;
            }
        }
        dp[1][n]
    }
}
```

### burst balloons java

```java
class Solution {
    public int maxCoins(int[] nums) {
        int[] vals = new int[nums.length + 2];
        System.arraycopy(nums, 0, vals, 1, nums.length);
        vals[0] = vals[nums.length + 1] = 1;

        int[][] rec = new int[vals.length][vals.length];
        for (int i = nums.length - 1; i >= 0; i--) {
            for (int j = i + 2; j < rec.length; j++) {
                for (int k = i + 1; k < j; k++) {
                    int v = vals[i] * vals[k] * vals[j];
                    rec[i][j] = Math.max(rec[i][j], v + rec[i][k] + rec[k][j]);
                }
            }
        }
        return rec[0][vals.length - 1];
    }
}
```

### remove duplicate letters rust

```rust
impl Solution {

    pub fn remove_duplicate_letters(s: String) -> String {
        let mut cnts = [0; 26];
        let mut vist = [false; 26];
        for c in s.as_bytes() {
            cnts[(c - b'a') as usize] += 1;
        }

        let mut ans = String::new();
        for &c in s.as_bytes() {
            let i = (c - b'a') as usize;
            if !vist[i] {

                while !ans.is_empty() {
                    let a = ans.as_bytes()[ans.len() - 1];
                    let j = (a - b'a') as usize;
                    if a < c {
                        break;
                    }
                    if cnts[j] > 0 {
                        vist[j] = false;
                        ans.remove(ans.len() - 1);
                    }else{
                        break;
                    }
                }

                vist[i] = true;
                ans.push(c as char);
            }
            cnts[i] -= 1;
        }

        ans
    }
}
```

### coin change rust

```rust
impl Solution {
    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {
        let mut dp = vec![-1; amount as usize + 1];
        dp[0] = 0;
        for i in 1..dp.len() {
            for &c in &coins {
                if i >= c as usize && dp[i - c as usize] >= 0 {
                    if dp[i] < 0 {
                        dp[i] = dp[i - c as usize] + 1;
                    }else{
                        dp[i] = dp[i].min(dp[i - c as usize] + 1);
                    }
                }
            }
        }
        dp[amount as usize]
    }
}
```

### coin change java

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;

        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
        
        return dp[amount] > amount? -1: dp[amount];
    }
}
```

### house robber iii rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    
    pub fn rob(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        fn dfs(root: Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {
            if let Some(n) = root {
                let left = dfs(n.borrow_mut().left.take());
                let right = dfs(n.borrow_mut().right.take());
                let r = left.0 + right.0 + n.borrow_mut().val;
                let l = left.0.max(left.1) + right.0.max(right.1);
                (l, r)
            }else {
                (0, 0)
            }
        }
        let a = dfs(root);
        a.0.max(a.1)
    }

}
```

### house robber iii java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    public int rob(TreeNode root) {
        return Arrays.stream(aux(root)).max().getAsInt();
    }
    private int[] aux(TreeNode root) {
        int[] ints = {0, 0};
      if (root == null){
          return ints;
      }
        int[] left = aux(root.left);
        int[] right = aux(root.right);

        ints[1] = left[0] + right[0] + root.val;
        ints[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        return ints;
    }

}
```

### counting bits rust

```rust
impl Solution {
    pub fn count_bits(n: i32) -> Vec<i32> {
        let mut ans: Vec<i32> = vec![0];
        for i in ans.len()..=n as usize {
            ans.push(ans[i >> 1] + (i as i32 & 1));
        }
        ans
    }
}
```

### counting bits java

```java
class Solution {
    public int[] countBits(int n) {
      int[] ans = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            ans[i] = ans[i >> 1] + (i & 1);
        }
        return ans;
    }
}
```

### power of four java

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & 0xAAAAAAAA) == 0 && (n & (n - 1)) == 0;
    }
}
```

### reverse string java

```java
public class Solution {
    public String reverseString(String s) {
        if(s == null || s.length() <= 1) return s;
        char[] chars = s.toCharArray();
        StringBuilder sb = new StringBuilder();
        sb.append(chars).reverse();
        return sb.toString();
    }
}
```

### top k frequent elements rust

```rust
impl Solution {
    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let mut map = std::collections::HashMap::new();
        nums.iter().for_each(|&i| *map.entry(i).or_insert(0) += 1);
        let mut v: Vec<(&i32, &i32)> = map.iter().map(|a| a).collect();
        v.sort_unstable_by_key(|&(_, cnt)| cnt);
        v.iter().rev().map(|&(&n, _)| n).take(k as usize).collect()
    }
}
```

### top k frequent elements java

```java
public class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        return IntStream.of(nums)
                .boxed()
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet()
                .stream()
                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
                .limit(k)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
    }
}
```

### intersection of two arrays java

```java
public class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = Arrays.stream(nums1).boxed().collect(Collectors.toSet());
        Set<Integer> set2 = Arrays.stream(nums2).boxed().collect(Collectors.toSet());
        set1.retainAll(set2);
        return set1.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

### max sum of rectangle no larger than k java

```java
class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int m = matrix.length;
        int n = matrix[0].length;

        Integer best = null;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > 0){
                    matrix[i][j] += matrix[i - 1][j];
                }
                if (j > 0) {
                    matrix[i][j] += matrix[i][j - 1];
                }
                if (i > 0 && j > 0){
                    matrix[i][j] -= matrix[i - 1][j - 1];
                }
                for (int ii = -1; ii < i; ii++) {
                    for (int jj = -1; jj < j; jj++) {
                        int s = matrix[i][j];
                        if(ii >= 0) s -= matrix[ii][j];
                        if(jj >= 0) s -= matrix[i][jj];
                        if (ii >= 0 && jj >= 0) s += matrix[ii][jj];
                        if (s <= k && (best == null || s >= best)){
                            best = s;
                        }
                        if (s == k){
                            return k;
                        }
                    }
                }
            }
        }
        return best;
    }
}
```

### water and jug problem java

```java
public class Solution {
    
    public boolean canMeasureWater(int x, int y, int z) {
        if(x + y < z) return false;
    	if(z == x || z == y || z == 0 || z == x + y) return true;
    	if(x == y || x == 0 || y == 0) return false;
    	return z % gcd(x, y) == 0;
    }
    private 
    int gcd(int x, int y){
        int t = 1;
        while(y != 0){
            t = y;
            y = x % y;
            x = t;
        }
        return t;
    }
}
```

### valid perfect square java

```java
public class Solution {
    public boolean isPerfectSquare(int num) {
        if (num <= 0) return false;
        if (num == 1) return true;
        int n = num / 3;
        int m = num / n;
        Set<Integer> set = new HashSet<>();
        while (!set.contains(m)){
            if (m * m == num) return true;
            set.add(m);
            m = (num / m + m) >> 1;
        }
        return false;
    }
}
```

### largest divisible subset java

```java
public class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        Arrays.sort(nums);
        solve(nums, new ArrayList<>(), 0);
        return best;
    }
    Set<Integer> ever = new HashSet<>();
    List best = new ArrayList<>();
    private void solve(int[] nums, List<Integer> cur, int n){
        if (n >= nums.length){
            if (best == null || best.size() < cur.size())
                best = new ArrayList<>(cur);
            return;
        }
        if (cur.size() == 0 || nums[n] % cur.get(cur.size() - 1) == 0){
            if (cur.size() == 0 && ever.contains(n)) return;
            ever.add(n);
            cur.add(nums[n]);
            solve(nums, cur, n + 1);
            cur.remove(cur.size() - 1);
        }
        if (cur.size() + (nums.length - n - 1) > best.size())
            solve(nums, cur, n + 1);
    }
}
```

### sum of two integers java

```java
public class Solution {
    public int getSum(int a, int b) {
        if(b == 0)
            return a;
        else{
            int c = a ^ b;
            int d = a & b;
            return getSum(c, d << 1);
        }
    }
}
```

### guess number higher or lower java

```java
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int l = 1, r = n;
        while (true){
            int mid = l + (r - l) / 2;
            int guess = guess(mid);
            if (guess == 0){
                return mid;
            }else if (guess < 0){
                r = mid - 1;
            }else {
                l = mid + 1;
            }
        }
    }
}
```

### decode string rust

```rust
impl Solution {

    pub fn decode_string(s: String) -> String {
        let mut i = 0;
        let mut ns = vec![];
        let mut ss = vec![];
        let mut n = 0;
        let mut curs: String = String::new();
        while i < s.len() {
            let c = s.as_bytes()[i];
            match c {
                b'0'..=b'9' => {
                    n = 0;
                    while i < s.len() {
                        let c = s.as_bytes()[i];
                        match c {
                            b'0'..=b'9' => {
                                n = n * 10 + (c - b'0');
                                i += 1;
                            },
                            _ => break,
                        }
                    }
                },
                b'[' => {
                    ns.push(n);
                    ss.push(curs);
                    curs = String::new();
                    i += 1;
                },
                b']' => {
                    let a = ns.pop().unwrap();
                    let copy = curs.clone();
                    for _ in 0..a-1 {
                        curs += &copy;
                    }
                    let a = ss.pop().unwrap();
                    curs = a + &curs;
                    i += 1;
                },
                _ => {
                    while i < s.len() {
                        let c = s.as_bytes()[i];
                        match c {
                            b'a'..=b'z' => {
                                curs.push(c as char);
                                i += 1;
                            },
                            _ => break,
                        }
                    }
                }
            }
            
        }
        curs
    }
}
```

### decode string java

```java
class Solution {
    public String decodeString(String s) {
        StringBuilder sb = new StringBuilder();
        int i = 0;
        Deque<Object> q = new LinkedList<>();

        while (i < s.length()){
            char c = s.charAt(i);
            if ('0' <= c && c <= '9'){
                int num = 0;
                while (i < s.length() && '0' <= s.charAt(i) && s.charAt(i) <= '9'){
                    num = num * 10 + (s.charAt(i) - '0');
                    i++;
                }
                q.add(num);
            }else if (c == '['){
                i++;
            }else if (c == ']') {
                StringBuilder tmp = new StringBuilder();
                while (q.peekLast() instanceof String) {
                    tmp.insert(0, q.pollLast());
                }
                Integer num = (Integer) q.pollLast();
                String s1 = tmp.toString();
                for (int j = 1; j < num; j++) {
                    tmp.append(s1);
                }
                q.add(tmp.toString());
                i++;
            }else {
                StringBuilder tmp = new StringBuilder();
                while (i < s.length() && ('a' <= s.charAt(i) && s.charAt(i) <= 'z')){
                    tmp.append(s.charAt(i));
                    i++;
                }
                q.add(tmp.toString());
            }
        }

        return q.stream().map(Object::toString).collect(Collectors.joining());

    }
}
```

### evaluate division rust

```rust


struct UnionFind {
    parents: Vec<usize>,
    vals: Vec<f64>,
}

impl UnionFind {
    fn new(size: usize) -> UnionFind {
        UnionFind{
            parents: (0..size + 2).collect(),
            vals: vec![1.0; size + 2],
        }
    }
    fn put(&mut self, a: usize, b: usize, val: f64) {
        let ap = self.find(a);
        let bp = self.find(b);
        self.parents[ap] = bp;
        self.vals[ap] = self.vals[b] * val / self.vals[a];
    }

    fn find(&mut self, a: usize) -> usize {
        let ap = self.parents[a];
        if ap != a {
            let rp = self.find(ap);
            self.parents[a] = rp;
            self.vals[a] *= self.vals[ap];
            rp
        }else{
            a
        }
    }

    fn cal(&mut self, a: usize, b: usize) -> f64 {
        let ap = self.find(a);
        let bp = self.find(b);
        if ap == bp {
            self.vals[a] / self.vals[b]
        }else {
            -1f64
        }
    }

}
impl Solution {
    pub fn calc_equation(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> {
        let mut uf = UnionFind::new(equations.len() * 2);
        let mut map: std::collections::HashMap<String, usize> = std::collections::HashMap::new();
        let mut cnt = 0;
        for i in 0..equations.len() {
            let eq = &equations[i];
            let a = match map.get(&eq[0]) {
                Some(a) => *a,
                _ => {cnt += 1; map.insert(eq[0].clone(), cnt); cnt},
            };
            let b = match map.get(&eq[1]) {
                Some(a) => *a,
                _ => {cnt += 1; map.insert(eq[1].clone(), cnt); cnt},
            };
            uf.put(a, b, values[i]);
        }

        let mut ans = vec![];
        for q in queries {
            if let (Some(&a), Some(&b)) = (map.get(&q[0]), map.get(&q[1])) {
                ans.push(uf.cal(a, b));
            }else{
                ans.push(-1f64);
            }
        }

        ans
    }
}
```

### evaluate division java

```java
class Solution {


    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        Map<String, Integer> ids = new HashMap<>();
        int id = 0;

        UnionFind unionFind = new UnionFind(equations.size() << 1);
        for (int i = 0, equationsSize = equations.size(); i < equationsSize; i++) {
            List<String> eq = equations.get(i);
            Integer x = ids.get(eq.get(0));
            Integer y = ids.get(eq.get(1));
            if (x == null) {
                ids.put(eq.get(0), x = id++);
            }
            if (y == null) {
                ids.put(eq.get(1), y = id++);
            }
            unionFind.rec(x, y, values[i]);
        }

        double[] ans = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            Integer x = ids.get(query.get(0));
            Integer y = ids.get(query.get(1));
            if (x == null || y == null){
                ans[i] = -1;
            }else{
                ans[i] = unionFind.calc(x, y);
            }
        }
        return ans;
    }

    static class UnionFind{

        double[] w;
        int[] p;
        public UnionFind(int n){
            w = new double[n];
            p = IntStream.range(0, n).toArray();
            Arrays.fill(w, 1);
        }
        private int find(int x){
            if (p[x] != x){
                int orignal = p[x];
                p[x] = find(p[x]);
                w[x] *= w[orignal];
            }
            return p[x];
        }
        public void rec(int x, int y, double v) {
            int rootx = find(x);
            int rooty = find(y);
            if (rootx == rooty){
                return;
            }
            p[rootx] = rooty;
            w[rootx] = v * w[y] / w[x];
        }
        public double calc(int x, int y){
            int rootx = find(x);
            int rooty = find(y);
            if (rootx != rooty){
                return -1;
            }

            return w[x] / w[y];
        }
    }
}
```

### binary watch java

```java
class Solution {

    public List<String> readBinaryWatch(int turnedOn) {
        int[] t = {1, 2, 4, 8, 16, 32, 60, 60 << 1, 60 << 2, 60 << 3};
        ArrayList<String> ans = new ArrayList<>();
        aux(t, turnedOn, 0, 0, 0, ans);
        return ans;
    }

    private void aux(int[] t, int turnedOn, int from, int h, int m, ArrayList<String> objects) {
        if (turnedOn <= 0){
            objects.add(String.format("%d:%02d", h, m));
            return;
        }
        if (from >= t.length){
            return;
        }
        for (int i = from; i < t.length; i++) {
            int hh = h;
            int mm = m;
            if (t[i] >= 60){
                hh += t[i] / 60;
            }else{
                mm += t[i];
            }
            if (hh >= 12 || mm >= 60){
                continue;
            }
            aux(t, turnedOn - 1, i + 1, hh, mm, objects);
        }
    }

}
```

### frog jump java

```java
class Solution {
    public boolean canCross(int[] stones) {
        Map<Integer, Set<Integer>> map = new HashMap<>();
        map.computeIfAbsent(0, HashSet::new).add(0);
        Set<Integer> c = Arrays.stream(stones).boxed().collect(Collectors.toSet());
        int[] step = {-1, 0, 1};
        int target = stones[stones.length - 1];
        for (int i = 0; i < stones.length - 1; i++) {
            Set<Integer> integers = map.get(stones[i]);
            c.remove(stones[i]);
            if (integers == null){
                continue;
            }
            for (int cur : integers) {
                for (int s : step) {
                    int t = cur + s;
                    int ta = stones[i] + t;
                    if (ta == target){
                        return true;
                    }
                    if (c.contains(ta)){
                        map.computeIfAbsent(ta, HashSet::new).add(t);
                    }
                }
            }
            map.remove(stones[i]);
        }
        return map.containsKey(target);
    }
}
```

### queue reconstruction by height rust

```rust
impl Solution {

    pub fn reconstruct_queue(people: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut people = people;
        people.sort_by(|x, y| y[0].cmp(&x[0]).then(x[1].cmp(&y[1])));
        let mut ans = vec![];
        for p in people {
            ans.insert(p[1] as usize, p);
        }
        ans
    }

}
```

### queue reconstruction by height java

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Comparator<int[]> comparator = Comparator.comparingInt(x -> x[0]);
        Arrays.sort(people, comparator.reversed().thenComparingInt(x -> x[1]));
        int n = people.length;
        List<int[]> ans = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int[] person = people[i];
            ans.add(person[1], person);
        }
        return ans.toArray(new int[0][]);
    }
}
```

### partition equal subset sum rust

```rust
impl Solution {

    pub fn can_partition(nums: Vec<i32>) -> bool {
        let mut s = nums.iter().fold(0, |a, b| a + b);
        if s & 1 > 0 {
            return false;
        }
        s = s >> 1;
        let mut dp = vec![false; s as usize + 1];
        dp[0] = true;

        for num in nums {
            for i in (1..=s as i32).rev() {
                if dp[i as usize] {
                    continue;
                }
                let a = i - num;
                if a >= 0 {
                    dp[i as usize] = dp[a as usize];
                }
            }
        }
        dp[s as usize]
    }
}
```

### partition equal subset sum java

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = Arrays.stream(nums).sum();
        if ((sum & 1) > 0){
            return false;
        }
        sum >>>= 1;
        boolean[] dp = new boolean[sum + 1];
        dp[0] = true;
        for (int num : nums) {
            for (int i = sum; i >= num; i--) {
                dp[i] |= dp[i - num];
            }
        }
        return dp[sum];
    }
}
```

### path sum iii rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> i32 {
        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>, ans: &mut i32, last: bool, cur: i32, target: i32) {
            if let Some(r) = root {
                if !last {
                    dfs(&r.borrow_mut().left, ans, false, 0, target);
                    dfs(&r.borrow_mut().right, ans, false, 0, target);
                }
                let now = cur + r.borrow().val;
                if now == target {
                    *ans += 1;
                }
                dfs(&r.borrow_mut().left, ans, true, now, target);
                dfs(&r.borrow_mut().right, ans, true, now, target);
            }
        }
        let mut ans = 0;
        dfs(&root, &mut ans, false, 0, target_sum);
        ans
    }
}
```

### path sum iii java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    
    public int pathSum(TreeNode root, int targetSum) {
        return pathSum(root, targetSum, false);
    }

    public int pathSum(TreeNode root, int targetSum, boolean include) {
        if (root == null){
            return 0;
        }
        int ans = 0;
        if (targetSum == root.val){
            ans++;
        }
        ans += pathSum(root.left, targetSum - root.val, true);
        ans += pathSum(root.right, targetSum - root.val, true);
        if (!include){
            ans += pathSum(root.left, targetSum, false);
            ans += pathSum(root.right, targetSum, false);
        }
        return ans;
    }

}
```

### find all anagrams in a string rust

```rust
impl Solution {

    pub fn find_anagrams(s: String, p: String) -> Vec<i32> {
        let bys = s.as_bytes();
        let mut cnts = [0; 26];
        let mut clen = 0;
        for &b in p.as_bytes() {
            let a = &mut cnts[(b - b'a') as usize];
            *a += 1;
            if *a == 1{
                clen += 1;
            }
        }
        let mut ans = vec![];
        let mut left = 0;
        let mut right = 0;

        while right < s.len() {
            let b = bys[right];
            let a = &mut cnts[(b - b'a') as usize];
            *a -= 1;
            if *a == 0 {
                clen -= 1;
            }
            if clen == 0 {
                ans.push(left as i32);
            }
            while right - left + 1 == p.len() {
                let b = bys[left];
                let a = &mut cnts[(b - b'a') as usize];
                *a += 1;
                if *a == 1 {
                    clen += 1;
                }
                left += 1;
            }
            right += 1;
        }
        ans
    }
}
```

### find all anagrams in a string java

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>();

        Map<Integer, Long> cnts = p.chars().boxed().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        int[] pcnts = new int[26];
        int ok = cnts.size();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (++pcnts[c - 'a'] == cnts.getOrDefault((int)c, 0L)) {
                ok--;
            }
            if (i >= p.length()){
                char cc = s.charAt(i - p.length());
                if (cnts.containsKey((int)cc) && pcnts[cc - 'a']-- == cnts.getOrDefault((int)cc, 0L)) {
                    ok++;
                }
            }
            System.out.println(i + " " + ok);
            if (ok == 0){
                ans.add(i - p.length() + 1);
            }
        }

        return ans;
    }
}
```

### find all numbers disappeared in an array rust

```rust
impl Solution {
    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {
        let mut nums = nums;
        for i in 0..nums.len() {
            let a = (nums[i].abs() - 1) as usize;
            nums[a] = -nums[a].abs()
        }
        nums.iter().enumerate().filter(|&(i, &v)| v > 0).map(|(i, _)| i as i32 + 1).collect()
    }
}
```

### find all numbers disappeared in an array java

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        Set<Integer> set = IntStream.rangeClosed(1, nums.length).boxed().collect(Collectors.toSet());
        Arrays.stream(nums).boxed().forEach(set::remove);
        return new ArrayList<>(set);
    }
}
```

### sort characters by frequency rust

```rust
use std::iter::FromIterator;
impl Solution {
    pub fn frequency_sort(s: String) -> String {
        let mut cnts = [0; 128];
        s.as_bytes().iter().for_each(|&a| cnts[a as usize] += 1);
        let mut cnts: Vec<(usize, &i32)> = cnts.iter().enumerate().collect();
        cnts.sort_by_key(|&(_, v)| -v);
        cnts.iter().fold(String::new(), |res, &(c, &v)| {res + &String::from_iter(core::iter::repeat(c as u8 as char).take(v as usize))})
    }
}
```

### hamming distance rust

```rust
impl Solution {
    pub fn hamming_distance(x: i32, y: i32) -> i32 {
        (x ^ y).count_ones() as i32
    }
}
```

### hamming distance java

```java
class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y);
    }
}
```

### ones and zeroes java

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i < strs.length; i++) {
            int zero = (int)strs[i].chars().filter(x -> x == '0').count();
            int one = strs[i].length() - zero;
            for (int j = m; j >= zero; j--) {
                for (int k = n; k >= one; k--) {
                    dp[j][k] = Math.max(dp[j][k], dp[j - zero][k - one] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```

### total hamming distance java

```java
class Solution {
    public int totalHammingDistance(int[] nums) {
        int s = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                s += Integer.bitCount(nums[i] ^ nums[j]);
            }
        }
        return s;
    }
}
```

### smallest good base java

```java
class Solution {
    public String smallestGoodBase(String n) {
        long target = Long.parseLong(n);
        for (int i = 60; i > 0; i--) {
            long l = 2, r = target - 1;
            outer:while (l <= r){
                long mid = l + (r - l) / 2;
                long cur = 1;
                long base = 1;
                for (int k = 0; k < i; k++) {
                    if (Long.MAX_VALUE / base > mid) {
                        base *= mid;
                    }else {
                        r = mid - 1;
                        continue outer;
                    }
                    if (base < 0 || cur > target - base){
                        r = mid - 1;
                        continue outer;
                    }else {
                        cur += base;
                    }
                }
                if (cur > target){
                    r = mid - 1;
                }else if (cur < target){
                    l = mid + 1;
                }else {
                    return Long.toString(mid);
                }
            }
        }
        return Long.toString(target - 1);
    }
}
```

### target sum rust

```rust
impl Solution {

    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {
        let sum = nums.iter().fold(0, |a, b| a + b);
        let r2 = sum - target;
        if r2 & 1 > 0  || r2 < 0{
            return 0;
        }
        let target = r2 >> 1;

        let mut dp = vec![0; (1 + target) as usize];
        dp[0] = 1;
        for i in nums {
            for j in (i as usize..=target as usize).rev() {
                dp[j] += dp[j -  i as usize];
            }
        }

        dp[target as usize]
    }


}
```

### target sum java

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        return findTargetSumWays(nums, target, 0, new HashMap<>());
    }

    public int findTargetSumWays(int[] nums, int target, int from, HashMap<String, Integer> h) {
        if (from >= nums.length) {
            return target == 0 ? 1 : 0;
        }
        String key = from + "-" + target;
        Integer cache = h.get(key);
        if (cache != null){
            return cache;
        }
        int ans = findTargetSumWays(nums, target - nums[from], from + 1, h)
                + findTargetSumWays(nums, target + nums[from], from + 1, h);
        h.put(key, ans);
        return ans;
    }
}
```

### coin change 2 java

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;

        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] += dp[i - coin];
            }
        }

        return dp[amount];
    }
}
```

### continuous subarray sum java

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        if (nums.length < 2){
            return false;
        }
        Map<Integer, Integer> map = new HashMap<>();
        int remain = 0;
        for (int i = 0; i < nums.length; i++) {
            remain = (remain + nums[i]) % k;
            if (i > 0 && remain == 0){
                return true;
            }
            if (map.containsKey(remain)){
                if (i - map.get(remain) >= 2) {
                    return true;
                }
            }else {
                map.put(remain, i);
            }
        }
        return false;
    }
}
```

### contiguous array java

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int sum = 0;
        int ret = 0;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i] > 0? 1: -1;
            if (map.containsKey(sum)){
                ret = Math.max(ret, i - map.get(sum));
            }else{
                map.put(sum, i);
            }
        }
        return ret;

    }
}
```

### convert bst to greater tree rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn convert_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        fn dfs(root: &mut Option<Rc<RefCell<TreeNode>>>, s: &mut i32) {
            if let Some(r) = root {
                dfs(&mut r.borrow_mut().right, s);
                r.borrow_mut().val += *s;
                *s = r.borrow().val;
                dfs(&mut r.borrow_mut().left, s);
            }
        }
        let mut root = root;
        dfs(&mut root, &mut 0);
        root
    }
}
```

### convert bst to greater tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        if (root != null){
            convertBST(root.right);
            sum += root.val;
            root.val = sum;
            convertBST(root.left);
        }
        return root;
    }
}
```

### diameter of binary tree rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn diameter_of_binary_tree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        let mut ans = 0;
        fn max_depth(r: Option<Rc<RefCell<TreeNode>>>, ans: &mut i32) -> i32 {
            if let Some(node) = r {
                let mut len_left = max_depth(node.borrow_mut().left.take(), ans);
                let mut len_right = max_depth(node.borrow_mut().right.take(), ans);
                *ans = (*ans).max(len_left + len_right + 1);
                1 + len_right.max(len_left)
            } else {
                0
            }
        }
        max_depth(root, &mut ans);
        ans - 1
    }
}
```

### diameter of binary tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    

  int ans = 1;
    public int diameterOfBinaryTree(TreeNode root) { 
        height(root);
        return ans - 1;
    }

    private int height(TreeNode root){
      if (root == null){
          return 0;
      }
        int left = height(root.left);
        int right = height(root.right);
        ans = Math.max(ans, left + right + 1);
        return Math.max(left, right) + 1;
    }


}
```

### subarray sum equals k rust

```rust
impl Solution {
    pub fn subarray_sum(nums: Vec<i32>, k: i32) -> i32 {
        let mut map = std::collections::HashMap::new();
        map.insert(0, 1);
        let mut s = 0;
        let mut ans = 0;
        for i in nums {
            s += i;
            if let Some(&r) = map.get(&(s - k)) {
                ans += r;
            }
            let r = map.entry(s).or_insert(0);
            *r += 1;
        }
        ans
    }
}
```

### subarray sum equals k java

```java
class Solution {
    public int subarraySum(int[] nums, int k) {

      int ans = 0;
      Map<Integer, Integer> cnts = new HashMap<>();
      cnts.put(0, 1);
      
        for (int i = 0; i < nums.length; i++) {
            if (i > 0){
                nums[i] += nums[i - 1];
            }
            int cnt = cnts.getOrDefault(nums[i] - k, 0);
            ans += cnt;
            cnts.compute(nums[i], (key, v) -> v == null? 1: ++v);
        }
        return ans;
    }
}
```

### permutation in string java

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        Map<Integer, Long> map = s1.chars().boxed().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        int ok = map.size();

        for (int i = 0; i < s2.length(); i++) {
            int c = s2.charAt(i);
            Long a = map.computeIfPresent(c, (k, v) -> --v);
            if (a != null && a == 0){
                ok--;
            }
            if (i >= s1.length()){
                Long b = map.computeIfPresent(((int) s2.charAt(i - s1.length())), (k, v) -> ++v);
                if (b != null && b == 1){
                    ok++;
                }
            }
            if (ok == 0){
                return true;
            }
        }
        return false;
    }
}
```

### shortest unsorted continuous subarray rust

```rust
impl Solution {

    pub fn find_unsorted_subarray(nums: Vec<i32>) -> i32 {
        let mut q = vec![];
        
        let mut start = nums.len() as i32;
        let mut end = 0 as i32;

        for n in 0..nums.len() {
            if q.is_empty() || nums[*q.last().unwrap() as usize] <= nums[n] {
                q.push(n as i32);
            }else {
                let mut i = q.len() as i32 - 1;
                while i >= 0 && nums[q[i as usize] as usize] > nums[n]{
                    i -= 1;
                }
                start = start.min(i);
                end = end.max(n as i32);
            }
        }
        if end < start {
            0
        } else {
            end - start
        }
    }


}
```

### shortest unsorted continuous subarray java

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int ans = 0;
        int[] copy = Arrays.copyOf(nums, nums.length);
        Arrays.sort(copy);
        int i = -1;
        while (++i < copy.length && copy[i] == nums[i]){
            ans++;
        }
        int j = copy.length;
        while (--j > i && copy[j] == nums[j]){
            ans++;
        }
        return nums.length - ans;
    }
}
```

### big countries mysql

```mysql
# Write your MySQL query statement below
select name, population, area from world where area > 3000000 or population > 25000000
```

### classes more than 5 students mysql

```mysql
# Write your MySQL query statement below
select class
from courses
group by class
having count(distinct student) >= 5;
```

### non negative integers without consecutive ones java

```java
class Solution {

    public int findIntegers(int num) {
        int[] dp = new int[32];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < dp.length; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        int sum = 0;
        int i = 30;
        boolean last_bit = false;
        do {
            if ((num & (1 << i)) != 0){
                sum += dp[i];
                if (last_bit){
                    sum--;
                    break;
                }
                last_bit = true;
            }else {
                last_bit = false;
            }
        }while (--i >= 0);
        return ++sum;
    }
}
```

### merge two binary trees rust

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn merge_trees(root1: Option<Rc<RefCell<TreeNode>>>, root2: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        match (root1, root2) {
            (Some(node1), Some(node2)) => {
                let left = Solution::merge_trees(node1.borrow_mut().left.take(), node2.borrow_mut().left.take());
                let right = Solution::merge_trees(node1.borrow_mut().right.take(), node2.borrow_mut().right.take());
                Some(Rc::new(RefCell::new(TreeNode{val: node1.borrow_mut().val + node2.borrow_mut().val, left, right})))
            },
            (Some(n), None) | (None, Some(n)) => Some(n),
            _ => None,
        }
    }
}
```

### merge two binary trees java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
      if (root1 == null){
          return root2;
      }
      if (root2 == null){
          return root1;
      }
      root1.val += root2.val;
        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);
        return root1;
    }
}
```

### not boring movies mysql

```mysql
# Write your MySQL query statement below
select id, movie, description, rating
from cinema
where id mod 2 = 1 and description <> 'boring'
order by rating desc;
```

### task scheduler rust

```rust
impl Solution {
    pub fn least_interval(tasks: Vec<char>, n: i32) -> i32 {
        let mut cnts = std::collections::HashMap::new();
        let mut m = 0;
        for &t in &tasks {
            let cnt = cnts.entry(t).or_insert(0);
            *cnt += 1;
        }
        let a = cnts.iter().map(|(_, &c)| c).max().unwrap();
        let s = cnts.iter().filter(|&(_, &c)| c == a).count() as i32;

        let one = (a - 1) * (n + 1) + s;
        one.max(tasks.len() as i32)
    }
}
```

### task scheduler java

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {

        Map<Integer, Integer> cnts = new HashMap<>();
        for (char task : tasks) {
            cnts.compute((int)task, (k, v) -> v == null? 1: ++v);
        }

        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());
        queue.addAll(cnts.values());

        n += 1;
        int ans = 0;
        int c = 0;
        int lstc = 0;
        int[] tmp = new int[n];
        while (!queue.isEmpty()){
            while (!queue.isEmpty() && c < n){
                tmp[c++] = queue.poll();
            }
            lstc = c;
            while (c > 0){
                int i = tmp[--c];
                if (i > 1) {
                    queue.add(--i);
                }
            }
            ans += n;
        }

        return ans - (n - lstc);

    }
}
```

### exchange seats mysql

```mysql
# Write your MySQL query statement below
select 
(case
when (id - (select min(id) from seat)) % 2 = 1 then id - 1 
when id = (select max(id) from seat) then id 
else id + 1 end) as id
, student
from seat
order by id
```

### swap salary mysql

```mysql
# Write your MySQL query statement below
update salary set sex = (case when sex = 'm' then 'f' when sex = 'f' then 'm' else sex end)
```

### sum of square numbers java

```java
class Solution {
    public boolean judgeSquareSum(int c) {

        int i = 0, ii = 0;
        int left = c - ii;
        do{
            if (isSqure(left)){
                return true;
            }
            i++;
            ii = i * i;
            left = c - ii;
        }while(left >= 0);
        return false;
    }

    private boolean isSqure(int left) {
        if (left < 0){
            return false;
        }
        if (left <= 1){
            return true;
        }
        int i = left % 10;
        if (i == 2 || i == 3 || i == 7 || i == 8){
            return false;
        }
        int l = 0, r = (left >> 1) + 1;
        int m = -1;
        while (true){
            int mt = m;
            m = (l + r) >> 1;
            if (m == mt){
                return false;
            }
            int mm = m * m;
            if (mm == left){
                return true;
            }
            if (mm > left || mm < 0){
                r = m;
            }else{
                l = m;
            }

        }

    }
}
```

### set mismatch rust

```rust
impl Solution {

    pub fn find_error_nums(nums: Vec<i32>) -> Vec<i32> {
        let mut nums = nums;
        let mut ans: Vec<i32> = vec![];
        for i in 0..nums.len() {
            let idx = (nums[i].abs() - 1) as usize;
            if nums[idx] < 0 {
                ans.push(nums[i].abs() as i32)
            } else {
                nums[idx] = -nums[idx];
            }
        }
        ans.push(nums.iter().enumerate()
        .filter(|&(_, &v)| v > 0)
        .map(|(i, _)| i + 1)
        .next()
        .unwrap() as i32);
        ans
    }

}
```

### palindromic substrings rust

```rust
impl Solution {

    pub fn count_substrings(s: String) -> i32 {
        let n = s.len();
        let mut ans = 0;
        let mut dp = vec![vec![false; n]; n];
        for i in 0..n {
            for j in 0..n-i {
                match i {
                    0 => dp[j][i + j] = true,
                    1 => dp[j][i + j] = s.as_bytes()[j] == s.as_bytes()[i + j],
                    _ => dp[j][i + j] = dp[j + 1][i + j - 1] && s.as_bytes()[j] == s.as_bytes()[i + j],
                }
                if dp[j][i + j] {
                    ans += 1;
                }
            }
        }
        ans
    }
}
```

### palindromic substrings java

```java
class Solution {
    public int countSubstrings(String s) {
        boolean[][] b = new boolean[s.length()][s.length()];
        int ans = 0;
        for (int len = 0; len < s.length(); len++) {
            for (int j = 0; j < s.length() - len; j++) {
                int end = j + len;
                if (len == 0){
                    b[j][end] = true;
                }else if (len == 1){
                    b[j][end] = s.charAt(j) == s.charAt(end);
                }else{
                    b[j][end] = b[j + 1][end - 1] && s.charAt(j) == s.charAt(end);
                }
                if (b[j][end]){
                    ans++;
                }
            }
        }
        return ans;
    }
}
```

### top k frequent words java

```java
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        return Arrays.stream(words).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet()
                .stream()
                .sorted(Comparator.comparingLong(Map.Entry<String, Long>::getValue).reversed().thenComparing(Map.Entry::getKey))
                .map(Map.Entry::getKey)
                .limit(k)
                .collect(Collectors.toList());
    }
}
```

### number of atoms rust

```rust
impl Solution {

    pub fn count_of_atoms(formula: String) -> String {

        fn go<'a>(pos: &mut usize, formula: &'a String) -> Vec<(&'a str, usize)> {
            let mut ans: Vec<(&str, usize)> = vec![];
            loop {
                if *pos < formula.len() {
                    let b = formula.as_bytes()[*pos];
                    match b {
                        b')' => {
                            *pos += 1;
                            return ans;
                        },
                        _ => {
                            for &mut (str, num) in &mut parseName(pos, formula) {
                                let e = ans
                                .iter_mut()
                                .filter(|(astr, anum)| str.cmp(astr) == std::cmp::Ordering::Equal)
                                .take(1).next();
                                match e {
                                    Some(i) => {
                                        *i = (str, num + i.1)
                                    },
                                    _ => ans.push((str, num))
                                }
                            }
                            
                        },
                    }
                } else {
                    return ans;
                }
            }
        }

        fn parseName<'a>(pos: &mut usize, formula: &'a String) -> Vec<(&'a str, usize)> {
            let mut ans: Vec<(&str, usize)> = vec![];
            while *pos < formula.len() {
                let b = formula.as_bytes()[*pos];
                match b {
                    b'(' => {
                        *pos += 1;
                        let mut names = go(pos, formula);
                        let n = parseNum(pos, formula);
                        return names.iter().map(|&(str, num)| (str, num * n)).collect();
                    },
                    b')' => {

                    },
                    b'A'..=b'Z' => {
                        let last = *pos;
                        *pos += 1;
                        while *pos < formula.len() {
                            let bb = formula.as_bytes()[*pos];
                            match bb {
                                b'a'..=b'z' => {*pos += 1; continue;},
                                _ => {
                                    ans.push((&formula[last..*pos], parseNum(pos, formula)));
                                    return ans;
                                },
                            }
                        }
                        ans.push((&formula[last..*pos], parseNum(pos, formula)));
                    },
                    _ => {
                        panic!("{}", pos);
                    }
                }
            }
            ans
        }
            
        fn parseNum(pos: &mut usize, formula: &String) -> usize {
            let mut ans = 0;
            while *pos < formula.len() {
                let b = formula.as_bytes()[*pos];
                match b {
                    b'0'..=b'9' => {
                        ans *= 10;
                        ans += (b - b'0') as usize;
                        *pos += 1;
                    },
                    _ => break,
                }
            }
            if ans == 0 {1} else {ans}
        }
        let mut pos = 0;
        let mut a = go(&mut pos, &formula);
        let mut ans = String::new();
        a.sort_by_key(|&(str,_)| str);
        for &(str, num) in &a {
            ans.push_str(&format!("{}", str));
            if num > 1 {
                ans.push_str(&format!("{}", num));
            }
        }

        ans
    }

}
```

### daily temperatures rust

```rust
impl Solution {


pub fn daily_temperatures(temperatures: Vec<i32>) -> Vec<i32> {
    let mut q = vec![];
    let mut ans = vec![0; temperatures.len()];
    for i in (0..temperatures.len()).rev() {
        while !q.is_empty() && temperatures[*q.last().unwrap()] <= temperatures[i] {
            q.pop();
        }
        if q.is_empty() {
            ans[i] = 0;
        } else {
            ans[i] = (*q.last().unwrap() - i) as i32;
        }
        q.push(i);
    }
    ans
}
}
```

### daily temperatures java

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        Deque<Integer> q = new LinkedList<>();
        for (int i = 0; i < temperatures.length; i++) {
            while (!q.isEmpty() && temperatures[i] > temperatures[q.peek()]){
                int poll = q.pop();
                ans[poll] = i - poll;
            }
            q.push(i);
        }
        return ans;
    }
}
```

### open the lock java

```java
class Solution {


    public int openLock(String[] deadends, String target) {

        int targetInt = Integer.parseInt(target);
        if (targetInt == 0){
            return 0;
        }

        int[] sean = new int[10000];
        for (String d : deadends) {
            sean[Integer.parseInt(d)] = 1;
        }
        if (sean[0] == 1 || sean[targetInt] == 1){
            return -1;
        }
        List<Integer> r = new ArrayList<>();
        r.add(0);
        sean[0] = 1;
        int step = 0;
        int[] stps = {1, 10, 100, 1000};
        while (!r.isEmpty()){
            List<Integer> cur = new ArrayList<>();
            for (Integer t : r) {
                int tt = t;
                for (int tmp : stps) {
                    int c = tt % 10;
                    if (c + 1 > 9) {
                        cur.add(t - 9 * tmp);
                    }else {
                        cur.add(t + tmp);
                    }
                    if (c - 1 < 0) {
                        cur.add(t + 9 * tmp);
                    }else {
                        cur.add(t - tmp);
                    }
                    tt /= 10;
                }
            }
            step++;
            r.clear();
            for (Integer i : cur) {
                if (targetInt == i){
                    return step;
                }
                if (sean[i] == 0){
                    sean[i] = 1;
                    r.add(i);
                }
            }

        }

        return -1;
    }

}
```

### sliding puzzle java

```java
class Solution {


    public int slidingPuzzle(int[][] board) {
        int ans = 0;
        int m = 2;
        int n = 3;

        int[][] target = {{1,2,3},{4,5,0}};
        if (Arrays.deepEquals(target, board)){
            return 0;
        }

        int[][] stps = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int[] mapping = {2, 3, 0, 1};

        Set<Node> sean = new HashSet<>();
        Set<Node> q = new HashSet<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 0) {
                    q.add(new Node(board, i, j, -1));
                    break;
                }
            }
        }

        while (!q.isEmpty()){
            ans++;
            Set<Node> cur = new HashSet<>();
            for (Node a : q) {
                for (int i = 0; i < stps.length; i++) {
                    if (a.stp == i){
                        continue;
                    }
                    int xx = a.x + stps[i][0];
                    int yy = a.y + stps[i][1];
                    if (xx >= m || yy >= n || xx < 0 || yy < 0){
                        continue;
                    }
                    int[][] copy = Arrays.stream(a.board).map(x -> Arrays.copyOf(x, x.length)).toArray(int[][]::new);
                    int tmp = copy[xx][yy];
                    copy[xx][yy] = copy[a.x][a.y];
                    copy[a.x][a.y] = tmp;
                    Node node = new Node(copy, xx, yy, mapping[i]);
                    if (sean.add(node) && cur.add(node) && Arrays.deepEquals(copy, target)) {
                        return ans;
                    }
                }
            }
            q = cur;
        }

        return -1;
    }
    static class Node{
        private int[][] board;
        private int x;
        private int y;
        private int stp;

        public Node(int[][] board, int x, int y, int stp) {
            this.board = board;
            this.x = x;
            this.y = y;
            this.stp = stp;
        }

        @Override
        public boolean equals(Object o) {
            Node n = (Node) o;
            return x == n.x && y == n.y && Arrays.deepEquals(board, n.board);
        }

        @Override
        public int hashCode() {
            return x + y + Arrays.deepHashCode(board);
        }
    }


}
```

### bus routes java

```java
class Solution {


    public int numBusesToDestination(int[][] routes, int source, int target) {
        if (source == target) {
            return 0;
        }
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < routes.length; i++) {
            for (int j = 0; j < routes[i].length; j++) {
                map.computeIfAbsent(routes[i][j], k -> new ArrayList<>()).add(i);
            }
        }
        int[] visited = new int[1000_000];
        List<Integer> q = new ArrayList<>();
        q.add(source);
        visited[source] = 1;

        int[] rVisisted = new int[501];
        int ans = 0;
        while (!q.isEmpty()){
            ans++;
            List<Integer> term = new ArrayList<>();
            for (Integer k : q) {
                for (Integer route : map.getOrDefault(k, Collections.emptyList())) {
                    if (rVisisted[route] == 1){
                        continue;
                    }
                    rVisisted[route] = 1;
                    for (int station : routes[route]) {
                        if (visited[station] == 0){
                            visited[station] = 1;
                            term.add(station);
                            if (station == target){
                                return ans;
                            }
                        }
                    }
                }
            }
            q = term;
        }
        return -1;
    }


}
```

### peak index in a mountain array java

```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int l = 0, r = arr.length - 1;
        while (l < r){
            int mid = l + (r - l) / 2;
            if (mid > 1){
                if (arr[mid - 1] < arr[mid]){
                    l = mid;
                }else {
                    r = mid - 1;
                }
            }
            if (mid < arr.length - 1){
                if (arr[mid] < arr[mid + 1]){
                    l = mid + 1;
                }else {
                    r = mid;
                }
            }
        }
        return l;
    }
}
```

### leaf similar trees java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        List<Integer> l1 = new ArrayList<>();
        dfs(root1, l1);
        List<Integer> l2 = new ArrayList<>();
        dfs(root2, l2);
        return Arrays.equals(l1.toArray(), l2.toArray());
    }
    
    private void dfs(TreeNode r, List<Integer> l){
        if (r.left == null && r.right == null){
            l.add(r.val);
            return;
        }
        if (r.left != null){
            dfs(r.left, l);
        }
        if (r.right != null){
            dfs(r.right, l);
        }
    }

}
```

### stone game java

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        return true;
    }
}
```

### profitable schemes java

```java
class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
      int[][] dp = new int[n + 1][minProfit + 1];
        IntStream.rangeClosed(0, n).forEach(i -> dp[i][0] = 1);
        int mod = (int) 1e9 + 7;
        for (int k = 0; k < group.length; k++) {
            for (int i = n; i >= group[k]; i--) {
                for (int j = minProfit; j >= 0; j--) {
                    dp[i][j] = (dp[i][j] + dp[i - group[k]][Math.max(0, j - profit[k])]) % mod;
                }
            }
        }
        return dp[n][minProfit];
    }
}
```

### increasing order search tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode increasingBST(TreeNode root) {
        if (root == null){
            return null;
        }
        root.right = increasingBST(root.right);
        if (root.left == null){
            return root;
        }
        TreeNode treeNode = increasingBST(root.left);
        root.left = null;
        TreeNode newRoot = treeNode;
        while (treeNode.right != null){
            treeNode = treeNode.right;
        }
        treeNode.right = root;
        return newRoot;
    }
}
```

### snakes and ladders java

```java
class Solution {


    public int snakesAndLadders(int[][] board) {
        int n = board.length;
        if (n == 1){
            return 0;
        }
        int ans = 0;
        int target = n * n;
        Set<Integer> sean = new HashSet<>();
        sean.add(1);
        Set<Integer> q = new HashSet<>();
        q.add(1);
        while (!q.isEmpty()) {
            ans++;
            Set<Integer> term = new HashSet<>();
            for (Integer num : q) {
                for (int i = 1; i <= 6; i++) {
                    int e = num + i;
                    if (e <= target){
                        int[] exy = getPos(e, n);
                        int eto = board[exy[0]][exy[1]];
                        e = eto > 0? eto: e;
                        if (sean.add(e)){
                            term.add(e);
                        }
                        if (e == target){
                            return ans;
                        }
                    }
                }
            }
            q = term;
        }
        return -1;
    }
    private int[] getPos(int num, int n) {
        int no = (num - 1) / n;
        int c = (num - 1) % n;
        if ((no & 1) > 0){
            c = n - 1 - c;
        }
        return new int[]{n - 1 - no, c};
    }

}
```

### binary subarrays with sum rust

```rust
impl Solution {

    pub fn num_subarrays_with_sum(nums: Vec<i32>, goal: i32) -> i32 {
        let mut map: std::collections::HashMap<i32, i32> = std::collections::HashMap::new();
        let mut sum = 0;
        let mut ans = 0;
        map.insert(0, 1);
        for i in nums {
            sum += i;
            if let Some(&s) = map.get(&(sum - goal)) {
                ans += s;
            }
            let a = map.entry(sum).or_insert(0);
            *a += 1;
        }
        ans
    }
}
```

### range sum of bst java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if (root == null){
            return 0;
        }
        int sum = 0;
        if (root.val < low){
            sum += rangeSumBST(root.right, low, high);
        }else if (root.val > high){
            sum += rangeSumBST(root.left, low, high);
        }else{
            sum += root.val + rangeSumBST(root.right, low, high) + rangeSumBST(root.left, low, high);
        }
        
        return sum;
    }
    
}
```

### unique paths iii java

```java
class Solution {

    public int uniquePathsIII(int[][] grid) {

        int startx = 0, starty = 0;
        int endx = 0, endy = 0;
        int roadcnt = 0;
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0){
                    roadcnt++;
                }else if (grid[i][j] == 1){
                    startx = i;
                    starty = j;
                }else if (grid[i][j] == 2){
                    endx = i;
                    endy = j;
                }
            }
        }

        boolean[][] f = new boolean[m][n];
        return uniquePathsIII(grid, f, startx, starty, endx, endy, roadcnt);
    }

    private int uniquePathsIII(int[][] grid, boolean[][] f, int startx, int starty, int endx, int endy, int roadcnt) {
        boolean b = roadcnt < 0;
        boolean c = startx == endx && starty == endy;
        if (b || c){
            return b && c ? 1 : 0;
        }
        f[startx][starty] = true;
        int[][] steps = {{1,0},{-1,0},{0,1},{0,-1}};
        int s = 0;
        for (int[] step : steps) {
            int xx = startx + step[0];
            int yy = starty + step[1];
            if (xx < 0 || yy < 0 || xx >= grid.length || yy >= grid[0].length || f[xx][yy] || grid[xx][yy] < 0){
                continue;
            }
            s += uniquePathsIII(grid, f, xx, yy, endx, endy, roadcnt - 1);
        }
        f[startx][starty] = false;
        return s;
    }
}
```

### time based key value store rust

```rust
struct TimeMap{
    map: std::collections::HashMap<String, Vec<(i32, String)>>
}

/**
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */


impl TimeMap {

    /** Initialize your data structure here. */
    fn new() -> Self {
        TimeMap {
            map: std::collections::HashMap::new()
        }
    }
    
    fn set(&mut self, key: String, value: String, timestamp: i32) {
        if let Some(v) = self.map.get_mut(&key) {
            v.insert(v.len(), (timestamp, value));
        }else {
            let mut v = Vec::with_capacity(60000);
            v.push((timestamp, value));
            self.map.insert(key, v);
        }
    }
    
    fn get(&self, key: String, timestamp: i32) -> String {
        if let Some(v) = self.map.get(&key) {
            match v.binary_search_by_key(&timestamp, |&(t, _)| t) {
                Ok(i) => v[i].1.clone(),
                Err(i) => {
                    if i == 0 {
                        String::new()
                    } else {
                        v[i - 1].1.clone()
                    }
                },
            }
        }else {
            String::new()
        }
    }
}


/**
 * Your TimeMap object will be instantiated and called as such:
 * let obj = TimeMap::new();
 * obj.set(key, value, timestamp);
 * let ret_2: String = obj.get(key, timestamp);
 */
```

### add to array form of integer java

```java
class Solution {
    public List<Integer> addToArrayForm(int[] num, int k) {

        ArrayList<Integer> ans = new ArrayList<>();
        
        int last = 0;
        int n = num.length - 1;
        while (n >= 0 || k > 0){
            int a = n >= 0 ? num[n--] : 0;
            int b = 0;
            if (k > 0){
                b = k % 10;
                k /= 10;
            }
            int c = a + b + last;
            if (c > 9){
                last = 1;
                ans.add(c - 10);
            }else{
                last = 0;
                ans.add(c);
            }
        }
        if (last > 0){
            ans.add(last);
        }
        Collections.reverse(ans);
        return ans;
    }
}
```

### cousins in binary tree java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(iant val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        int[] ints1 = searchParent(root, 0, x);
        int[] ints2 = searchParent(root, 0, y);
        return ints1[0] == ints2[0] && ints1[1] != ints2[1];
    }

    private int[] searchParent(TreeNode root, int level, int x){
        if (root == null){
            return null;
        }
        if (root.val == x){
            return new int[]{level, x};
        }
        int[] ints1 = searchParent(root.left, level + 1, x);
        if (ints1 != null){
            if (ints1[0] == level + 1) ints1[1] = root.val;
            return ints1;
        }
        int[] ints2 = searchParent(root.right, level + 1, x);
        if (ints2 != null){
            if (ints2[0] == level + 1) ints2[1] = root.val;
            return ints2;
        }
        return null;
    }
}
```

### uncrossed lines java

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int[][] rs = new int[nums1.length + 1][nums2.length + 1];
        for (int i = nums1.length - 1; i >= 0; i--) {
            for (int j = nums2.length - 1; j >= 0; j--) {
                int ti = i;
                int cur = rs[ti][j + 1];
                while (ti < nums1.length && rs[ti + 1][j + 1] + 1 > cur){
                    if (nums1[ti] == nums2[j]){
                        cur = rs[ti + 1][j + 1] + 1;
                        break;
                    }
                    ti++;
                }
                rs[i][j] = cur;
            }
        }

        return rs[0][0];
    }
}
```

### last stone weight ii java

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        Set<Integer> s1 = new HashSet<>();
        Set<Integer> s2 = new HashSet<>();

        s1.add(stones[0]);
        for (int i = 1; i < stones.length; i++) {
            int stone = stones[i];
            for (Integer k : s1) {
                s2.add(Math.abs(stone - k));
                s2.add(stone + k);
            }
            Set<Integer> tmp = s1;
            s1 = s2;
            s2 = tmp;
            s2.clear();
        }
        return s1.stream().min(Comparator.naturalOrder()).get();

    }
}
```

### number of submatrices that sum to target java

```java
class Solution {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int cnt = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int s = matrix[i][j];
                if (i > 0){
                    s += matrix[i - 1][j];
                }
                if (j > 0){
                    s += matrix[i][j - 1];
                }
                if (i > 0 && j > 0){
                    s -= matrix[i - 1][j - 1];
                }
                matrix[i][j] = s;
            }
        }
        for (int si = -1; si < m - 1; si++) {
            for (int sj = -1; sj < n - 1; sj++) {

                for (int i = si + 1; i < m; i++) {
                    for (int j = sj + 1; j < n; j++) {
                        int s = matrix[i][j];
                        if (si >= 0){
                            s -= matrix[si][j];
                        }
                        if (sj >= 0){
                            s -= matrix[i][sj];
                        }
                        if (si >= 0 && sj >= 0){
                            s += matrix[si][sj];
                        }

                        if (s == target){
                            cnt++;
                        }
                    }
                }
            }
        }
        return cnt;

    }
}
```

### print in order java

```java
class Foo {

    public Foo() {

    }

    private Exchanger<Integer> ex1 = new Exchanger<>();
    private Exchanger<Integer> ex2 = new Exchanger<>();

    public void first(Runnable printFirst) throws InterruptedException {
        // printFirst.run() outputs "first". Do not change or remove this line.
        printFirst.run();
        ex1.exchange(1);
    }

    public void second(Runnable printSecond) throws InterruptedException {
        // printSecond.run() outputs "second". Do not change or remove this line.
        ex1.exchange(2);
        printSecond.run();
        ex2.exchange(2);
    }

    public void third(Runnable printThird) throws InterruptedException {

        ex2.exchange(3);
        // printThird.run() outputs "third". Do not change or remove this line.
        printThird.run();

    }
}
```

### print foobar alternately java

```java
class FooBar {
    private int n;

    public FooBar(int n) {
        this.n = n;
    }

    private Exchanger<Integer> ex1 = new Exchanger<>();
    private Exchanger<Integer> ex2 = new Exchanger<>();
    
    public void foo(Runnable printFoo) throws InterruptedException {

        for (int i = 0; i < n; i++) {
            // printFoo.run() outputs "foo". Do not change or remove this line.
            printFoo.run();
            ex1.exchange(1);
            ex2.exchange(1);
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {

        for (int i = 0; i < n; i++) {
            ex1.exchange(1);
            // printBar.run() outputs "bar". Do not change or remove this line.
            printBar.run();
            ex2.exchange(1);

        }
    }
}
```

### print zero even odd java

```java
class ZeroEvenOdd {
    private int n;

    public ZeroEvenOdd(int n) {
        this.n = n;
    }

    Exchanger<Integer> ex1 = new Exchanger<>();
    Exchanger<Integer> ex2 = new Exchanger<>();
    Exchanger<Integer> ok = new Exchanger<>();

    // printNumber.accept(x) outputs "x", where x is an integer.
    public void zero(IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; i++) {
            printNumber.accept(0);
            if ((i % 2) > 0){
                ex1.exchange(1);
            }else {
                ex2.exchange(2);
            }
            ok.exchange(0);
        }
    }

    public void even(IntConsumer printNumber) throws InterruptedException {
        for (int i = 2; i <= n; i+=2) {
            ex2.exchange(2);
            printNumber.accept(i);
            ok.exchange(0);
        }
    }

    public void odd(IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; i+=2) {
            ex1.exchange(1);
            printNumber.accept(i);
            ok.exchange(0);
        }
    }
}
```

### reverse substrings between each pair of parentheses java

```java
class Solution {


    public String reverseParentheses(String s) {
        Map<Integer, Integer> index = new HashMap<>();
        char[] chars = s.toCharArray();

        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '('){
                i = go(chars, i, index);
            }
        }
        return aux(chars, 1, -1, chars.length, index);
    }

    private int go(char[] chars, int i, Map<Integer, Integer> index){
        int j = i;
        while (chars[++j] != ')'){
            if (chars[j] == '('){
                j = go(chars, j, index);
            }
        }
        index.put(i, j);
        index.put(j, i);
        return j;
    }

    private String aux(char[] chars, int step, int from, int to, Map<Integer, Integer> index) {
        StringBuilder sb = new StringBuilder();
        for (int i = from + step; i != to; i += step) {
            if (chars[i] == '(' || chars[i] == ')'){
                Integer newfrom = index.get(i);
                String aux = aux(chars, -step, newfrom, i, index);
                sb.append(aux);
                i = newfrom;
            }else{
                sb.append(chars[i]);
            }
        }
        return sb.toString();
    }

}
```

### maximum length of a concatenated string with unique characters java

```java
class Solution {
    

    public int maxLength(List<String> arr) {
        List<Integer> iarr = new ArrayList<>();
        outer:for (String s : arr) {
            int r = 0;
            for (int i = 0; i < s.length(); i++) {
                if((r & (1 << (s.charAt(i) - 'a'))) == 0){
                    r |= (1 << (s.charAt(i) - 'a'));
                }else {
                    continue outer;
                }
            }
            iarr.add(r);
        }
        return dfs(iarr, 0, 0);
    }

    private int dfs(List<Integer> iarr, int i, int mask) {
        if (i >= iarr.size()){
            return Integer.bitCount(mask);
        }
        int ans1 = dfs(iarr, i + 1, mask);
        int ans2 = 0;
        if ((mask & iarr.get(i)) == 0) {
            ans2 = dfs(iarr, i + 1, mask | iarr.get(i));
        }
        return Math.max(ans1, ans2);
    }

}
```

### display table of food orders in a restaurant rust

```rust
impl Solution {


    pub fn display_table(orders: Vec<Vec<String>>) -> Vec<Vec<String>> {
        let mut map = std::collections::HashMap::new();
        let mut foods: Vec<String> = vec![];
        for mut order in orders {
            let table: i32 = order[1].parse().unwrap();
            let food_name = order.remove(2);
            let name = foods.iter().enumerate().filter(|&(_, x)| food_name.eq(x)).next();
            let f_idx = match name {
                Some((idx, _)) => idx,
                None => {
                    foods.push(food_name);
                    foods.len() - 1
                }
            };
            let num = map.entry(table).or_insert(std::collections::HashMap::new())
                                .entry(f_idx).or_insert(0);
            *num += 1;
        }
        
        let mut food_with_idx: Vec<(usize, &String)> = foods.iter().enumerate().collect();
        food_with_idx.sort_by_key(|&(_, str)| str);
        let mut tables: Vec<&i32> = map.keys().collect();
        tables.sort();

        let mut ans = vec![];
        let mut head = vec![];
        head.push("Table".to_string());
        let mut food_names: Vec<String>= food_with_idx.iter().map(|&(_, str)| str.clone()).collect();
        head.append(&mut food_names);
        ans.push(head);
        for t in tables {
            let mut row = vec![];
            row.push(t.to_string());
            let m = map.get(t).unwrap();
            for (f_idx, _) in &food_with_idx {
                row.push(m.get(f_idx).unwrap_or(&0).to_string());
            }
            ans.push(row);
        }

        ans
    }


}
```

### form largest integer with digits that add up to target java

```java
class Solution {
    public String largestNumber(int[] cost, int target) {
        int[] dp = new int[target + 1];
        Arrays.fill(dp, -1);
        dp[0] = 0;
        for (int i = 1; i <= target; i++) {
            for (int c : cost) {
                if (i >= c && dp[i - c] >= 0){
                    dp[i] = Math.max(dp[i], dp[i - c] + 1);
                }
            }
        }
        if (dp[target] < 0){
            return "0";
        }
        String ans = "";
        for (int i = cost.length - 1; i >= 0; i--) {
            int c = cost[i];
            for (int j = target; j >= c && dp[j] == dp[j - c] + 1; j -= c) {
                ans += i + 1;
                target -= c;
            }
        }
        return ans;
    }
}
```

### throne inheritance java

```java
class ThroneInheritance {
        
    private String root;
    private Map<String, List<String>> map = new HashMap<>();
    private Set<String> death = new HashSet<>();
    
    public ThroneInheritance(String kingName) {
        root = kingName;
    }

    public void birth(String parentName, String childName) {
        map.computeIfAbsent(parentName, l -> new ArrayList<>()).add(childName);
    }

    public void death(String name) {
        death.add(name);
    }

    public List<String> getInheritanceOrder() {
        ArrayList<String> es = new ArrayList<>();
        succ(root, es);
        return es;
    }

    private void succ(String root, ArrayList<String> ans) {
        if (!death.contains(root)){
            ans.add(root);
        }
        List<String> children = map.get(root);
        if (children != null) {
            for (String s : children) {
                succ(s, ans);
            }
        }
    }
}

/**
 * Your ThroneInheritance object will be instantiated and called as such:
 * ThroneInheritance obj = new ThroneInheritance(kingName);
 * obj.birth(parentName,childName);
 * obj.death(name);
 * List<String> param_3 = obj.getInheritanceOrder();
 */
```

### count good meals rust

```rust
impl Solution {


    pub fn count_pairs(deliciousness: Vec<i32>) -> i32 {
        let mut deliciousness = deliciousness;
        deliciousness.sort();
        let mut ans = 0;

        for p in 0..=21 {
            let target = 1 << p;
            let mut left = 0;
            let mut right = deliciousness.len() - 1;
            while left < right {
                let a = deliciousness[left] + deliciousness[right];
                if deliciousness[left] > target {
                    break;
                }
                
                if a > target {
                    right -= 1;
                } else if a < target {
                    left += 1;
                } else if deliciousness[left] == deliciousness[right] {
                    let n = right - left + 1;
                    ans += (n as i64 * (n - 1) as i64 / 2) % 1000_000_007;
                    ans %= 1000_000_007;
                    break;
                }else {
                    let mut cnt_left = 0;
                    let mut cnt_right = 0;
                    let val_left = deliciousness[left];
                    let val_right = deliciousness[right];
                    while val_left == deliciousness[left] {
                        cnt_left += 1;
                        left += 1;
                    }
                    while val_right == deliciousness[right] {
                        cnt_right += 1;
                        right -= 1;
                    }
                    ans += (cnt_left as i64 * cnt_right as i64) % 1000_000_007;
                    ans %= 1000_000_007;
                }
            }
        }

        ans as i32
    }
        


}
```

### decode xored array java

```java
class Solution {
    public int[] decode(int[] encoded, int first) {
        int[] ret = Arrays.copyOf(encoded, encoded.length + 1);
        ret[0] = first;
        for (int i = 1; i < ret.length; i++) {
            ret[i] = ret[i - 1] ^ encoded[i - 1];
        }
        return ret;
    }
}
```

### decode xored permutation java

```java
class Solution {
    public int[] decode(int[] encoded) {
        int[] ans = new int[encoded.length + 1];
        int all = 0;
        for (int i = 1; i <= ans.length; i++) {
            all ^= i;
        }
        for (int i = 1; i < encoded.length; i += 2) {
            all ^= encoded[i];
        }
        ans[0] = all;
        for (int i = 0; i < encoded.length; i++) {
            ans[i + 1] = ans[i] ^ encoded[i];
        }
        
        return ans;
    }
}
```

### find kth largest xor coordinate value java

```java
class Solution {
    public int kthLargestValue(int[][] matrix, int k) {
        PriorityQueue<Integer> p = new PriorityQueue<>(k, Comparator.reverseOrder());
        int[][] values = new int[matrix.length][matrix[0].length];
        for (int i = 0; i < values.length; i++) {
            for (int j = 0; j < values[0].length; j++) {
                int v = matrix[i][j];
                if (i > 0){
                    v ^= values[i - 1][j];
                }
                if (j > 0){
                    v ^= values[i][j - 1];
                }
                if (i > 0 && j > 0){
                    v ^= values[i - 1][j - 1];
                }
                values[i][j] = v;
                p.add(v);
            }
        }
//        System.out.println(Arrays.deepToString(values));
        IntStream.range(1, k).forEach(x -> p.poll());
        return p.poll();
    }
}
```

### can you eat your favorite candy on your favorite day java

```java
class Solution {
    public boolean[] canEat(int[] candiesCount, int[][] queries) {
        long[] s = new long[candiesCount.length];
        for (int i = 1; i < s.length; i++) {
            s[i] = s[i - 1] + candiesCount[i - 1];
        }
        boolean[] ret = new boolean[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int[] query = queries[i];
            ret[i] = s[query[0]] + candiesCount[query[0]] > query[1] && s[query[0]] < (long) query[2] * (query[1] + 1);
        }
        return ret;
    }
}
```

### minimum absolute sum difference rust

```rust
impl Solution {
    
    pub fn min_absolute_sum_diff(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let mut s = nums1.clone();
        s.sort_unstable();
        let mut diff = 0;
        let mut ans = 0;
        for (index, &n) in nums2.iter().enumerate() {
            let orig = (nums1[index] - nums2[index]).abs();
            ans = (ans + orig) % 1_000_000_007;
            diff = match s.binary_search(&n) {
                Ok(_) => orig,
                Err(idx) => {
                    let mut c = 0;
                    if idx > 0 {
                        c = c.max(orig - (s[idx - 1] - n).abs());
                    }
                    if idx < nums1.len() {
                        c = c.max(orig - (s[idx] - n).abs());
                    }
                    c
                }
            }.max(diff);
        }
        (ans - diff + 1_000_000_007) % 1_000_000_007
    }


}
```

### maximum ice cream bars rust

```rust
impl Solution {


    pub fn max_ice_cream(costs: Vec<i32>, coins: i32) -> i32 {
        let mut costs = costs;
        costs.sort_unstable();
        let mut s = 0;
        
        for i in 0..costs.len() {
            s += costs[i];
            if s > coins {
                return i as i32;
            }
        }

        costs.len() as i32
    }

}
```

### frequency of the most frequent element rust

```rust
impl Solution {

pub fn max_frequency(nums: Vec<i32>, k: i32) -> i32 {
    let mut ans = 0;
    let mut diff = 0;
    let mut nums = nums;
    nums.sort_unstable();
    let n = nums.len();
    let mut left = 0;
    for right in 1..n {
        diff += ((right - left) * (nums[right] - nums[right - 1]) as usize) as i32;
        while diff > k {
            diff -= nums[right] - nums[left];
            left += 1;
        }
        ans = ans.max(right - left);
    }
    1 + ans as i32
}

}
```

### frequency of the most frequent element java

```java
class Solution {

    public int maxFrequency(int[] nums, int k) {
        Arrays.sort(nums);
        int right = nums.length - 1;
        int left = right;
        int change = 0;
        int lastval = 0;
        int ans = 0;
        while (right >= 0) {
            int target = nums[right];
            int nextright = firstLessIdx(nums, target);
            if (change > 0) {
                k += (lastval - target) * change;
                change -= right - nextright;
            }
            left = Math.min(left, nextright);
            while (left >= 0 && target - nums[left] <= k) {
                k -= target - nums[left];
                left--;
                change++;
            }
            ans = Math.max(ans, right - left);
            lastval = target;
            right = nextright;
        }
        return ans;
    }
    
    private int firstLessIdx(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return right;
    }
}
```

### maximum element after decreasing and rearranging rust

```rust
impl Solution {

pub fn maximum_element_after_decrementing_and_rearranging(arr: Vec<i32>) -> i32 {
    let mut arr = arr;
    arr.sort_unstable();
    arr[0] = 1;
    for i in 1..arr.len() {
        if (arr[i] - arr[i - 1]).abs() > 1 {
            arr[i] = arr[i - 1] + 1;
        }
    }
    *arr.last().unwrap()
}
}
```

### minimize maximum pair sum in array rust

```rust
impl Solution {

pub fn min_pair_sum(nums: Vec<i32>) -> i32 {
    let mut nums = nums;
    nums.sort_unstable();
    let n = nums.len();
    let mut left = 0;
    let mut right = n - 1;
    let mut ans = 0;
    while left < right {
        ans = ans.max(nums[left] + nums[right]);
        left += 1;
        right -= 1;
    }
    ans
}

}
```

### chuan di xin xi rust

```rust
impl Solution {

    pub fn num_ways(n: i32, relation: Vec<Vec<i32>>, k: i32) -> i32 {
        let mut map: std::collections::HashMap<i32, Vec<i32>>= std::collections::HashMap::new();
        for r in &relation {
            if map.contains_key(&r[0]) {
                map.get_mut(&r[0]).unwrap().push(r[1]);
            }else{
                map.insert(r[0], vec![r[1]]);
            }
        }
        let target = n - 1;
        let mut left = vec![0];
        let mut right: Vec<i32> = vec![];
        for i in 0..k {
            for node in &left {
                if let Some(t) = map.get(node) {
                    for &x in t {
                        right.push(x);
                    }
                }
            }
            let mut tmp = left;
            left = right;
            right = tmp;
            right.clear();
        }

        left.iter().filter(|&&x| x == target).count() as i32
    }

}
```

### er jin zhi zhong 1de ge shu lcof java

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        return Integer.bitCount(n);
    }
}
```

### xu lie hua er cha shu lcof java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

        // Encodes a tree to a single string.
        public String serialize(TreeNode root) {
            Deque<TreeNode> q = new LinkedList<>();
            StringBuilder sb = new StringBuilder();
            q.push(root);
            while (!q.isEmpty()){
                TreeNode node = q.pop();
                if (node == null){
                    sb.append("null").append(",");
                }else {
                    sb.append(node.val).append(",");
                    q.push(node.right);
                    q.push(node.left);
                }
            }
            return sb.deleteCharAt(sb.length() - 1).toString();
        }

        // Decodes your encoded data to tree.
        public TreeNode deserialize(String data) {
            String[] ds = data.split(",");
            if (ds.length == 1){
                return null;
            }
            Deque<String> q = new LinkedList<>(Arrays.asList(ds));
            return dfs(q);
        }

        private TreeNode dfs(Deque<String> ds) {
            String pop = ds.pop();
            if (pop.equals("null")){
                return null;
            }
            TreeNode node = new TreeNode(Integer.parseInt(pop));
            node.left = dfs(ds);
            node.right = dfs(ds);

            return node;
        }

    }

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

### zi fu chuan de pai lie lcof java

```java
class Solution {

    public String[] permutation(String s) {
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        List<String> ans = new ArrayList<>();
        do{
            ans.add(new String(chars));
        }while (next(chars));
        return ans.toArray(new String[0]);
    }

    private boolean next(char[] chars) {
        int index = -1;

        int n = chars.length - 1;
        for (int i = n; i >= 1; i--) {
            if (chars[i] > chars[i - 1]){
                index = i - 1;
                break;
            }
        }
        if (index < 0){
            return false;
        }
        int nn = n;
        while (chars[nn] <= chars[index]){
            nn--;
        }

        char t = chars[index];
        chars[index] = chars[nn];
        chars[nn] = t;

        int left = index + 1, right = n;
        while (left < right){
            char tmp = chars[left];
            chars[left++] = chars[right];
            chars[right--] = tmp;
        }

        return true;
    }
}
```

### lian xu zi shu zu de zui da he lcof rust

```rust
impl Solution {

    pub fn max_sub_array(nums: Vec<i32>) -> i32 {
        let mut ans = nums[0];
        let mut cur = 0;
        for i in nums {
            cur = i.max(i + cur);
            ans = ans.max(cur);
        }
        ans
    }
}
```

### zai pai xu shu zu zhong cha zhao shu zi lcof rust

```rust
impl Solution {

    pub fn search(nums: Vec<i32>, target: i32) -> i32 {
        let d = match nums.binary_search(&target) {
            Ok(i) => i as i32,
            _ => -1,
        };
        if d < 0 {
            return 0;
        }
        let d = d;
        let mut cnt = 0;
        {
            let mut left = 0;
            let mut right = d;
            while left <= right {
                let mid = left + (right - left) / 2;
                match nums[mid as usize].cmp(&target) {
                    std::cmp::Ordering::Less => left = mid + 1,
                    _ => right = mid - 1,
                }
            }
            cnt += d + 1 - left;
        }
        {
            let mut left = d;
            let mut right = nums.len()  as i32 - 1;
            while left <= right {
                let mid = left + (right - left) / 2;
                match nums[mid as usize].cmp(&target) {
                    std::cmp::Ordering::Greater => right = mid - 1,
                    _ => left = mid + 1,
                }
            }
            cnt += right - d;
        }
        cnt
    }
}
```

### group anagrams lcci rust

```rust
impl Solution {

    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {
        let mut result: Vec<Vec<String>> = vec![];
        let mut m = vec![];
        for s in strs {
            let mut cs: Vec<u8> = s.clone().into_bytes().to_vec();
            cs.sort();
            let key = String::from_utf8(cs).unwrap();
            let a = m.iter().enumerate().filter(|&(_, x)| x == &key).next();
            if a.is_some() {
                let v = a.unwrap().0;
                let tmp = &mut result[v];
                tmp.push(s);
            } else {
                m.push(key);
                result.push(vec![s]);
            }
        }
        result
    }

}
```

### find majority element lcci rust

```rust
impl Solution {
    
    pub fn majority_element(nums: Vec<i32>) -> i32 {
        let mut cur = 0;
        let mut vote = 0;
        for &i in &nums {
            if vote == 0 {
                cur = i;
            }
            if i == cur {
                vote += 1;
            } else {
                vote -= 1;
            }
        }
        let c = nums.iter().filter(|&x|cur.eq(x)).count();
        if c > nums.len() >> 1 {
            cur
        } else {
            -1
        }
    }
}
```

