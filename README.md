## Usage

 ```bash
export cookie="..." ## cookie from logon leetcode-cn
java -jar leetcodecn-downloader-1.0-SNAPSHOT-jar-with-dependencies.jar
```
Generate db file(sqlite)，and README.md file.




## My Leetcode-cn Summary
#|title|solution|topic|difficulty
--|--|--|--|--
1|[Two Sum](https://leetcode-cn.com/problems/two-sum)|[rust](#two-sum-rust)|array,hash-table|Easy
2|[Add Two Numbers](https://leetcode-cn.com/problems/add-two-numbers)|[rust](#add-two-numbers-rust)|recursion,linked-list,math|Medium
3|[Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)|[rust](#longest-substring-without-repeating-characters-rust)|hash-table,string,sliding-window|Medium
4|[Median of Two Sorted Arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)|[rust](#median-of-two-sorted-arrays-rust)|array,binary-search,divide-and-conquer|Hard
5|[Longest Palindromic Substring](https://leetcode-cn.com/problems/longest-palindromic-substring)|[rust](#longest-palindromic-substring-rust)|string,dynamic-programming|Medium
10|[Regular Expression Matching](https://leetcode-cn.com/problems/regular-expression-matching)|[rust](#regular-expression-matching-rust)|recursion,string,dynamic-programming|Hard
11|[Container With Most Water](https://leetcode-cn.com/problems/container-with-most-water)|[rust](#container-with-most-water-rust)|greedy,array,two-pointers|Medium
15|[3Sum](https://leetcode-cn.com/problems/3sum)|[rust](#3sum-rust)|array,two-pointers,sorting|Medium
17|[Letter Combinations of a Phone Number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number)|[rust](#letter-combinations-of-a-phone-number-rust)|hash-table,string,backtracking|Medium
19|[Remove Nth Node From End of List](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)|[rust](#remove-nth-node-from-end-of-list-rust)|linked-list,two-pointers|Medium
20|[Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses)|[rust](#valid-parentheses-rust)|stack,string|Easy
21|[Merge Two Sorted Lists](https://leetcode-cn.com/problems/merge-two-sorted-lists)|[rust](#merge-two-sorted-lists-rust)|recursion,linked-list|Easy
22|[Generate Parentheses](https://leetcode-cn.com/problems/generate-parentheses)|[rust](#generate-parentheses-rust)|string,dynamic-programming,backtracking|Medium
23|[Merge k Sorted Lists](https://leetcode-cn.com/problems/merge-k-sorted-lists)|[rust](#merge-k-sorted-lists-rust)|linked-list,divide-and-conquer,heap-priority-queue,merge-sort|Hard
24|[Swap Nodes in Pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs)|[rust](#swap-nodes-in-pairs-rust)|recursion,linked-list|Medium
26|[Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)|[rust](#remove-duplicates-from-sorted-array-rust)|array,two-pointers|Easy
27|[Remove Element](https://leetcode-cn.com/problems/remove-element)|[rust](#remove-element-rust)|array,two-pointers|Easy
31|[Next Permutation](https://leetcode-cn.com/problems/next-permutation)|[rust](#next-permutation-rust)|array,two-pointers|Medium
32|[Longest Valid Parentheses](https://leetcode-cn.com/problems/longest-valid-parentheses)|[rust](#longest-valid-parentheses-rust)|stack,string,dynamic-programming|Hard
33|[Search in Rotated Sorted Array](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)|[rust](#search-in-rotated-sorted-array-rust)|array,binary-search|Medium
34|[Find First and Last Position of Element in Sorted Array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array)|[rust](#find-first-and-last-position-of-element-in-sorted-array-rust)|array,binary-search|Medium
35|[Search Insert Position](https://leetcode-cn.com/problems/search-insert-position)|[rust](#search-insert-position-rust)|array,binary-search|Easy
39|[Combination Sum](https://leetcode-cn.com/problems/combination-sum)|[rust](#combination-sum-rust)|array,backtracking|Medium
42|[Trapping Rain Water](https://leetcode-cn.com/problems/trapping-rain-water)|[rust](#trapping-rain-water-rust)|stack,array,two-pointers,dynamic-programming,monotonic-stack|Hard
46|[Permutations](https://leetcode-cn.com/problems/permutations)|[rust](#permutations-rust)|array,backtracking|Medium
48|[Rotate Image](https://leetcode-cn.com/problems/rotate-image)|[rust](#rotate-image-rust)|array,math,matrix|Medium
49|[Group Anagrams](https://leetcode-cn.com/problems/group-anagrams)|[rust](#group-anagrams-rust)|hash-table,string,sorting|Medium
53|[Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray)|[rust](#maximum-subarray-rust)|array,divide-and-conquer,dynamic-programming|Easy
55|[Jump Game](https://leetcode-cn.com/problems/jump-game)|[rust](#jump-game-rust)|greedy,array,dynamic-programming|Medium
56|[Merge Intervals](https://leetcode-cn.com/problems/merge-intervals)|[rust](#merge-intervals-rust)|array,sorting|Medium
62|[Unique Paths](https://leetcode-cn.com/problems/unique-paths)|[rust](#unique-paths-rust)|math,dynamic-programming,combinatorics|Medium
64|[Minimum Path Sum](https://leetcode-cn.com/problems/minimum-path-sum)|[rust](#minimum-path-sum-rust)|array,dynamic-programming,matrix|Medium
66|[Plus One](https://leetcode-cn.com/problems/plus-one)|[rust](#plus-one-rust)|array,math|Easy
70|[Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs)|[rust](#climbing-stairs-rust)|memoization,math,dynamic-programming|Easy
72|[Edit Distance](https://leetcode-cn.com/problems/edit-distance)|[rust](#edit-distance-rust)|string,dynamic-programming|Hard
75|[Sort Colors](https://leetcode-cn.com/problems/sort-colors)|[rust](#sort-colors-rust)|array,two-pointers,sorting|Medium
76|[Minimum Window Substring](https://leetcode-cn.com/problems/minimum-window-substring)|[rust](#minimum-window-substring-rust)|hash-table,string,sliding-window|Hard
78|[Subsets](https://leetcode-cn.com/problems/subsets)|[rust](#subsets-rust)|bit-manipulation,array,backtracking|Medium
79|[Word Search](https://leetcode-cn.com/problems/word-search)|[rust](#word-search-rust)|array,backtracking,matrix|Medium
84|[Largest Rectangle in Histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram)|[rust](#largest-rectangle-in-histogram-rust)|stack,array,monotonic-stack|Hard
85|[Maximal Rectangle](https://leetcode-cn.com/problems/maximal-rectangle)|[rust](#maximal-rectangle-rust)|stack,array,dynamic-programming,matrix,monotonic-stack|Hard
94|[Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)|[rust](#binary-tree-inorder-traversal-rust)|stack,tree,depth-first-search,binary-tree|Easy
96|[Unique Binary Search Trees](https://leetcode-cn.com/problems/unique-binary-search-trees)|[rust](#unique-binary-search-trees-rust)|tree,binary-search-tree,math,dynamic-programming,binary-tree|Medium
98|[Validate Binary Search Tree](https://leetcode-cn.com/problems/validate-binary-search-tree)|[rust](#validate-binary-search-tree-rust)|tree,depth-first-search,binary-search-tree,binary-tree|Medium
101|[Symmetric Tree](https://leetcode-cn.com/problems/symmetric-tree)|[rust](#symmetric-tree-rust)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
102|[Binary Tree Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)|[rust](#binary-tree-level-order-traversal-rust)|tree,breadth-first-search,binary-tree|Medium
104|[Maximum Depth of Binary Tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree)|[rust](#maximum-depth-of-binary-tree-rust)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
105|[Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)|[rust](#construct-binary-tree-from-preorder-and-inorder-traversal-rust)|tree,array,hash-table,divide-and-conquer,binary-tree|Medium
114|[Flatten Binary Tree to Linked List](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list)|[rust](#flatten-binary-tree-to-linked-list-rust)|stack,tree,depth-first-search,linked-list,binary-tree|Medium
121|[Best Time to Buy and Sell Stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)|[rust](#best-time-to-buy-and-sell-stock-rust)|array,dynamic-programming|Easy
124|[Binary Tree Maximum Path Sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum)|[rust](#binary-tree-maximum-path-sum-rust)|tree,depth-first-search,dynamic-programming,binary-tree|Hard
128|[Longest Consecutive Sequence](https://leetcode-cn.com/problems/longest-consecutive-sequence)|[rust](#longest-consecutive-sequence-rust)|union-find,array,hash-table|Medium
136|[Single Number](https://leetcode-cn.com/problems/single-number)|[rust](#single-number-rust)|bit-manipulation,array|Easy
139|[Word Break](https://leetcode-cn.com/problems/word-break)|[rust](#word-break-rust)|trie,memoization,hash-table,string,dynamic-programming|Medium
146|[LRU Cache](https://leetcode-cn.com/problems/lru-cache)|[rust](#lru-cache-rust)|design,hash-table,linked-list,doubly-linked-list|Medium
148|[Sort List](https://leetcode-cn.com/problems/sort-list)|[rust](#sort-list-rust)|linked-list,two-pointers,divide-and-conquer,sorting,merge-sort|Medium
152|[Maximum Product Subarray](https://leetcode-cn.com/problems/maximum-product-subarray)|[rust](#maximum-product-subarray-rust)|array,dynamic-programming|Medium
155|[Min Stack](https://leetcode-cn.com/problems/min-stack)|[rust](#min-stack-rust)|stack,design|Easy
168|[Excel Sheet Column Title](https://leetcode-cn.com/problems/excel-sheet-column-title)|[rust](#excel-sheet-column-title-rust)|math,string|Easy
169|[Majority Element](https://leetcode-cn.com/problems/majority-element)|[rust](#majority-element-rust)|array,hash-table,divide-and-conquer,counting,sorting|Easy
198|[House Robber](https://leetcode-cn.com/problems/house-robber)|[rust](#house-robber-rust)|array,dynamic-programming|Medium
200|[Number of Islands](https://leetcode-cn.com/problems/number-of-islands)|[rust](#number-of-islands-rust)|depth-first-search,breadth-first-search,union-find,array,matrix|Medium
203|[Remove Linked List Elements](https://leetcode-cn.com/problems/remove-linked-list-elements)|[rust](#remove-linked-list-elements-rust)|recursion,linked-list|Easy
206|[Reverse Linked List](https://leetcode-cn.com/problems/reverse-linked-list)|[rust](#reverse-linked-list-rust)|recursion,linked-list|Easy
207|[Course Schedule](https://leetcode-cn.com/problems/course-schedule)|[rust](#course-schedule-rust)|depth-first-search,breadth-first-search,graph,topological-sort|Medium
208|[Implement Trie (Prefix Tree)](https://leetcode-cn.com/problems/implement-trie-prefix-tree)|[rust](#implement-trie-prefix-tree-rust)|design,trie,hash-table,string|Medium
215|[Kth Largest Element in an Array](https://leetcode-cn.com/problems/kth-largest-element-in-an-array)|[rust](#kth-largest-element-in-an-array-rust)|array,divide-and-conquer,quickselect,sorting,heap-priority-queue|Medium
221|[Maximal Square](https://leetcode-cn.com/problems/maximal-square)|[rust](#maximal-square-rust)|array,dynamic-programming,matrix|Medium
226|[Invert Binary Tree](https://leetcode-cn.com/problems/invert-binary-tree)|[rust](#invert-binary-tree-rust)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
234|[Palindrome Linked List](https://leetcode-cn.com/problems/palindrome-linked-list)|[rust](#palindrome-linked-list-rust)|stack,recursion,linked-list,two-pointers|Easy
236|[Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree)|[rust](#lowest-common-ancestor-of-a-binary-tree-rust)|tree,depth-first-search,binary-tree|Medium
238|[Product of Array Except Self](https://leetcode-cn.com/problems/product-of-array-except-self)|[rust](#product-of-array-except-self-rust)|array,prefix-sum|Medium
239|[Sliding Window Maximum](https://leetcode-cn.com/problems/sliding-window-maximum)|[rust](#sliding-window-maximum-rust)|queue,array,sliding-window,monotonic-queue,heap-priority-queue|Hard
240|[Search a 2D Matrix II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii)|[rust](#search-a-2d-matrix-ii-rust)|array,binary-search,divide-and-conquer,matrix|Medium
274|[H-Index](https://leetcode-cn.com/problems/h-index)|[rust](#h-index-rust)|array,counting-sort,sorting|Medium
275|[H-Index II](https://leetcode-cn.com/problems/h-index-ii)|[rust](#h-index-ii-rust)|array,binary-search|Medium
279|[Perfect Squares](https://leetcode-cn.com/problems/perfect-squares)|[rust](#perfect-squares-rust)|breadth-first-search,math,dynamic-programming|Medium
283|[Move Zeroes](https://leetcode-cn.com/problems/move-zeroes)|[rust](#move-zeroes-rust)|array,two-pointers|Easy
287|[Find the Duplicate Number](https://leetcode-cn.com/problems/find-the-duplicate-number)|[rust](#find-the-duplicate-number-rust)|bit-manipulation,array,two-pointers,binary-search|Medium
297|[Serialize and Deserialize Binary Tree](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree)|[rust](#serialize-and-deserialize-binary-tree-rust)|tree,depth-first-search,breadth-first-search,design,string,binary-tree|Hard
300|[Longest Increasing Subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence)|[rust](#longest-increasing-subsequence-rust)|array,binary-search,dynamic-programming|Medium
301|[Remove Invalid Parentheses](https://leetcode-cn.com/problems/remove-invalid-parentheses)|[rust](#remove-invalid-parentheses-rust)|breadth-first-search,string,backtracking|Hard
309|[Best Time to Buy and Sell Stock with Cooldown](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)|[rust](#best-time-to-buy-and-sell-stock-with-cooldown-rust)|array,dynamic-programming|Medium
312|[Burst Balloons](https://leetcode-cn.com/problems/burst-balloons)|[rust](#burst-balloons-rust)|array,dynamic-programming|Hard
316|[Remove Duplicate Letters](https://leetcode-cn.com/problems/remove-duplicate-letters)|[rust](#remove-duplicate-letters-rust)|stack,greedy,string,monotonic-stack|Medium
322|[Coin Change](https://leetcode-cn.com/problems/coin-change)|[rust](#coin-change-rust)|breadth-first-search,array,dynamic-programming|Medium
337|[House Robber III](https://leetcode-cn.com/problems/house-robber-iii)|[rust](#house-robber-iii-rust)|tree,depth-first-search,dynamic-programming,binary-tree|Medium
338|[Counting Bits](https://leetcode-cn.com/problems/counting-bits)|[rust](#counting-bits-rust)|bit-manipulation,dynamic-programming|Easy
347|[Top K Frequent Elements](https://leetcode-cn.com/problems/top-k-frequent-elements)|[rust](#top-k-frequent-elements-rust)|array,hash-table,divide-and-conquer,bucket-sort,counting,quickselect,sorting,heap-priority-queue|Medium
394|[Decode String](https://leetcode-cn.com/problems/decode-string)|[rust](#decode-string-rust)|stack,recursion,string|Medium
399|[Evaluate Division](https://leetcode-cn.com/problems/evaluate-division)|[rust](#evaluate-division-rust)|depth-first-search,breadth-first-search,union-find,graph,array,shortest-path|Medium
406|[Queue Reconstruction by Height](https://leetcode-cn.com/problems/queue-reconstruction-by-height)|[rust](#queue-reconstruction-by-height-rust)|greedy,array,sorting|Medium
416|[Partition Equal Subset Sum](https://leetcode-cn.com/problems/partition-equal-subset-sum)|[rust](#partition-equal-subset-sum-rust)|array,dynamic-programming|Medium
437|[Path Sum III](https://leetcode-cn.com/problems/path-sum-iii)|[rust](#path-sum-iii-rust)|tree,depth-first-search,binary-tree|Medium
438|[Find All Anagrams in a String](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string)|[rust](#find-all-anagrams-in-a-string-rust)|hash-table,string,sliding-window|Medium
448|[Find All Numbers Disappeared in an Array](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array)|[rust](#find-all-numbers-disappeared-in-an-array-rust)|array,hash-table|Easy
451|[Sort Characters By Frequency](https://leetcode-cn.com/problems/sort-characters-by-frequency)|[rust](#sort-characters-by-frequency-rust)|hash-table,string,bucket-sort,counting,sorting,heap-priority-queue|Medium
461|[Hamming Distance](https://leetcode-cn.com/problems/hamming-distance)|[rust](#hamming-distance-rust)|bit-manipulation|Easy
494|[Target Sum](https://leetcode-cn.com/problems/target-sum)|[rust](#target-sum-rust)|array,dynamic-programming,backtracking|Medium
538|[Convert BST to Greater Tree](https://leetcode-cn.com/problems/convert-bst-to-greater-tree)|[rust](#convert-bst-to-greater-tree-rust)|tree,depth-first-search,binary-search-tree,binary-tree|Medium
543|[Diameter of Binary Tree](https://leetcode-cn.com/problems/diameter-of-binary-tree)|[rust](#diameter-of-binary-tree-rust)|tree,depth-first-search,binary-tree|Easy
560|[Subarray Sum Equals K](https://leetcode-cn.com/problems/subarray-sum-equals-k)|[rust](#subarray-sum-equals-k-rust)|array,hash-table,prefix-sum|Medium
581|[Shortest Unsorted Continuous Subarray](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray)|[rust](#shortest-unsorted-continuous-subarray-rust)|stack,greedy,array,two-pointers,sorting,monotonic-stack|Medium
617|[Merge Two Binary Trees](https://leetcode-cn.com/problems/merge-two-binary-trees)|[rust](#merge-two-binary-trees-rust)|tree,depth-first-search,breadth-first-search,binary-tree|Easy
621|[Task Scheduler](https://leetcode-cn.com/problems/task-scheduler)|[rust](#task-scheduler-rust)|greedy,array,hash-table,counting,sorting,heap-priority-queue|Medium
645|[Set Mismatch](https://leetcode-cn.com/problems/set-mismatch)|[rust](#set-mismatch-rust)|bit-manipulation,array,hash-table,sorting|Easy
647|[Palindromic Substrings](https://leetcode-cn.com/problems/palindromic-substrings)|[rust](#palindromic-substrings-rust)|string,dynamic-programming|Medium
726|[Number of Atoms](https://leetcode-cn.com/problems/number-of-atoms)|[rust](#number-of-atoms-rust)|stack,hash-table,string|Hard
739|[Daily Temperatures](https://leetcode-cn.com/problems/daily-temperatures)|[rust](#daily-temperatures-rust)|stack,array,monotonic-stack|Medium
930|[Binary Subarrays With Sum](https://leetcode-cn.com/problems/binary-subarrays-with-sum)|[rust](#binary-subarrays-with-sum-rust)|array,hash-table,prefix-sum,sliding-window|Medium
981|[Time Based Key-Value Store](https://leetcode-cn.com/problems/time-based-key-value-store)|[rust](#time-based-key-value-store-rust)|design,hash-table,string,binary-search|Medium
1418|[Display Table of Food Orders in a Restaurant](https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant)|[rust](#display-table-of-food-orders-in-a-restaurant-rust)|array,hash-table,string,ordered-set,sorting|Medium
1711|[Count Good Meals](https://leetcode-cn.com/problems/count-good-meals)|[rust](#count-good-meals-rust)|array,hash-table|Medium
1818|[Minimum Absolute Sum Difference](https://leetcode-cn.com/problems/minimum-absolute-sum-difference)|[rust](#minimum-absolute-sum-difference-rust)|greedy,array,binary-search,ordered-set|Medium
1833|[Maximum Ice Cream Bars](https://leetcode-cn.com/problems/maximum-ice-cream-bars)|[rust](#maximum-ice-cream-bars-rust)|greedy,array,sorting|Medium
1838|[Frequency of the Most Frequent Element](https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element)|[rust](#frequency-of-the-most-frequent-element-rust)|array,binary-search,prefix-sum,sliding-window|Medium
1846|[Maximum Element After Decreasing and Rearranging](https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging)|[rust](#maximum-element-after-decreasing-and-rearranging-rust)|greedy,array,sorting|Medium
1877|[Minimize Maximum Pair Sum in Array](https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array)|[rust](#minimize-maximum-pair-sum-in-array-rust)|greedy,array,two-pointers,sorting|Medium
LCP 07|[传递信息](https://leetcode-cn.com/problems/chuan-di-xin-xi)|[rust](#chuan-di-xin-xi-rust)|depth-first-search,breadth-first-search,graph,dynamic-programming|Easy
剑指 Offer 42|[连续子数组的最大和  LCOF](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof)|[rust](#lian-xu-zi-shu-zu-de-zui-da-he-lcof-rust)|array,divide-and-conquer,dynamic-programming|Easy
剑指 Offer 52|[两个链表的第一个公共节点  LCOF](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof)|[python3](#liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof-python3)|hash-table,linked-list,two-pointers|Easy
剑指 Offer 53 - I|[在排序数组中查找数字  LCOF](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof)|[rust](#zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof-rust)|array,binary-search|Easy
面试题 10.02|[Group Anagrams LCCI](https://leetcode-cn.com/problems/group-anagrams-lcci)|[rust](#group-anagrams-lcci-rust)|hash-table,string,sorting|Medium
面试题 17.10|[Find Majority Element LCCI](https://leetcode-cn.com/problems/find-majority-element-lcci)|[rust](#find-majority-element-lcci-rust)|array,counting|Easy
### two sum rust

> submit time: Tue Jun 29 07:21:52 UTC 2021

```rust
impl Solution {


    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
        let mut index: Vec<usize> = (0..nums.len() as usize).collect();
        // let nums = &nums;
        index.sort_by(|a, b| nums[*a].cmp(&nums[*b]));

        let mut left = 0;
        let mut right = nums.len() - 1;
        while left < right {
            let a = nums[index[left]] + nums[index[right]];
            match a.cmp(&target) {
                std::cmp::Ordering::Less => left += 1,
                std::cmp::Ordering::Greater => right -= 1,
                std::cmp::Ordering::Equal => return vec![index[left] as i32, index[right] as i32]
            }
        }
        return vec![-1, -1];
    }

}
```

### add two numbers rust

> submit time: Thu Jul 01 06:16:05 UTC 2021

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {

    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut ans = Some(Box::new(ListNode::new(-1)));
        let mut last = &mut ans;
        let mut l1 = &l1;
        let mut l2 = &l2;

        let mut p = 0;
        while l1.is_some() || l2.is_some() || p > 0 {
            let mut tmp = p;
            if let Some(n) = l1 {
                tmp += n.val;
                l1 = &n.next;
            }
            if let Some(n) = l2 {
                tmp += n.val;
                l2 = &n.next;
            }
            p = tmp / 10;
            tmp %= 10;
            last.as_mut()?.next = Some(Box::new(ListNode::new(tmp)));
            last = &mut last.as_mut()?.next;
        }
        ans?.next
    }


}
```

### longest substring without repeating characters rust

> submit time: Sat Jul 03 03:08:16 UTC 2021

```rust
impl Solution {

    pub fn length_of_longest_substring(s: String) -> i32 {
        let mut pos = std::collections::HashMap::new();
        let mut ans = 0;
        let mut lst_pos = -1i32;

        for (idx, c) in s.chars().enumerate() {
            if let Some(&last) = pos.get(&c) {
                lst_pos = lst_pos.max(last);
            }
            ans = ans.max(idx as i32 - lst_pos);
            pos.insert(c, idx as i32);
        }
        ans
    }
}
```

### median of two sorted arrays rust

> submit time: Mon Jul 05 07:00:17 UTC 2021

```rust
impl Solution {

    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {
        fn find_k(nums1: &Vec<i32>, nums2: &Vec<i32>, kk: usize) -> i32 {
            let mut k = kk;
            let mut index1 = 0usize;
            let mut index2 = 0usize;
            loop {
                
                if index1 == nums1.len() {
                    return nums2[kk - index1 - 1];
                }
                if index2 == nums2.len() {
                    return nums1[kk - index2 - 1];
                }
                if k == 1 {
                    return std::cmp::min(nums1[index1], nums2[index2]);
                }

                let half = k >> 1;
                let n_index1 = std::cmp::min(half + index1, nums1.len()) - 1;
                let n_index2 = std::cmp::min(half + index2, nums2.len()) - 1;

                if nums1[n_index1] < nums2[n_index2] {
                    k -= n_index1 + 1 - index1;
                    index1 = n_index1 + 1;
                } else {
                    k -= n_index2 + 1 - index2;
                    index2 = n_index2 + 1;
                }
            }
        }
        let size = nums1.len() + nums2.len();
        if size & 1 > 0 {
            find_k(&nums1, &nums2, (size >> 1) + 1) as f64
        } else {
            (find_k(&nums1, &nums2, size >> 1) + find_k(&nums1, &nums2, (size >> 1) + 1)) as f64 / 2f64
        }

    }
}
```

### longest palindromic substring rust

> submit time: Mon Jul 05 07:42:09 UTC 2021

```rust
impl Solution {


    pub fn longest_palindrome(s: String) -> String {
        let mut dp = vec![vec![false; s.len()]; s.len()];
        let bytes = s.as_bytes();
        let mut ans = s[0..1].to_string();
        for i in 0..s.len() {
            for j in i..s.len() {
                if i == 0 {
                    dp[j][j] = true;
                }else if i == 1 {
                    dp[j - i][j] = bytes[j - i] == bytes[j];
                }else{
                    dp[j - i][j] = dp[j - i + 1][j - 1] && bytes[j - i] == bytes[j];
                }
                if dp[j - i][j] && i + 1 > ans.len() {
                    ans = s[j-i..j+1].to_string();
                }
            }
        }
        ans
    }

}
```

### regular expression matching rust

> submit time: Mon Jul 12 08:48:48 UTC 2021

```rust
impl Solution {

    pub fn is_match(s: String, p: String) -> bool {
        let m = s.len();
        let n = p.len();
        let mut dp = vec![vec![false; n + 1]; m + 1];
        dp[0][0] = true;

        for i in 0..=m {
            for j in 1..=n {
                if p.as_bytes()[j - 1] == b'*' {
                    dp[i][j] = dp[i][j - 2];
                    if i > 0 && (s.as_bytes()[i - 1] == p.as_bytes()[j - 2] || p.as_bytes()[j - 2] == b'.') {
                        dp[i][j] = dp[i][j] || dp[i - 1][j];
                    }
                } else {
                    if i > 0 {
                        dp[i][j] = dp[i - 1][j - 1] && (s.as_bytes()[i - 1] == p.as_bytes()[j - 1] || p.as_bytes()[j - 1] == b'.');
                    }
                }
            }
        }

        dp[m][n]
    }
}
```

### container with most water rust

> submit time: Wed Jul 07 02:09:39 UTC 2021

```rust
impl Solution {
    pub fn max_area(height: Vec<i32>) -> i32 {
        let mut left = 0;
        let mut right = height.len() - 1;
        let mut ans = 0;
        while left < right {
            ans = ans.max((right - left) as i32 * height[left].min(height[right]));
            if height[right] > height[left] {
                left += 1;
            } else {
                right -= 1;
            }
        }
        ans
    }

}
```

### 3sum rust

> submit time: Tue Jul 06 06:30:04 UTC 2021

```rust
impl Solution {
    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut ans = vec![];
        let mut nums = nums;

        if nums.len() < 3 {
            return ans;
        }
        nums.sort();
        for i in 0..nums.len()-2 {
            if i > 0 && nums[i] == nums[i - 1] {
                continue;
            }
            if nums[i] + nums[nums.len() - 1] + nums[nums.len() - 2] < 0 {
                continue;
            }
            if nums[i] + nums[i + 1] + nums[i + 2] > 0 {
                break;
            }
            let first = -nums[i];
            let (mut left, mut right) = (i + 1, nums.len() - 1);
            while left < right {
                if left > i + 1 && nums[left] == nums[left - 1] {
                    left += 1;
                    continue;
                }
                let a = nums[left] + nums[right];
                match a.cmp(&first) {
                    std::cmp::Ordering::Greater => right -= 1,
                    std::cmp::Ordering::Less => left += 1,
                    _ => {
                        ans.push(vec![nums[i], nums[left], nums[right]]);
                        right -= 1;
                        left += 1;
                    }
                }
            }
        }

        ans
    }
}
```

### letter combinations of a phone number rust

> submit time: Tue Jul 06 06:52:36 UTC 2021

```rust
impl Solution {

    pub fn letter_combinations(digits: String) -> Vec<String> {
        let dict = vec![vec![],
            vec![], vec!["a", "b", "c"], vec!["d", "e", "f"],
            vec!["g", "h", "i"], vec!["j", "k", "l"], vec!["m", "n", "o"], 
            vec!["p", "q", "r", "s"], vec!["t", "u", "v"],vec!["w", "x", "y", "z"], 
        ];

        let mut ans: Vec<String> = vec![];
        let nums: Vec<usize>= digits.as_bytes().iter().map(|&i| (i - b'0') as usize).collect();
        for d in nums {
            let n = &dict[d];
            if ans.is_empty() {
                let mut a: Vec<String> = n.iter().map(|&x|x.to_string()).collect();
                ans.append(&mut a);
            } else {
                let len = ans.len();
                for i in 0..len {
                    let mut c = ans[i].clone();
                    ans[i] += n[0];
                    for j in 1..n.len() {
                        ans.push(c.clone() + n[j]);
                    }
                }
            }
        }

        ans
    }
}
```

### remove nth node from end of list rust

> submit time: Thu Jul 01 08:13:29 UTC 2021

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {
        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));

        let mut cnt = 0;

        let mut cur = &mut dummy;

        while let Some(_) = cur {
            cnt += 1;
            cur = &mut cur.as_mut()?.next;
        }

        cur = &mut dummy;

        for _ in 0..cnt-n-1 {
            cur = &mut cur.as_mut()?.next;
        }
        
        cur.as_mut()?.next = cur.as_mut()?.next.as_mut()?.next.take();

        dummy?.next
    }
}
```

### valid parentheses rust

> submit time: Fri Jul 02 05:57:32 UTC 2021

```rust
impl Solution {

    pub fn is_valid(s: String) -> bool {
        if s.len() & 1 > 0 {
            return false;
        }
        let mut v: Vec<u8> = vec![];
        for i in s.bytes() {
            match i {
                b'(' | b'[' | b'{' => v.push(i),
                _ => {
                    if let Some(b) = v.pop() {
                        match (b, i) {
                            (b'[', b']') | (b'(', b')') | (b'{', b'}') => continue,
                            _ => return false,
                        }
                    }else{
                        return false;
                    }
                }
            };
        }

        v.len() == 0
    }
}
```

### merge two sorted lists rust

> submit time: Wed Jun 30 06:03:08 UTC 2021

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn merge_two_lists(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut dummy = Some(Box::new(ListNode::new(-1)));
        let mut cur = &mut dummy;
        let mut l1 = l1;
        let mut l2 = l2;
        while l1.is_some() || l2.is_some() {
            if l2.is_none() {
                cur.as_mut().unwrap().next = l1;
                break;
            }else if l1.is_none(){
                cur.as_mut().unwrap().next = l2;
                break;
            }
            if l1.as_ref().unwrap().val < l2.as_ref().unwrap().val {
                let next = l1.as_mut().unwrap().next.take();
                cur.as_mut().unwrap().next = l1.take();
                l1 = next;
                cur = &mut cur.as_mut().unwrap().next;
            }else {
                let next = l2.as_mut().unwrap().next.take();
                cur.as_mut().unwrap().next = l2.take();
                l2 = next;
                cur = &mut cur.as_mut().unwrap().next;
            }
            

        }

        dummy.unwrap().next.take()
    }
}
```

### generate parentheses rust

> submit time: Sun Jul 11 02:41:45 UTC 2021

```rust
impl Solution {

    pub fn generate_parenthesis(n: i32) -> Vec<String> {
        fn dfs(st:&mut String, open: i32, close: i32, max: i32, ans: &mut Vec<String>){
            if st.len() == max as usize * 2 {
                ans.push(st.clone());
                return;
            }
            if open < max {
                st.push('(');
                dfs(st, open + 1, close, max, ans);
                st.remove(st.len() - 1);
            }
            if close < open {
                st.push(')');
                dfs(st, open, close + 1, max, ans);
                st.remove(st.len() - 1);
            }

        }
        let mut st = String::new();
        let mut ans = vec![];
        dfs(&mut st, 0, 0, n, &mut ans);
        ans
    }
}
```

### merge k sorted lists rust

> submit time: Thu Jul 15 07:33:10 UTC 2021

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {

    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {
        let mut m = std::collections::BinaryHeap::new();
        let n = lists.len();
        let mut lists = lists;
        for i in 0..n {
            if let Some(mut x) = lists[i].take() {
                m.push(std::cmp::Reverse((x.val, i)));
                lists[i] = x.next.take();
            }
        }
        let mut dummy = Box::new(ListNode::new(-1));
        let mut cur = &mut dummy;
        while !m.is_empty() {
            if let Some(std::cmp::Reverse((x, idx))) = m.pop() {
                cur.next = Some(Box::new(ListNode::new(x)));
                cur = cur.next.as_mut().unwrap();
                if let Some(mut x) = lists[idx].take() {
                    m.push(std::cmp::Reverse((x.val, idx)));
                    lists[idx] = x.next.take();
                }
            }
        }
        dummy.next
    }

}
```

### swap nodes in pairs rust

> submit time: Thu Jul 01 10:20:09 UTC 2021

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));

        let mut cur = &mut dummy;
        while cur.as_ref()?.next.is_some(){
            if cur.as_ref()?.next.as_ref()?.next.is_some() {
                let mut tmp = cur.as_mut()?.next.as_mut()?.next.take();
                cur.as_mut()?.next.as_mut()?.next = tmp.as_mut()?.next.take();
                tmp.as_mut()?.next = cur.as_mut()?.next.take();
                cur.as_mut()?.next = tmp;
                cur = &mut cur.as_mut()?.next.as_mut()?.next;
            }else{
                break;
            }
        }

        return dummy?.next;
    }
}
```

### remove duplicates from sorted array rust

> submit time: Tue Jun 29 08:14:15 UTC 2021

```rust
impl Solution {


    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {
        if nums.len() <= 0 {
            return 0;
        }
        let mut index = 1;
        for i in 1..nums.len() {
            if nums[i] != nums[i - 1] {
                nums[index] = nums[i];
                index += 1;
            }
        }
        index as i32
    }
}
```

### remove element rust

> submit time: Tue Jun 29 08:29:53 UTC 2021

```rust
impl Solution {


    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {
        let mut index = 0;
        for i in 0..nums.len() {
            if nums[i] != val {
                nums[index] = nums[i];
                index += 1;
            }
        }
        index as i32
    }
}
```

### next permutation rust

> submit time: Tue Jul 06 08:12:47 UTC 2021

```rust
impl Solution {
    
    pub fn next_permutation(nums: &mut Vec<i32>) {
        let len = nums.len();
        let mut i = len;
        for j in (1..len).rev() {
            if nums[j] > nums[j - 1] {
                i = j - 1;
                break;
            }
        }
        if i == len {
            nums.reverse();
            return;
        }
        let mut p = nums.len() - 1;
        while p > i && nums[p] <= nums[i] {
            p -= 1;
        }
        nums.swap(i, p);
        (&mut nums[i+1..len]).reverse();

    }

}
```

### longest valid parentheses rust

> submit time: Mon Jul 12 08:03:00 UTC 2021

```rust
impl Solution {
    
    pub fn longest_valid_parentheses(s: String) -> i32 {
        let n = s.len() as i32;
        let mut ans = 0;
        let mut dp =  vec![0; n as usize];
        for i in 1..n {
            if s.as_bytes()[i as usize] == b')' {
                if s.as_bytes()[i as usize - 1] == b'(' {
                    dp[i as usize] = 2 + if i >= 2 {dp[i as usize - 2]} else {0};
                } else {
                    if i - dp[i as usize - 1] - 1 >= 0 && s.as_bytes()[(i - dp[i as usize - 1] - 1) as usize] == b'(' {
                        dp[i as usize] = dp[i as usize - 1] + 2 + if i - dp[i as usize - 1] - 2 >= 0 {dp[(i - dp[i as usize - 1] - 2) as usize]} else {0};
                    }
                }
                ans = ans.max(dp[i as usize]);
            }
        }
        ans
    }

}
```

### search in rotated sorted array rust

> submit time: Thu Jul 15 08:24:17 UTC 2021

```rust
impl Solution {

    pub fn search(nums: Vec<i32>, target: i32) -> i32 {
        let n = nums.len() as i32;
        let mut left = 0i32;
        let mut right = n - 1;

        while left <= right {
            let mid = left + (right - left) / 2;
            let (lv, rv, mv) = (nums[left as usize], nums[right as usize], nums[mid as usize]);
            if lv <= rv {
                match mv.cmp(&target) {
                    std::cmp::Ordering::Less => left = mid + 1,
                    std::cmp::Ordering::Greater => right = mid - 1,
                    _ => return mid,
                }
            } else {
                if right - left < 3 {
                    let a: Vec<&i32>= nums[left as usize..=right as usize].iter().collect();
                    match a.iter().enumerate().filter(|&(_, &&x)| x == target).next() {
                        Some((i, _)) => return i as i32 + left,
                        _ => return -1,
                    }
                }
                if (mv < rv && (target < mv || target >= lv))
                 || (mv > rv && target >= lv && target < mv) {
                    right = mid - 1;
                } else {
                    left = mid;
                }
            }
        }
        -1
    }
}
```

### find first and last position of element in sorted array rust

> submit time: Thu Jul 15 08:47:38 UTC 2021

```rust
impl Solution {

    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {
        let a: i32 = match nums.binary_search(&target) {
            Ok(n) => n as i32,
            _ => -1,
        };
        if a < 0 {
            return vec![-1, -1];
        }
        let mut ans = vec![];
        {
            let mut left = 0;
            let mut right = a;
            while left <= right {
                let mid = left + (right - left) / 2;
                if nums[mid as usize] == target {
                    right = mid - 1;
                }else{
                    left = mid + 1;
                }
            }
            ans.push(left);
        }
        {
            let mut left = a;
            let mut right = nums.len() as i32 - 1;
            while left <= right {
                let mid = left + (right - left) / 2;
                if nums[mid as usize] == target {
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }
            ans.push(right);
        }

        ans
    }
}
```

### search insert position rust

> submit time: Tue Jun 29 08:59:18 UTC 2021

```rust
impl Solution {

    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {
        let mut left: i32 = 0;
        let mut right= (nums.len() - 1) as i32;
        while left <= right {
            let mut mid = left + ((right - left) >> 1);
            match nums[mid as usize].cmp(&target) {
                std::cmp::Ordering::Greater => right = mid - 1,
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Equal => {
                    while mid >= 0 && nums[mid as usize] == target {
                        mid -= 1;
                    }
                    return mid + 1;
                },
            }
        }
        left as i32
    }

}
```

### combination sum rust

> submit time: Tue Jul 06 08:27:23 UTC 2021

```rust
impl Solution {

    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        fn dfs(cs: & Vec<i32>, target: i32, from: usize, cur: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {
            if target < 0 || from >= cs.len() {
                return;
            } else if target == 0{
                ans.push(cur.clone());
                return;
            }
            dfs(cs, target, from + 1, cur, ans);
            cur.push(cs[from]);
            dfs(cs, target - cs[from], from, cur, ans);
            cur.remove(cur.len() - 1);
        }
        let mut ans = vec![];
        dfs(&candidates, target, 0, &mut vec![], &mut ans);
        ans
    }
}
```

### trapping rain water rust

> submit time: Tue Jul 06 14:26:43 UTC 2021

```rust
impl Solution {

    pub fn trap(height: Vec<i32>) -> i32 {
        let n = height.len();
        let mut q = vec![];
        let mut ans = 0;
        for i in 0..n {
            if q.is_empty() {
                q.push(i);
                continue;
            }
            if height[*q.last().unwrap() as usize] <= height[i] {
                let last = q.pop().unwrap();
                for j in last+1..i {
                    ans += height[last] - height[j];
                }
                q.push(i);
            }
        }
        if let Some(end) = q.pop() {
            for i in (end..n).rev() {
                if q.is_empty() {
                    q.push(i);
                    continue;
                }
                if height[*q.last().unwrap() as usize] <= height[i] {
                    let last = q.pop().unwrap();
                    for j in i+1..last {
                        ans += height[last] - height[j];
                    }
                    q.push(i);
                }
            }
        }

        ans

    }

}
```

### permutations rust

> submit time: Thu Jul 15 02:30:34 UTC 2021

```rust
impl Solution {

    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {
        fn dfs(nums: &mut Vec<i32>, cur: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>, vist: &mut Vec<bool>) {
            if cur.len() == nums.len() {
                ans.push(cur.clone());
                return;
            }
            for i in 0..nums.len() {
                if !vist[i] {
                    vist[i] = true;
                    cur.push(nums[i]);
                    dfs(nums, cur, ans, vist);
                    cur.remove(cur.len() - 1);
                    vist[i] = false;
                }
            }
        }
        let n = nums.len();
        let mut nums = nums;
        let mut ans = vec![];
        dfs(&mut nums, &mut vec![], &mut ans, &mut vec![false; n]);
        ans
    }
}
```

### rotate image rust

> submit time: Tue Jul 13 12:48:38 UTC 2021

```rust
impl Solution {
    
    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {
        let n = matrix.len();
        let n1 = n - 1;
        for i in 0..n/2 {
            for j in 0..(n+1)/2 {
                let (a, b, c, d) = (matrix[i][j], matrix[j][n1-i], matrix[n1-i][n1-j], matrix[n1-j][i]);
                matrix[i][j] = d;
                matrix[j][n1-i] = a;
                matrix[n1-i][n1-j] = b;
                matrix[n1-j][i] = c;
            }
        }
    }
}
```

### group anagrams rust

> submit time: Thu Jul 15 09:54:43 UTC 2021

```rust
use std::iter::FromIterator;
impl Solution {
    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {
        let mut map: std::collections::HashMap<String, usize>= std::collections::HashMap::new();
        let mut ans = vec![];
        for st in strs {
            let mut a: Vec<char> = st.chars().collect();
            a.sort_unstable();
            let a = String::from_iter(a.iter());
            let i = *map.entry(a).or_insert_with(|| {
                ans.push(vec![]);
                ans.len() - 1
            });
            ans[i].push(st);
        }
        ans
    }
}
```

### maximum subarray rust

> submit time: Fri Jul 02 06:07:12 UTC 2021

```rust
impl Solution {

    pub fn max_sub_array(nums: Vec<i32>) -> i32 {
        let mut ans = nums[0];
        let mut ret = ans;
        for idx in 1..nums.len() {
            let i = nums[idx];
            if ans + i < i {
                ans = i;
            } else {
                ans += i;
            }
            ret = std::cmp::max(ans, ret);
        }
        ret
    }


}
```

### jump game rust

> submit time: Tue Jul 06 09:16:34 UTC 2021

```rust
impl Solution {

    pub fn can_jump(nums: Vec<i32>) -> bool {
        let mut end = nums[0] as usize;
        let mut dep = nums[0] as usize;

        let mut i = 0;
        while i <= end as usize {
            if i == end {
                dep = dep.min(nums.len() - 1);
                end = dep + nums[dep] as usize;
            }
            dep = dep.max(i + nums[i] as usize);
            if dep >= nums.len() - 1 {
                return true;
            }
            i += 1;
        }

        false
    }

}
```

### merge intervals rust

> submit time: Mon Jul 12 15:20:26 UTC 2021

```rust
impl Solution {
    pub fn merge(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut t = intervals;
        t.sort_unstable_by(|a, b| a[0].cmp(&b[0]).then(a[1].cmp(&b[1])));
        let mut ans = vec![];
        let mut last_max = 0;
        for i in &t {
            if ans.is_empty() {
                ans.push(i.clone());
                last_max = ans[0][1];
            }else {

                let tmp = last_max.max(i[1]);
                if i[0] > last_max {
                    ans.push(i.clone());
                } else {
                    ans.last_mut().unwrap()[1] = tmp;
                }
                last_max = tmp;
            }
        }
        ans
    }
}
```

### unique paths rust

> submit time: Thu Jul 08 13:37:23 UTC 2021

```rust
impl Solution {
    pub fn unique_paths(m: i32, n: i32) -> i32 {
        let mut c = m + n - 2;
        let mut a = m.min(n) - 1;

        let mut ans = 1i64;
        let mut down = 1;
        while down <= a {
            ans = ans * c as i64 / down as i64;
            c -= 1;
            down += 1;
        }
        ans as i32
    }
}
```

### minimum path sum rust

> submit time: Fri Jul 09 08:10:41 UTC 2021

```rust
impl Solution {

pub fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 {
    let mut grid = grid;
    let m = grid.len();
    let n = grid[0].len();
    for i in 0..m {
        for j in 0..n {
            let mut c = 0;
            if i > 0 {
                if c == 0 {c = grid[i - 1][j]} else {c = c.min(grid[i - 1][j]);}
            }
            if j > 0 {
                if c == 0 {c = grid[i][j - 1]} else {c = c.min(grid[i][j - 1]);}
            }
            grid[i][j] += c;
        }
    }
    grid[m - 1][n - 1]
}
}
```

### plus one rust

> submit time: Tue Jun 29 09:27:32 UTC 2021

```rust
impl Solution {

    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {
        let mut ds = digits;
        let mut p = 1;

        for i in (0..ds.len()).rev() {
            ds[i] += p;
            if ds[i] > 9 {
                ds[i] = 0;
            }else {
                p = 0;
                break;
            }
        }

        if p > 0 {
            ds.insert(0, p);    
        }

        ds
    }

}
```

### climbing stairs rust

> submit time: Fri Jul 02 06:14:08 UTC 2021

```rust
impl Solution {
    pub fn climb_stairs(n: i32) -> i32 {
        let mut v = vec![1, 1];
        for i in 2..=n as usize {
            v.push(v[i - 1] + v[i - 2]);
        }
        return v[n as usize];
    }
}
```

### edit distance rust

> submit time: Mon Jul 12 07:36:52 UTC 2021

```rust
impl Solution {
    pub fn min_distance(word1: String, word2: String) -> i32 {
        let m = word1.len();
        let n = word2.len();
        let mut dp = vec![vec![0; n + 1]; m + 1];
        for i in 1..=n {
            dp[0][i] = i;
        }
        for i in 1..=m {
            dp[i][0] = i;
        }

        for i in 1..=m {
            for j in 1..=n {
                if word1.as_bytes()[i - 1] == word2.as_bytes()[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + dp[i - 1][j - 1].min(dp[i][j - 1]).min(dp[i - 1][j]);
                }
            }
        }
        dp[m][n]as i32
    }

}
```

### sort colors rust

> submit time: Tue Jul 06 09:40:48 UTC 2021

```rust
impl Solution {

    pub fn sort_colors(nums: &mut Vec<i32>) {
        let mut cnts = [0usize; 3];
        for i in nums.iter() {
            cnts[*i as usize] += 1;
        }
        let mut i = 0;
        for (c, num) in cnts.iter().enumerate() {
            let mut num = *num;
            while num > 0 {
                nums[i] = c as i32;
                num -= 1;
                i += 1;
            }
        }
    }
}
```

### minimum window substring rust

> submit time: Thu Jul 15 05:57:29 UTC 2021

```rust
impl Solution {

    pub fn min_window(s: String, t: String) -> String {
        let mut map  = std::collections::HashMap::new();
        for i in t.as_bytes() {
            *map.entry(*i).or_insert(0) += 1;
        }
        let mut left = 0;
        let mut right = 0;
        let mut ans = s.len() + 1;
        let mut start = 0;
        
        let mut cnts: std::collections::HashMap<u8, i32> = std::collections::HashMap::new();
        let mut clen = map.len();
        while right < s.len() {
            let k = s.as_bytes()[right];
            if let Some(a) = map.get(&k) {
                let b = cnts.entry(k).or_insert(0);
                *b += 1;
                if b == a {
                    clen -= 1;
                }
            }
            while clen == 0 {
                let k = s.as_bytes()[left];
                left += 1;
                if let Some(&a) = map.get(&k) {
                    let b = cnts.entry(k).or_insert(0);
                    *b -= 1;
                    if *b < a {
                        clen += 1;
                        let len = right + 2 - left;
                        if len < ans {
                            ans = len;
                            start = left - 1;
                        }
                        break;
                    }
                }
            }
            right += 1;
        }

        if ans > s.len() {String::new()}else {s[start..start + ans].to_string()}
    }
}
```

### subsets rust

> submit time: Thu Jul 08 13:48:23 UTC 2021

```rust
impl Solution {

    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut ans = Vec::with_capacity(2usize.pow(nums.len() as u32));

        ans.push(vec![]);

        for i in nums {
            let l = ans.len();
            for j in 0..l {
                let mut c = ans[j].clone();
                c.push(i);
                ans.push(c);
            }
        }
        ans

    }
}
```

### word search rust

> submit time: Tue Jul 13 13:13:04 UTC 2021

```rust
impl Solution {

    pub fn exist(board: Vec<Vec<char>>, word: String) -> bool {
        fn dfs(board: &Vec<Vec<char>>, flags: &mut Vec<Vec<bool>>, word: &String, cur: (usize, usize), idx: usize) -> bool {
            if board[cur.0][cur.1] != word.as_bytes()[idx] as char {
                return false;
            }
            if word.len() - 1 == idx {
                return true;
            }
            flags[cur.0][cur.1] = true;
            for (x, y) in [(-1, 0), (1, 0), (0, -1), (0, 1)].iter() {
                let (xx, yy) = (cur.0 as i32 + x, cur.1 as i32 + y);
                if xx < 0 || yy < 0 || xx >= board.len() as i32 || yy >= board[0].len() as i32 || flags[xx as usize][yy as usize]{
                    continue;
                }
                if dfs(board, flags, word, (xx as usize, yy as usize), idx + 1) {
                    return true;
                }
            }
            flags[cur.0][cur.1] = false;
            false
        }
        let mut flags = vec![vec![false; board[0].len()]; board.len()];
        for i in 0..board.len() {
            for j in 0..board[0].len() {
                if dfs(&board, &mut flags, &word, (i, j), 0) {
                    return true;
                }
            }
        }
        false
    }
}
```

### largest rectangle in histogram rust

> submit time: Tue Jul 06 15:23:13 UTC 2021

```rust
impl Solution {

    pub fn largest_rectangle_area(heights: Vec<i32>) -> i32 {
        let mut ans = 0;
        let mut heights = heights;
        heights.push(0);
        let mut q: Vec<i32> = vec![];
        for i in 0..heights.len() {
            while !q.is_empty() && heights[*q.last().unwrap() as usize] > heights[i] {
                let last = q.pop().unwrap() as usize;
                let l: i32 = *q.last().unwrap_or(&-1);
                ans = ans.max((i as i32 - l - 1) * heights[last]);

            }
            q.push(i as i32);
        }

        ans
    }
}
```

### maximal rectangle rust

> submit time: Tue Jul 06 14:46:26 UTC 2021

```rust
impl Solution {

    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {
        let m = matrix.len();
        if m == 0 {
            return 0;
        }
        let n = matrix[0].len();
        let mut dp = vec![vec![0; n + 1]; m + 1];
        let mut ans = 0;

        for r in 1..=m {
            for c in 1..=n {
                if matrix[r - 1][c - 1] == '1' {
                    dp[r][c] = dp[r][c - 1] + 1;
                    let mut w = dp[r][c];
                    let mut h = 1;
                    while h <= r {
                        w = w.min(dp[r - h + 1][c]);
                        if w == 0 {
                            break;
                        }
                        ans = ans.max(w * h);
                        h += 1;
                    }
                }
            }
        }

        ans as i32
    }

}
```

### binary tree inorder traversal rust

> submit time: Fri Jul 02 06:28:09 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {
        let mut ans: Vec<i32> = vec![];
        Solution::dfs(root, &mut ans);
        ans
    }

    fn dfs(root: Option<Rc<RefCell<TreeNode>>>, ans: &mut Vec<i32>) -> () {
        if let Some(node) = root {
            Solution::dfs(node.borrow_mut().left.take(), ans);
            ans.push(node.borrow_mut().val);
            Solution::dfs(node.borrow_mut().right.take(), ans);
        }
    }

}
```

### unique binary search trees rust

> submit time: Sun Jul 11 00:44:50 UTC 2021

```rust
impl Solution {
    
    pub fn num_trees(n: i32) -> i32 {
        let mut dp = vec![0; n as usize + 1];
        dp[0] = 1;
        dp[1] = 1;
        for i in 2..=n as usize {
            let mut s = 0;
            for j in 0..i {
                s += dp[j] * dp[i - j - 1];
            }
            dp[i] = s;
        }
        dp[n as usize]
    }

}
```

### validate binary search tree rust

> submit time: Tue Jul 13 13:38:30 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        fn aux(root: &mut Option<Rc<RefCell<TreeNode>>>, min: Option<i32>, max: Option<i32>) -> bool {
            if let Some(v) = root {
                let me = v.borrow().val;
                if let Some(n) = &min {
                    if n >= &me {
                        return false;
                    }
                }
                if let Some(n) = &max {
                    if n <= &me {
                        return false;
                    }
                }
                if !aux(&mut v.borrow_mut().left.take(), min, Some(me)){
                    return false;
                }
                if !aux(&mut v.borrow_mut().right.take(), Some(me), max){
                    return false;
                }
            }
            true
        }
        let mut root = root;
        aux(&mut root, None, None)
    }
}
```

### symmetric tree rust

> submit time: Fri Jul 02 06:49:06 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        fn is_same(r1: &Option<Rc<RefCell<TreeNode>>>, r2: &Option<Rc<RefCell<TreeNode>>>) -> bool {
            match (r1, r2) {
                (None, None) => true,
                (Some(n1), Some(n2)) => {
                    n1.borrow().val == n2.borrow().val
                    && is_same(&n1.borrow().left, &n2.borrow().right)
                    && is_same(&n1.borrow().right, &n2.borrow().left)
                },
                _ => false,
            }
        }
        if let Some(n) = root {
            is_same(&n.borrow().left, &n.borrow().right)
        }else{
            true
        }
    }


}
```

### binary tree level order traversal rust

> submit time: Wed Jul 14 02:08:01 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

pub fn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {
    fn dfs(root: Option<Rc<RefCell<TreeNode>>>, ans: &mut Vec<Vec<i32>>, level: usize) {
        if let Some(t) = root {
            if ans.len() <= level {
                ans.push(vec![]);
            }
            ans[level].push(t.borrow().val);
            dfs(t.borrow_mut().left.take(), ans, level + 1);
            dfs(t.borrow_mut().right.take(), ans, level + 1);
        }
    }
    let mut ans = vec![];
    dfs(root, &mut ans, 0);
    ans
}
}
```

### maximum depth of binary tree rust

> submit time: Fri Jul 02 07:36:44 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {


    pub fn max_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        if let Some(n) = root {
            let mut a = 0;
            {
                a = a.max(Solution::max_depth(n.borrow_mut().left.take()));
            }
            {
                a = a.max(Solution::max_depth(n.borrow_mut().right.take()));
            }
            a + 1
        }else {
            0
        }
    }

}
```

### construct binary tree from preorder and inorder traversal rust

> submit time: Wed Jul 14 02:32:26 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

pub fn build_tree(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {
    fn divide(preorder: &Vec<i32>, idx: &mut usize, inorder: &[i32]) -> Option<Rc<RefCell<TreeNode>>>{
        if inorder.is_empty() {
            return None;
        }
        let val = preorder[*idx];
        let mut t = TreeNode::new(val);
        let d_idx = inorder.iter().enumerate().filter(|&(i, &x)| x == val).next().unwrap().0;
        *idx += 1;
        t.left = divide(preorder, idx, &inorder[..d_idx]);
        t.right = divide(preorder, idx, &inorder[d_idx + 1..]);
        Some(Rc::new(RefCell::new(t)))
    }
    divide(&preorder, &mut 0, &inorder[0..inorder.len()])
}

}
```

### flatten binary tree to linked list rust

> submit time: Fri Jul 09 14:27:37 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    
    pub fn flatten(root: &mut Option<Rc<RefCell<TreeNode>>>) {
        if root.is_none() {
            return;
        }
        let mut q = vec![];
        q.push(root.as_mut().unwrap().borrow_mut().right.take());
        q.push(root.as_mut().unwrap().borrow_mut().left.take());
        let mut cur = root;
        while !q.is_empty() {
            let a = q.pop().unwrap();
            if let Some(x) = a {
                q.push(x.borrow_mut().right.take());
                q.push(x.borrow_mut().left.take());
                let c = cur.as_mut().unwrap();
                let d = Rc::get_mut(c).unwrap();
                let e = d.get_mut();
                e.right = Some(x);
                cur = &mut e.right;
            }
        }
    }
}
```

### best time to buy and sell stock rust

> submit time: Fri Jul 02 09:30:41 UTC 2021

```rust
impl Solution {

    pub fn max_profit(prices: Vec<i32>) -> i32 {
        if prices.len() == 0 {
            return 0;
        }
        let mut ans = 0;
        let mut lastmin = prices[0];
        for i in prices {
            ans = ans.max(i - lastmin);
            lastmin = lastmin.min(i);
        }
        ans
    }

}
```

### binary tree maximum path sum rust

> submit time: Tue Jul 06 15:46:39 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn max_path_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>, ans: &mut i32) -> i32{
            if let Some(n) = root {
                let left  = dfs(&n.borrow().left, ans).max(0);
                let right = dfs(&n.borrow().right, ans).max(0);
                let mut cur = left + n.borrow().val + right;
                *ans = *ans.max(&mut cur);
                n.borrow().val + left.max(right)
            }else{
                0
            }
        }
        let mut ans = i32::MIN;
        dfs(&root, &mut ans);
        ans
    }
}
```

### longest consecutive sequence rust

> submit time: Wed Jul 07 14:41:50 UTC 2021

```rust
impl Solution {
    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {
        let mut ans = 0;
        let mut h = std::collections::HashMap::new();
        for i in nums {
            if h.contains_key(&i) {
                continue;
            }
            let llen = *h.get(&(i - 1)).unwrap_or(&0);
            let rlen = *h.get(&(i + 1)).unwrap_or(&0);
            let len = llen + rlen + 1;
            h.insert(i, len);
            ans = ans.max(len);
            h.insert(i - llen, len);
            h.insert(i + rlen, len);
        }

        ans
    }

}
```

### single number rust

> submit time: Fri Jul 02 09:36:38 UTC 2021

```rust
impl Solution {
    pub fn single_number(nums: Vec<i32>) -> i32 {
        nums.iter().fold(0, |a, b| a^b)
    }
}
```

### word break rust

> submit time: Fri Jul 09 03:50:28 UTC 2021

```rust
impl Solution {

    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {
        let mut dp = vec![false; s.len() + 1];
        dp[0] = true;
        for i in 1..=s.len() {
            for w in &word_dict {
                if i >= w.len(){
                    dp[i] = dp[i - w.len()] && s[i-w.len()..i].eq(w);
                }
                if dp[i] {
                    break;
                }
            }
        }
        *dp.last().unwrap()
    }
}
```

### lru cache rust

> submit time: Mon Jul 12 13:43:23 UTC 2021

```rust
use std::rc::Rc;
use std::cell::RefCell;
struct LRUCache {
    map: std::collections::HashMap<i32, Rc<RefCell<Node>>>,
    capacity: usize,
    head: Rc<RefCell<Node>>,
    tail: Rc<RefCell<Node>>,
}
struct Node {
    key: i32,
    val: i32,
    pre: Option<Rc<RefCell<Node>>>,
    nxt: Option<Rc<RefCell<Node>>>,
}
impl Node {
    fn new(key: i32, val: i32) -> Node {
        Node {
            key,
            val,
            pre: None,
            nxt: None,
        }
    }
}


/**
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl LRUCache {

    fn new(capacity: i32) -> Self {
        
        let head = Rc::new(RefCell::new(Node::new(-1, -1)));
        let tail = Rc::new(RefCell::new(Node::new(-1, -1)));
        head.borrow_mut().nxt = Some(tail.clone());
        tail.borrow_mut().pre = Some(head.clone());
        LRUCache {
            map: std::collections::HashMap::new(),
            capacity: capacity as usize,
            head: head,
            tail: tail,
        }
    }
    
    fn get(&mut self, key: i32) -> i32 {
        if let Some(n) = self.map.get_mut(&key) {
            let pre = n.borrow_mut().pre.take().unwrap();
            let nxt = n.borrow_mut().nxt.take().unwrap();
            nxt.borrow_mut().pre = Some(pre.clone());
            pre.borrow_mut().nxt = Some(nxt.clone());
            
            let head = &mut self.head;
            
            n.borrow_mut().pre = Some(head.clone());
            n.borrow_mut().nxt = head.borrow_mut().nxt.take();
            head.borrow_mut().nxt = Some(n.clone());
            n.borrow_mut().nxt.as_mut().unwrap().borrow_mut().pre = Some(n.clone());
            n.borrow_mut().val
        }else{
            -1
        }
    }
    
    fn put(&mut self, key: i32, value: i32) {
        if let Some(n) = self.map.get_mut(&key) {
            n.borrow_mut().val = value;
            let pre = n.borrow_mut().pre.take().unwrap();
            let nxt = n.borrow_mut().nxt.take().unwrap();
            nxt.borrow_mut().pre = Some(pre.clone());
            pre.borrow_mut().nxt = Some(nxt.clone());
            
            let head = &mut self.head;
            
            n.borrow_mut().pre = Some(head.clone());
            n.borrow_mut().nxt = head.borrow_mut().nxt.take();
            head.borrow_mut().nxt = Some(n.clone());
            n.borrow_mut().nxt.as_mut().unwrap().borrow_mut().pre = Some(n.clone());
        }else{
            let n = Rc::new(RefCell::new(Node::new(key, value)));
            self.map.insert(key, n.clone());

            let head = &mut self.head;
            
            n.borrow_mut().pre = Some(head.clone());
            n.borrow_mut().nxt = head.borrow_mut().nxt.take();
            head.borrow_mut().nxt = Some(n.clone());
            n.borrow_mut().nxt.as_mut().unwrap().borrow_mut().pre = Some(n.clone());
            
            if self.map.len() > self.capacity {
                let remove = self.tail.borrow_mut().pre.take().unwrap();
                self.map.remove(&remove.borrow().key);
                self.tail.borrow_mut().pre = remove.borrow_mut().pre.take();
                self.tail.borrow_mut().pre.as_mut().unwrap().borrow_mut().nxt = Some(self.tail.clone());
            }

            
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * let obj = LRUCache::new(capacity);
 * let ret_1: i32 = obj.get(key);
 * obj.put(key, value);
 */
```

### sort list rust

> submit time: Thu Jul 08 01:29:26 UTC 2021

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut rec = vec![];
        let mut head = head;
        while let Some(mut h) = head {
            head = h.next.take();
            rec.push(h);
        }

        rec.sort_by_key(|b| b.val);

        let mut head = Some(Box::new(ListNode::new(-1)));
        let mut cur = head.as_mut().unwrap();

        for b in rec {
            cur.next = Some(b);
            cur = cur.next.as_mut().unwrap();
        }
        head.unwrap().next
    }
}
```

### maximum product subarray rust

> submit time: Sun Jul 11 00:57:39 UTC 2021

```rust
impl Solution {
    pub fn max_product(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut min = nums[0];
        let mut max = nums[0];
        let mut ans = nums[0];
        for i in 1..n {
            let a = nums[i];
            let (t_min, t_max) = (min, max);
            min = a.min(a * t_max).min(a * t_min);
            max = a.max(a * t_max).max(a * t_min);
            ans = ans.max(max);
        }
        ans
    }
}
```

### min stack rust

> submit time: Fri Jul 02 10:11:11 UTC 2021

```rust

struct MinStack(Vec<i32>, Vec<i32>);


/**
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl MinStack {

    
    /** initialize your data structure here. */
    fn new() -> Self {
        MinStack(vec![], vec![])
    }
    
    fn push(&mut self, val: i32) {
        self.0.push(val);
        if self.1.is_empty() || *self.1.last().unwrap() >= val {
            self.1.push(val);
        }
    }
    
    fn pop(&mut self) {
        if *self.1.last().unwrap() == self.0.pop().unwrap() {
            self.1.pop();
        }
    }
    
    fn top(&self) -> i32 {
        *self.0.last().unwrap()
    }
    
    fn get_min(&self) -> i32 {
        *self.1.last().unwrap()
    }
}
```

### excel sheet column title rust

> submit time: Tue Jun 29 02:34:58 UTC 2021

```rust
impl Solution {


    pub fn convert_to_title(column_number: i32) -> String {
        let mut ans = String::new();
        let mut num = column_number;
        while num > 0 {
            let last = (num - 1) % 26;
            let c = ('A' as u8) + (last as u8);
            ans.push(c as char);
            num = (num - 1) / 26;
        }
        return ans.chars().rev().collect();
    }

}
```

### majority element rust

> submit time: Fri Jul 02 10:20:34 UTC 2021

```rust
impl Solution {
    pub fn majority_element(nums: Vec<i32>) -> i32 {
        let mut map = std::collections::HashMap::new();
        let target = nums.len() >> 1;
        for i in nums {
            let v = map.entry(i).or_insert(0);
            *v += 1;
            if *v > target {
                return i;
            }
        }
        0
    }
}
```

### house robber rust

> submit time: Fri Jul 09 02:22:48 UTC 2021

```rust
impl Solution {
    pub fn rob(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut c = vec![vec![0; n + 1]; 2];
        for i in 1..=n {
            c[0][i] = c[0][i - 1].max(c[1][i - 1]);
            c[1][i] = c[0][i - 1] + nums[i - 1];
        }
        c[0][n].max(c[1][n])
    }
}
```

### number of islands rust

> submit time: Thu Jul 08 10:30:24 UTC 2021

```rust
impl Solution {

    pub fn num_islands(grid: Vec<Vec<char>>) -> i32 {
        let mut g = grid;
        let m = g.len();
        let n = g[0].len();
        let mut q = vec![];
        let mut num = 0;
        for i in 0..m {
            for j in 0..n {

                if g[i][j] == '1' {
                    num += 1;
                    q.push((i, j));
                    while !q.is_empty() {
                        let (x, y) = q.pop().unwrap();
                        if g[x][y] == '1' {
                            g[x][y] = '0';
                            if x > 0 {
                                q.push((x - 1, y));
                            }
                            if y > 0 {
                                q.push((x, y - 1));
                            }
                            if x < m - 1 {
                                q.push((x + 1, y));
                            }
                            if y < n - 1 {
                                q.push((x, y + 1));
                            }
                        }
                    }

                }
            }
        }

        num
    }
}
```

### remove linked list elements rust

> submit time: Wed Jun 30 15:16:44 UTC 2021

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {

    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {

        let mut dummy = Some(Box::new(ListNode{val: -1, next: head}));

        let mut h = &mut dummy;

        while h.as_ref().is_some() {
            if h.as_mut().unwrap().next.is_some() {
                if h.as_ref().unwrap().next.as_ref().unwrap().val == val {
                    h.as_mut().unwrap().next = h.as_mut().unwrap().next.as_mut().unwrap().next.take();
                }else{
                    h = &mut h.as_mut().unwrap().next;
                }
            }else{
                break;
            }
        }
        dummy.unwrap().next
    }
}
```

### reverse linked list rust

> submit time: Tue Jun 29 03:53:00 UTC 2021

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        if head.is_none() {
            return None;
        }
        let mut last: Option<Box<ListNode>> = None;
        let mut m = head;
        while m.is_some() {
            let mut node = m.take().unwrap();
            m = node.next;
            node.next = last;
            last = Some(node);
        }
        return last;
    }
}
```

### course schedule rust

> submit time: Fri Jul 09 07:55:47 UTC 2021

```rust
impl Solution {

pub fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {
    fn dfs(i: i32, map: &mut std::collections::HashMap<i32, Vec<i32>>, rec: &mut Vec<bool>) -> bool{
        if rec[i as usize] {
           return false;
        }
        rec[i as usize] = true;
        if let Some(v) = map.remove(&i) {
            for j in v {
                if !dfs(j, map, rec) {
                    return false;
                }
            }
        }
        rec[i as usize] = false;
        return true;
    }
    let mut map = std::collections::HashMap::new();
    for p in prerequisites{
        let v = map.entry(p[0]).or_insert(vec![]);
        v.push(p[1]);
    }
    let mut rec = vec![false; num_courses as usize];
    while !map.is_empty() {
        if !dfs(*map.keys().next().unwrap(), &mut map, &mut rec) {
            return false;
        }
    }
    true
}
}
```

### implement trie prefix tree rust

> submit time: Mon Jul 12 09:07:41 UTC 2021

```rust
struct Trie {
    map: Map,
}

struct Map {
    map: std::collections::HashMap<u8, Map>,
}


/**
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl Trie {

    /** Initialize your data structure here. */
    fn new() -> Self {
        Trie {
            map: Map {map: std::collections::HashMap::new()}
        }
    }
    
    /** Inserts a word into the trie. */
    fn insert(&mut self, word: String) {
        let mut m = &mut self.map;
        for &u in word.as_bytes() {
            m = m.map.entry(u).or_insert(Map { map: std::collections::HashMap::new()});
        }
        m.map.insert(0, Map { map: std::collections::HashMap::new()});
    }
    
    /** Returns if the word is in the trie. */
    fn search(&self, word: String) -> bool {
        let mut m = &self.map;
        for u in word.as_bytes() {
            if let Some(n) = m.map.get(u) {
                m = n;
            }else{
                return false;
            }
        }
        m.map.get(&0).is_some()
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    fn starts_with(&self, prefix: String) -> bool {
        let mut m = &self.map;
        for u in prefix.as_bytes() {
            if let Some(n) = m.map.get(u) {
                m = n;
            }else{
                return false;
            }
        }
        true
    }
}


/**
 * Your Trie object will be instantiated and called as such:
 * let obj = Trie::new();
 * obj.insert(word);
 * let ret_2: bool = obj.search(word);
 * let ret_3: bool = obj.starts_with(prefix);
 */
```

### kth largest element in an array rust

> submit time: Thu Jul 15 06:46:59 UTC 2021

```rust
use std::time::{SystemTime, UNIX_EPOCH};
impl Solution {

    pub fn find_kth_largest(nums: Vec<i32>, k: i32) -> i32 {
        fn rand(most: usize) -> usize {
            SystemTime::now().duration_since(UNIX_EPOCH)
            .unwrap()
            .subsec_nanos() as usize
            % most
        }
        let mut nums = nums;
        let mut left = 0;
        let mut right = nums.len() - 1;
        let k = k as usize;

        loop {
            nums.swap(left, left + rand(right + 1 - left));
            let flag = nums[left];
            let mut i = left + 1;
            while i <= right {
                match nums[i].cmp(&flag) {
                    std::cmp::Ordering::Less => {
                        nums.swap(i, right);
                        right -= 1;
                    },
                    _ => i += 1,
                }
            }
            nums.swap(right, left);
            if right == k - 1 {
                return nums[right];
            }else if right < k - 1 {
                left = right + 1;
                right = nums.len() - 1;
            }else{
                right = right - 1;
                left = 0;
            }
        }
    }
}
```

### maximal square rust

> submit time: Fri Jul 09 06:12:07 UTC 2021

```rust
impl Solution {
pub fn maximal_square(matrix: Vec<Vec<char>>) -> i32 {
    let m = matrix.len();
    let n = matrix[0].len();
    let mut dp = vec![vec![0; n + 1]; m + 1];
    let mut ans = 0;

    for i in 1..=m {
        for j in 1..=n {
            if matrix[i - 1][j - 1] == '1' {
                dp[i][j] = dp[i][j - 1].min(dp[i - 1][j]).min(dp[i - 1][j - 1]) + 1;
                ans = ans.max(dp[i][j]);
            }
        }
    }

    (ans * ans) as i32
}

}
```

### invert binary tree rust

> submit time: Sat Jul 03 00:56:05 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn invert_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        if let Some(n) = root {
            let left = Solution::invert_tree(n.borrow_mut().left.take());
            let right = Solution::invert_tree(n.borrow_mut().right.take());
            n.borrow_mut().left = right;
            n.borrow_mut().right = left;
            Some(n)
        }else{
            None
        }
    }

}
```

### palindrome linked list rust

> submit time: Sat Jul 03 01:05:44 UTC 2021

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {

    pub fn is_palindrome(head: Option<Box<ListNode>>) -> bool {
        let mut v = vec![];
        let mut head = head;
        while let Some(n) = head.take() {
            v.push(n.val);
            head = n.next;
        }
        for i in 0..v.len() >> 1 {
            if v[i] != v[v.len() - 1 - i] {
                return false;
            }
        }
        true
    }
}
```

### lowest common ancestor of a binary tree rust

> submit time: Tue Jul 13 14:13:42 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>, p: i32, q: i32) -> (bool, bool, Option<Rc<RefCell<TreeNode>>>) {
            let (mut a, mut b) = (false, false);
            if let Some(me) = root {
                let val = me.borrow().val;
                if  val == p{
                    a = true;
                }
                if  val == q{
                    b = true;
                }
                let (la, lb, lo) = dfs(& me.borrow().left, p, q);
                if lo.is_some() {
                    return (true, true, lo);
                }
                let (ra, rb, ro) = dfs(& me.borrow().right, p, q);
                if ro.is_some() {
                    return (true, true, ro);
                }
                let (aa, bb) = (a || la || ra, b || lb || rb);
                if aa && bb {
                    return (aa, bb, Some(Rc::new(RefCell::new(TreeNode::new(val)))));
                }
                return (aa, bb, None);
            }
            (false, false, None)
        }
        dfs(&root, p.unwrap().borrow().val, q.unwrap().borrow().val).2
    }

}
```

### product of array except self rust

> submit time: Thu Jul 08 13:05:59 UTC 2021

```rust
impl Solution {
    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {
        let mut left = vec![1; nums.len() + 2];
        let mut right = vec![1; nums.len() + 2];

        for i in 0..nums.len() {
            left[i + 1] = left[i] * nums[i];
            right[nums.len() - i] = right[nums.len() - i + 1] * nums[nums.len() - 1 - i];
        }

        let mut ans = vec![0; nums.len()];
        for i in 0..nums.len() {
            ans[i] = left[i] * right[i + 2];
        }

        ans
    }
}
```

### sliding window maximum rust

> submit time: Wed Jul 14 03:38:55 UTC 2021

```rust
impl Solution {

pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {
    let mut a: std::collections::BinaryHeap<(i32, usize)> = std::collections::BinaryHeap::new();
    let k = k as usize;
    for i in 0..k-1 {
        a.push((nums[i], i));
    }
    let mut ans = vec![];
    for i in k-1..nums.len() {
        a.push((nums[i], i));
        let start = i + 1 - k;
        loop {
            let b = a.peek().unwrap();
            if b.1 >= start {
                ans.push(b.0);
                break;
            } else {
                a.pop();
            }
        }
    }
    ans
}

}
```

### search a 2d matrix ii rust

> submit time: Fri Jul 09 08:02:35 UTC 2021

```rust
impl Solution {

pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {
    let mut i = matrix.len() as i32 - 1;
    let mut j = 0i32;

    while i >= 0 && j < matrix[0].len() as i32 {
        match matrix[i as usize][j as usize].cmp(&target) {
            std::cmp::Ordering::Equal => return true,
            std::cmp::Ordering::Less => j += 1,
            _ => i -= 1
        }
    }
    false
}
}
```

### h index rust

> submit time: Sun Jul 11 00:35:10 UTC 2021

```rust
impl Solution {

    pub fn h_index(citations: Vec<i32>) -> i32 {
        let n = citations.len();
        let mut cnts = vec![0; n + 1];
        for i in citations {
            cnts[i.min(n as i32) as usize] += 1;
        }
        let mut h = n + 1;
        let mut s = 0;
        for &i in cnts.iter().rev() {
            s += i;
            h -= 1;
            if s >= h {
                break;
            }
        }
        h as i32
    }
}
```

### h index ii rust

> submit time: Mon Jul 12 02:43:22 UTC 2021

```rust
impl Solution {

    pub fn h_index(citations: Vec<i32>) -> i32 {
        let n = citations.len() as i32;
        let mut left = 0i32;
        let mut right = n - 1;
        while left <= right {
            let mid = left + (right - left) / 2;
            match citations[mid as usize].cmp(&(n as i32 - mid as i32)) {
                std::cmp::Ordering::Greater => right = mid - 1,
                std::cmp::Ordering::Less => left = mid + 1,
                _ => return (n - mid) as i32
            }
        }
        n - left
    }
}
```

### perfect squares rust

> submit time: Thu Jul 08 13:58:38 UTC 2021

```rust
impl Solution {

    pub fn num_squares(n: i32) -> i32 {
        let mut dp = vec![n; n as usize + 1];
        dp[0] = 0;
        for i in 1..=n as usize {
            for j in 1..=i {
                let x = j * j;
                if x > i {
                    break;
                }
                dp[i] = dp[i].min(dp[i - x] + 1);
            }
        }
        dp[n as usize]
    }
}
```

### move zeroes rust

> submit time: Sat Jul 03 01:15:50 UTC 2021

```rust
impl Solution {

    pub fn move_zeroes(nums: &mut Vec<i32>) {
        let mut last = 0usize;
        for i in 0..nums.len() {
            if nums[i] != 0 {
                nums.swap(last, i);
                last += 1;
            }
        }
    }

}
```

### find the duplicate number rust

> submit time: Fri Jul 09 02:59:04 UTC 2021

```rust
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        let mut ans = 0;
        let mut p = 0;
        let n = nums.len();
        loop {
            let n_cnt = nums.iter().filter(|&x| x & (1 << p) > 0).count();
            let i_cnt = (1..n).filter(|x| x & (1 << p) > 0).count();
            if n_cnt > i_cnt {
                ans = ans | (1 << p);
            }
            p += 1;
            if i_cnt == 0 {
                break;
            }
        }
        ans
    }
}
```

### serialize and deserialize binary tree rust

> submit time: Tue Jul 13 09:23:08 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
struct Codec {
	
}

/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl Codec{
    fn new() -> Self {
        Codec{}
    }

    fn serialize(&self, root: Option<Rc<RefCell<TreeNode>>>) -> String {
        let mut q = vec![root];
        let mut ans = String::new();
        while let Some(n) = q.pop() {
            if let Some(w) = n {
                q.push(w.borrow_mut().right.take());
                q.push(w.borrow_mut().left.take());
                ans.push_str(format!("{},", w.borrow_mut().val).as_str());
            }else{
                ans.push_str("nil,");
            }
        }
        ans.remove(ans.len() - 1);
        ans
    }
    
    fn deserialize(&self, data: String) -> Option<Rc<RefCell<TreeNode>>> {
        let v: Vec<&str> = data.split(",").collect();
        self.aux(&v, &mut 0)
    }
    fn aux(&self, v: &Vec<&str>, idx: &mut usize) -> Option<Rc<RefCell<TreeNode>>> {
        match v[*idx] {
            "nil" => None,
            _ => {
                let n: i32 = v[*idx].parse().unwrap();
                let mut n = Some(Rc::new(RefCell::new(TreeNode::new(n))));
                *idx += 1;
                n.as_mut().unwrap().borrow_mut().left = self.aux(v, idx);
                *idx += 1;
                n.as_mut().unwrap().borrow_mut().right = self.aux(v, idx);
                n
            }
        }
    }
}
/**
 * Your Codec object will be instantiated and called as such:
 * let obj = Codec::new();
 * let data: String = obj.serialize(strs);
 * let ans: Option<Rc<RefCell<TreeNode>>> = obj.deserialize(data);
 */
```

### longest increasing subsequence rust

> submit time: Sun Jul 11 02:13:43 UTC 2021

```rust
impl Solution {

    pub fn length_of_lis(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut ans = 1;
        let mut dp = vec![0; n];
        dp[0] = 1;
        for i in 1..n {
            let mut cur = 0;
            for j in 0..i {
                if nums[i] > nums[j] && cur < dp[j] {
                    cur = dp[j];
                }
            }
            dp[i] = cur + 1;
            ans = ans.max(dp[i]);
        }
        ans
    }
}
```

### remove invalid parentheses rust

> submit time: Thu Jul 15 13:21:07 UTC 2021

```rust
impl Solution {


    pub fn remove_invalid_parentheses(s: String) -> Vec<String> {
        fn dfs(bys: &[u8], ans: &mut std::collections::HashSet<String>, idx: usize, cnt: usize, dleft: usize, dright: usize, cur: &mut String){
            if idx == bys.len() && dleft == 0 && dright == 0 {
                ans.insert(cur.clone());
                return;
            }
            if idx == bys.len() {
                return;
            }
            match bys[idx] {
                b'(' => {
                    if dleft > 0 {
                        dfs(bys, ans, idx + 1, cnt, dleft - 1, dright, cur);
                    }
                    cur.push('(');
                    dfs(bys, ans, idx + 1, cnt + 1, dleft, dright, cur);
                    cur.remove(cur.len() - 1);
                },
                b')' => {
                    if cnt > 0 {
                        cur.push(')');
                        dfs(bys, ans, idx + 1, cnt - 1, dleft, dright, cur);
                        cur.remove(cur.len() - 1);
                    }
                    if dright > 0{
                        dfs(bys, ans, idx + 1, cnt, dleft, dright - 1, cur);
                    }
                },
                _ => {
                    cur.push(bys[idx] as char);
                    dfs(bys, ans, idx + 1, cnt, dleft, dright, cur);
                    cur.remove(cur.len() - 1);
                },
            }
        }
        let mut cnt = 0i32;
        let mut dright =  0;
        let mut dleft = 0;
        for &i in s.as_bytes() {
            match i {
                b'(' => cnt += 1,
                b')' => cnt -= 1,
                _ => continue,
            }
            if cnt < 0{
                dright += 1;
                cnt += 1;
            }
        }
        if cnt > 0{
            dleft = cnt as usize;
        }
        let mut ans = std::collections::HashSet::new();
        dfs(s.as_bytes(), &mut ans, 0, 0, dleft, dright, &mut String::new());
        let a = ans.into_iter().collect();
        a
    }
}
```

### best time to buy and sell stock with cooldown rust

> submit time: Sun Jul 11 02:03:07 UTC 2021

```rust
impl Solution {

    pub fn max_profit(prices: Vec<i32>) -> i32 {
        if prices.is_empty() {
            return 0;
        }
        let mut dp = vec![0; 3];
        dp[0] = -prices[0];
        for &i in &prices[1..prices.len()] {
            let (a, b, c) = (dp[0], dp[1], dp[2]);
            dp[0] = a.max(c - i);
            dp[1] = a + i;
            dp[2] = b.max(c);
        }
        dp[1].max(dp[2])
    }
}
```

### burst balloons rust

> submit time: Mon Jul 12 06:29:21 UTC 2021

```rust
impl Solution {

    pub fn max_coins(nums: Vec<i32>) -> i32 {
        let mut nums = nums;
        let n = nums.len();
        nums.insert(0, 1);
        nums.push(1);
        let mut dp = vec![vec![0; n + 2]; n + 2];

        for len in 1..=n {
            for start in 1..=n-len+1 {
                let left = nums[start -1];
                let right = nums[start + len];
                let mut max = 0;
                for i in start..start+len {
                    let mut f = 0;
                    if start <= i - 1 {
                        f += dp[start][i-1];
                    }
                    if i + 1 <= start + len - 1 {
                        f += dp[i+1][start + len - 1];
                    }
                    max = max.max(left * right * nums[i] + f);
                }
                dp[start][start + len - 1] = max;
            }
        }
        dp[1][n]
    }
}
```

### remove duplicate letters rust

> submit time: Wed Jul 07 05:52:07 UTC 2021

```rust
impl Solution {

    pub fn remove_duplicate_letters(s: String) -> String {
        let mut cnts = [0; 26];
        let mut vist = [false; 26];
        for c in s.as_bytes() {
            cnts[(c - b'a') as usize] += 1;
        }

        let mut ans = String::new();
        for &c in s.as_bytes() {
            let i = (c - b'a') as usize;
            if !vist[i] {

                while !ans.is_empty() {
                    let a = ans.as_bytes()[ans.len() - 1];
                    let j = (a - b'a') as usize;
                    if a < c {
                        break;
                    }
                    if cnts[j] > 0 {
                        vist[j] = false;
                        ans.remove(ans.len() - 1);
                    }else{
                        break;
                    }
                }

                vist[i] = true;
                ans.push(c as char);
            }
            cnts[i] -= 1;
        }

        ans
    }
}
```

### coin change rust

> submit time: Thu Jul 08 12:48:32 UTC 2021

```rust
impl Solution {
    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {
        let mut dp = vec![-1; amount as usize + 1];
        dp[0] = 0;
        for i in 1..dp.len() {
            for &c in &coins {
                if i >= c as usize && dp[i - c as usize] >= 0 {
                    if dp[i] < 0 {
                        dp[i] = dp[i - c as usize] + 1;
                    }else{
                        dp[i] = dp[i].min(dp[i - c as usize] + 1);
                    }
                }
            }
        }
        dp[amount as usize]
    }
}
```

### house robber iii rust

> submit time: Sun Jul 11 01:47:28 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    
    pub fn rob(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        fn dfs(root: Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {
            if let Some(n) = root {
                let left = dfs(n.borrow_mut().left.take());
                let right = dfs(n.borrow_mut().right.take());
                let r = left.0 + right.0 + n.borrow_mut().val;
                let l = left.0.max(left.1) + right.0.max(right.1);
                (l, r)
            }else {
                (0, 0)
            }
        }
        let a = dfs(root);
        a.0.max(a.1)
    }

}
```

### counting bits rust

> submit time: Sat Jul 03 01:27:43 UTC 2021

```rust
impl Solution {
    pub fn count_bits(n: i32) -> Vec<i32> {
        let mut ans: Vec<i32> = vec![0];
        for i in ans.len()..=n as usize {
            ans.push(ans[i >> 1] + (i as i32 & 1));
        }
        ans
    }
}
```

### top k frequent elements rust

> submit time: Wed Jul 14 03:34:46 UTC 2021

```rust
impl Solution {
    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let mut map = std::collections::HashMap::new();
        nums.iter().for_each(|&i| *map.entry(i).or_insert(0) += 1);
        let mut v: Vec<(&i32, &i32)> = map.iter().map(|a| a).collect();
        v.sort_unstable_by_key(|&(_, cnt)| cnt);
        v.iter().rev().map(|&(&n, _)| n).take(k as usize).collect()
    }
}
```

### decode string rust

> submit time: Fri Jul 09 03:34:32 UTC 2021

```rust
impl Solution {

    pub fn decode_string(s: String) -> String {
        let mut i = 0;
        let mut ns = vec![];
        let mut ss = vec![];
        let mut n = 0;
        let mut curs: String = String::new();
        while i < s.len() {
            let c = s.as_bytes()[i];
            match c {
                b'0'..=b'9' => {
                    n = 0;
                    while i < s.len() {
                        let c = s.as_bytes()[i];
                        match c {
                            b'0'..=b'9' => {
                                n = n * 10 + (c - b'0');
                                i += 1;
                            },
                            _ => break,
                        }
                    }
                },
                b'[' => {
                    ns.push(n);
                    ss.push(curs);
                    curs = String::new();
                    i += 1;
                },
                b']' => {
                    let a = ns.pop().unwrap();
                    let copy = curs.clone();
                    for _ in 0..a-1 {
                        curs += &copy;
                    }
                    let a = ss.pop().unwrap();
                    curs = a + &curs;
                    i += 1;
                },
                _ => {
                    while i < s.len() {
                        let c = s.as_bytes()[i];
                        match c {
                            b'a'..=b'z' => {
                                curs.push(c as char);
                                i += 1;
                            },
                            _ => break,
                        }
                    }
                }
            }
            
        }
        curs
    }
}
```

### evaluate division rust

> submit time: Thu Jul 15 02:07:50 UTC 2021

```rust


struct UnionFind {
    parents: Vec<usize>,
    vals: Vec<f64>,
}

impl UnionFind {
    fn new(size: usize) -> UnionFind {
        UnionFind{
            parents: (0..size + 2).collect(),
            vals: vec![1.0; size + 2],
        }
    }
    fn put(&mut self, a: usize, b: usize, val: f64) {
        let ap = self.find(a);
        let bp = self.find(b);
        self.parents[ap] = bp;
        self.vals[ap] = self.vals[b] * val / self.vals[a];
    }

    fn find(&mut self, a: usize) -> usize {
        let ap = self.parents[a];
        if ap != a {
            let rp = self.find(ap);
            self.parents[a] = rp;
            self.vals[a] *= self.vals[ap];
            rp
        }else{
            a
        }
    }

    fn cal(&mut self, a: usize, b: usize) -> f64 {
        let ap = self.find(a);
        let bp = self.find(b);
        if ap == bp {
            self.vals[a] / self.vals[b]
        }else {
            -1f64
        }
    }

}
impl Solution {
    pub fn calc_equation(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> {
        let mut uf = UnionFind::new(equations.len() * 2);
        let mut map: std::collections::HashMap<String, usize> = std::collections::HashMap::new();
        let mut cnt = 0;
        for i in 0..equations.len() {
            let eq = &equations[i];
            let a = match map.get(&eq[0]) {
                Some(a) => *a,
                _ => {cnt += 1; map.insert(eq[0].clone(), cnt); cnt},
            };
            let b = match map.get(&eq[1]) {
                Some(a) => *a,
                _ => {cnt += 1; map.insert(eq[1].clone(), cnt); cnt},
            };
            uf.put(a, b, values[i]);
        }

        let mut ans = vec![];
        for q in queries {
            if let (Some(&a), Some(&b)) = (map.get(&q[0]), map.get(&q[1])) {
                ans.push(uf.cal(a, b));
            }else{
                ans.push(-1f64);
            }
        }

        ans
    }
}
```

### queue reconstruction by height rust

> submit time: Wed Jul 07 02:29:03 UTC 2021

```rust
impl Solution {

    pub fn reconstruct_queue(people: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut people = people;
        people.sort_by(|x, y| y[0].cmp(&x[0]).then(x[1].cmp(&y[1])));
        let mut ans = vec![];
        for p in people {
            ans.insert(p[1] as usize, p);
        }
        ans
    }

}
```

### partition equal subset sum rust

> submit time: Sun Jul 11 01:39:04 UTC 2021

```rust
impl Solution {

    pub fn can_partition(nums: Vec<i32>) -> bool {
        let mut s = nums.iter().fold(0, |a, b| a + b);
        if s & 1 > 0 {
            return false;
        }
        s = s >> 1;
        let mut dp = vec![false; s as usize + 1];
        dp[0] = true;

        for num in nums {
            for i in (1..=s as i32).rev() {
                if dp[i as usize] {
                    continue;
                }
                let a = i - num;
                if a >= 0 {
                    dp[i as usize] = dp[a as usize];
                }
            }
        }
        dp[s as usize]
    }
}
```

### path sum iii rust

> submit time: Wed Jul 14 00:00:50 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> i32 {
        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>, ans: &mut i32, last: bool, cur: i32, target: i32) {
            if let Some(r) = root {
                if !last {
                    dfs(&r.borrow_mut().left, ans, false, 0, target);
                    dfs(&r.borrow_mut().right, ans, false, 0, target);
                }
                let now = cur + r.borrow().val;
                if now == target {
                    *ans += 1;
                }
                dfs(&r.borrow_mut().left, ans, true, now, target);
                dfs(&r.borrow_mut().right, ans, true, now, target);
            }
        }
        let mut ans = 0;
        dfs(&root, &mut ans, false, 0, target_sum);
        ans
    }
}
```

### find all anagrams in a string rust

> submit time: Thu Jul 15 09:22:48 UTC 2021

```rust
impl Solution {

    pub fn find_anagrams(s: String, p: String) -> Vec<i32> {
        let bys = s.as_bytes();
        let mut cnts = [0; 26];
        let mut clen = 0;
        for &b in p.as_bytes() {
            let a = &mut cnts[(b - b'a') as usize];
            *a += 1;
            if *a == 1{
                clen += 1;
            }
        }
        let mut ans = vec![];
        let mut left = 0;
        let mut right = 0;

        while right < s.len() {
            let b = bys[right];
            let a = &mut cnts[(b - b'a') as usize];
            *a -= 1;
            if *a == 0 {
                clen -= 1;
            }
            if clen == 0 {
                ans.push(left as i32);
            }
            while right - left + 1 == p.len() {
                let b = bys[left];
                let a = &mut cnts[(b - b'a') as usize];
                *a += 1;
                if *a == 1 {
                    clen += 1;
                }
                left += 1;
            }
            right += 1;
        }
        ans
    }
}
```

### find all numbers disappeared in an array rust

> submit time: Sat Jul 03 01:55:13 UTC 2021

```rust
impl Solution {
    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {
        let mut nums = nums;
        for i in 0..nums.len() {
            let a = (nums[i].abs() - 1) as usize;
            nums[a] = -nums[a].abs()
        }
        nums.iter().enumerate().filter(|&(i, &v)| v > 0).map(|(i, _)| i as i32 + 1).collect()
    }
}
```

### sort characters by frequency rust

> submit time: Sat Jul 03 00:32:02 UTC 2021

```rust
use std::iter::FromIterator;
impl Solution {
    pub fn frequency_sort(s: String) -> String {
        let mut cnts = [0; 128];
        s.as_bytes().iter().for_each(|&a| cnts[a as usize] += 1);
        let mut cnts: Vec<(usize, &i32)> = cnts.iter().enumerate().collect();
        cnts.sort_by_key(|&(_, v)| -v);
        cnts.iter().fold(String::new(), |res, &(c, &v)| {res + &String::from_iter(core::iter::repeat(c as u8 as char).take(v as usize))})
    }
}
```

### hamming distance rust

> submit time: Sat Jul 03 01:57:55 UTC 2021

```rust
impl Solution {
    pub fn hamming_distance(x: i32, y: i32) -> i32 {
        (x ^ y).count_ones() as i32
    }
}
```

### target sum rust

> submit time: Thu Jul 08 14:34:59 UTC 2021

```rust
impl Solution {

    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {
        let sum = nums.iter().fold(0, |a, b| a + b);
        let r2 = sum - target;
        if r2 & 1 > 0  || r2 < 0{
            return 0;
        }
        let target = r2 >> 1;

        let mut dp = vec![0; (1 + target) as usize];
        dp[0] = 1;
        for i in nums {
            for j in (i as usize..=target as usize).rev() {
                dp[j] += dp[j -  i as usize];
            }
        }

        dp[target as usize]
    }


}
```

### convert bst to greater tree rust

> submit time: Tue Jul 13 14:29:13 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn convert_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        fn dfs(root: &mut Option<Rc<RefCell<TreeNode>>>, s: &mut i32) {
            if let Some(r) = root {
                dfs(&mut r.borrow_mut().right, s);
                r.borrow_mut().val += *s;
                *s = r.borrow().val;
                dfs(&mut r.borrow_mut().left, s);
            }
        }
        let mut root = root;
        dfs(&mut root, &mut 0);
        root
    }
}
```

### diameter of binary tree rust

> submit time: Sat Jul 03 02:23:52 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn diameter_of_binary_tree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        let mut ans = 0;
        fn max_depth(r: Option<Rc<RefCell<TreeNode>>>, ans: &mut i32) -> i32 {
            if let Some(node) = r {
                let mut len_left = max_depth(node.borrow_mut().left.take(), ans);
                let mut len_right = max_depth(node.borrow_mut().right.take(), ans);
                *ans = (*ans).max(len_left + len_right + 1);
                1 + len_right.max(len_left)
            } else {
                0
            }
        }
        max_depth(root, &mut ans);
        ans - 1
    }
}
```

### subarray sum equals k rust

> submit time: Thu Jul 08 13:18:33 UTC 2021

```rust
impl Solution {
    pub fn subarray_sum(nums: Vec<i32>, k: i32) -> i32 {
        let mut map = std::collections::HashMap::new();
        map.insert(0, 1);
        let mut s = 0;
        let mut ans = 0;
        for i in nums {
            s += i;
            if let Some(&r) = map.get(&(s - k)) {
                ans += r;
            }
            let r = map.entry(s).or_insert(0);
            *r += 1;
        }
        ans
    }
}
```

### shortest unsorted continuous subarray rust

> submit time: Wed Jul 07 03:25:18 UTC 2021

```rust
impl Solution {

    pub fn find_unsorted_subarray(nums: Vec<i32>) -> i32 {
        let mut q = vec![];
        
        let mut start = nums.len() as i32;
        let mut end = 0 as i32;

        for n in 0..nums.len() {
            if q.is_empty() || nums[*q.last().unwrap() as usize] <= nums[n] {
                q.push(n as i32);
            }else {
                let mut i = q.len() as i32 - 1;
                while i >= 0 && nums[q[i as usize] as usize] > nums[n]{
                    i -= 1;
                }
                start = start.min(i);
                end = end.max(n as i32);
            }
        }
        if end < start {
            0
        } else {
            end - start
        }
    }


}
```

### merge two binary trees rust

> submit time: Sat Jul 03 02:42:12 UTC 2021

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn merge_trees(root1: Option<Rc<RefCell<TreeNode>>>, root2: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        match (root1, root2) {
            (Some(node1), Some(node2)) => {
                let left = Solution::merge_trees(node1.borrow_mut().left.take(), node2.borrow_mut().left.take());
                let right = Solution::merge_trees(node1.borrow_mut().right.take(), node2.borrow_mut().right.take());
                Some(Rc::new(RefCell::new(TreeNode{val: node1.borrow_mut().val + node2.borrow_mut().val, left, right})))
            },
            (Some(n), None) | (None, Some(n)) => Some(n),
            _ => None,
        }
    }
}
```

### task scheduler rust

> submit time: Wed Jul 07 13:50:59 UTC 2021

```rust
impl Solution {
    pub fn least_interval(tasks: Vec<char>, n: i32) -> i32 {
        let mut cnts = std::collections::HashMap::new();
        let mut m = 0;
        for &t in &tasks {
            let cnt = cnts.entry(t).or_insert(0);
            *cnt += 1;
        }
        let a = cnts.iter().map(|(_, &c)| c).max().unwrap();
        let s = cnts.iter().filter(|&(_, &c)| c == a).count() as i32;

        let one = (a - 1) * (n + 1) + s;
        one.max(tasks.len() as i32)
    }
}
```

### set mismatch rust

> submit time: Sun Jul 04 01:07:16 UTC 2021

```rust
impl Solution {

    pub fn find_error_nums(nums: Vec<i32>) -> Vec<i32> {
        let mut nums = nums;
        let mut ans: Vec<i32> = vec![];
        for i in 0..nums.len() {
            let idx = (nums[i].abs() - 1) as usize;
            if nums[idx] < 0 {
                ans.push(nums[i].abs() as i32)
            } else {
                nums[idx] = -nums[idx];
            }
        }
        ans.push(nums.iter().enumerate()
        .filter(|&(_, &v)| v > 0)
        .map(|(i, _)| i + 1)
        .next()
        .unwrap() as i32);
        ans
    }

}
```

### palindromic substrings rust

> submit time: Sun Jul 11 01:28:26 UTC 2021

```rust
impl Solution {

    pub fn count_substrings(s: String) -> i32 {
        let n = s.len();
        let mut ans = 0;
        let mut dp = vec![vec![false; n]; n];
        for i in 0..n {
            for j in 0..n-i {
                match i {
                    0 => dp[j][i + j] = true,
                    1 => dp[j][i + j] = s.as_bytes()[j] == s.as_bytes()[i + j],
                    _ => dp[j][i + j] = dp[j + 1][i + j - 1] && s.as_bytes()[j] == s.as_bytes()[i + j],
                }
                if dp[j][i + j] {
                    ans += 1;
                }
            }
        }
        ans
    }
}
```

### number of atoms rust

> submit time: Mon Jul 05 03:20:02 UTC 2021

```rust
impl Solution {

    pub fn count_of_atoms(formula: String) -> String {

        fn go<'a>(pos: &mut usize, formula: &'a String) -> Vec<(&'a str, usize)> {
            let mut ans: Vec<(&str, usize)> = vec![];
            loop {
                if *pos < formula.len() {
                    let b = formula.as_bytes()[*pos];
                    match b {
                        b')' => {
                            *pos += 1;
                            return ans;
                        },
                        _ => {
                            for &mut (str, num) in &mut parseName(pos, formula) {
                                let e = ans
                                .iter_mut()
                                .filter(|(astr, anum)| str.cmp(astr) == std::cmp::Ordering::Equal)
                                .take(1).next();
                                match e {
                                    Some(i) => {
                                        *i = (str, num + i.1)
                                    },
                                    _ => ans.push((str, num))
                                }
                            }
                            
                        },
                    }
                } else {
                    return ans;
                }
            }
        }

        fn parseName<'a>(pos: &mut usize, formula: &'a String) -> Vec<(&'a str, usize)> {
            let mut ans: Vec<(&str, usize)> = vec![];
            while *pos < formula.len() {
                let b = formula.as_bytes()[*pos];
                match b {
                    b'(' => {
                        *pos += 1;
                        let mut names = go(pos, formula);
                        let n = parseNum(pos, formula);
                        return names.iter().map(|&(str, num)| (str, num * n)).collect();
                    },
                    b')' => {

                    },
                    b'A'..=b'Z' => {
                        let last = *pos;
                        *pos += 1;
                        while *pos < formula.len() {
                            let bb = formula.as_bytes()[*pos];
                            match bb {
                                b'a'..=b'z' => {*pos += 1; continue;},
                                _ => {
                                    ans.push((&formula[last..*pos], parseNum(pos, formula)));
                                    return ans;
                                },
                            }
                        }
                        ans.push((&formula[last..*pos], parseNum(pos, formula)));
                    },
                    _ => {
                        panic!("{}", pos);
                    }
                }
            }
            ans
        }
            
        fn parseNum(pos: &mut usize, formula: &String) -> usize {
            let mut ans = 0;
            while *pos < formula.len() {
                let b = formula.as_bytes()[*pos];
                match b {
                    b'0'..=b'9' => {
                        ans *= 10;
                        ans += (b - b'0') as usize;
                        *pos += 1;
                    },
                    _ => break,
                }
            }
            if ans == 0 {1} else {ans}
        }
        let mut pos = 0;
        let mut a = go(&mut pos, &formula);
        let mut ans = String::new();
        a.sort_by_key(|&(str,_)| str);
        for &(str, num) in &a {
            ans.push_str(&format!("{}", str));
            if num > 1 {
                ans.push_str(&format!("{}", num));
            }
        }

        ans
    }

}
```

### daily temperatures rust

> submit time: Fri Jul 09 07:26:17 UTC 2021

```rust
impl Solution {


pub fn daily_temperatures(temperatures: Vec<i32>) -> Vec<i32> {
    let mut q = vec![];
    let mut ans = vec![0; temperatures.len()];
    for i in (0..temperatures.len()).rev() {
        while !q.is_empty() && temperatures[*q.last().unwrap()] <= temperatures[i] {
            q.pop();
        }
        if q.is_empty() {
            ans[i] = 0;
        } else {
            ans[i] = (*q.last().unwrap() - i) as i32;
        }
        q.push(i);
    }
    ans
}
}
```

### binary subarrays with sum rust

> submit time: Thu Jul 08 01:16:08 UTC 2021

```rust
impl Solution {

    pub fn num_subarrays_with_sum(nums: Vec<i32>, goal: i32) -> i32 {
        let mut map: std::collections::HashMap<i32, i32> = std::collections::HashMap::new();
        let mut sum = 0;
        let mut ans = 0;
        map.insert(0, 1);
        for i in nums {
            sum += i;
            if let Some(&s) = map.get(&(sum - goal)) {
                ans += s;
            }
            let a = map.entry(sum).or_insert(0);
            *a += 1;
        }
        ans
    }
}
```

### time based key value store rust

> submit time: Sat Jul 10 01:15:28 UTC 2021

```rust
struct TimeMap{
    map: std::collections::HashMap<String, Vec<(i32, String)>>
}

/**
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */


impl TimeMap {

    /** Initialize your data structure here. */
    fn new() -> Self {
        TimeMap {
            map: std::collections::HashMap::new()
        }
    }
    
    fn set(&mut self, key: String, value: String, timestamp: i32) {
        if let Some(v) = self.map.get_mut(&key) {
            v.insert(v.len(), (timestamp, value));
        }else {
            let mut v = Vec::with_capacity(60000);
            v.push((timestamp, value));
            self.map.insert(key, v);
        }
    }
    
    fn get(&self, key: String, timestamp: i32) -> String {
        if let Some(v) = self.map.get(&key) {
            match v.binary_search_by_key(&timestamp, |&(t, _)| t) {
                Ok(i) => v[i].1.clone(),
                Err(i) => {
                    if i == 0 {
                        String::new()
                    } else {
                        v[i - 1].1.clone()
                    }
                },
            }
        }else {
            String::new()
        }
    }
}


/**
 * Your TimeMap object will be instantiated and called as such:
 * let obj = TimeMap::new();
 * obj.set(key, value, timestamp);
 * let ret_2: String = obj.get(key, timestamp);
 */
```

### display table of food orders in a restaurant rust

> submit time: Tue Jul 06 02:44:31 UTC 2021

```rust
impl Solution {


    pub fn display_table(orders: Vec<Vec<String>>) -> Vec<Vec<String>> {
        let mut map = std::collections::HashMap::new();
        let mut foods: Vec<String> = vec![];
        for mut order in orders {
            let table: i32 = order[1].parse().unwrap();
            let food_name = order.remove(2);
            let name = foods.iter().enumerate().filter(|&(_, x)| food_name.eq(x)).next();
            let f_idx = match name {
                Some((idx, _)) => idx,
                None => {
                    foods.push(food_name);
                    foods.len() - 1
                }
            };
            let num = map.entry(table).or_insert(std::collections::HashMap::new())
                                .entry(f_idx).or_insert(0);
            *num += 1;
        }
        
        let mut food_with_idx: Vec<(usize, &String)> = foods.iter().enumerate().collect();
        food_with_idx.sort_by_key(|&(_, str)| str);
        let mut tables: Vec<&i32> = map.keys().collect();
        tables.sort();

        let mut ans = vec![];
        let mut head = vec![];
        head.push("Table".to_string());
        let mut food_names: Vec<String>= food_with_idx.iter().map(|&(_, str)| str.clone()).collect();
        head.append(&mut food_names);
        ans.push(head);
        for t in tables {
            let mut row = vec![];
            row.push(t.to_string());
            let m = map.get(t).unwrap();
            for (f_idx, _) in &food_with_idx {
                row.push(m.get(f_idx).unwrap_or(&0).to_string());
            }
            ans.push(row);
        }

        ans
    }


}
```

### count good meals rust

> submit time: Wed Jul 07 01:46:18 UTC 2021

```rust
impl Solution {


    pub fn count_pairs(deliciousness: Vec<i32>) -> i32 {
        let mut deliciousness = deliciousness;
        deliciousness.sort();
        let mut ans = 0;

        for p in 0..=21 {
            let target = 1 << p;
            let mut left = 0;
            let mut right = deliciousness.len() - 1;
            while left < right {
                let a = deliciousness[left] + deliciousness[right];
                if deliciousness[left] > target {
                    break;
                }
                
                if a > target {
                    right -= 1;
                } else if a < target {
                    left += 1;
                } else if deliciousness[left] == deliciousness[right] {
                    let n = right - left + 1;
                    ans += (n as i64 * (n - 1) as i64 / 2) % 1000_000_007;
                    ans %= 1000_000_007;
                    break;
                }else {
                    let mut cnt_left = 0;
                    let mut cnt_right = 0;
                    let val_left = deliciousness[left];
                    let val_right = deliciousness[right];
                    while val_left == deliciousness[left] {
                        cnt_left += 1;
                        left += 1;
                    }
                    while val_right == deliciousness[right] {
                        cnt_right += 1;
                        right -= 1;
                    }
                    ans += (cnt_left as i64 * cnt_right as i64) % 1000_000_007;
                    ans %= 1000_000_007;
                }
            }
        }

        ans as i32
    }
        


}
```

### minimum absolute sum difference rust

> submit time: Wed Jul 14 01:54:01 UTC 2021

```rust
impl Solution {
    
    pub fn min_absolute_sum_diff(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let mut s = nums1.clone();
        s.sort_unstable();
        let mut diff = 0;
        let mut ans = 0;
        for (index, &n) in nums2.iter().enumerate() {
            let orig = (nums1[index] - nums2[index]).abs();
            ans = (ans + orig) % 1_000_000_007;
            diff = match s.binary_search(&n) {
                Ok(_) => orig,
                Err(idx) => {
                    let mut c = 0;
                    if idx > 0 {
                        c = c.max(orig - (s[idx - 1] - n).abs());
                    }
                    if idx < nums1.len() {
                        c = c.max(orig - (s[idx] - n).abs());
                    }
                    c
                }
            }.max(diff);
        }
        (ans - diff + 1_000_000_007) % 1_000_000_007
    }


}
```

### maximum ice cream bars rust

> submit time: Fri Jul 02 01:05:07 UTC 2021

```rust
impl Solution {


    pub fn max_ice_cream(costs: Vec<i32>, coins: i32) -> i32 {
        let mut costs = costs;
        costs.sort_unstable();
        let mut s = 0;
        
        for i in 0..costs.len() {
            s += costs[i];
            if s > coins {
                return i as i32;
            }
        }

        costs.len() as i32
    }

}
```

### frequency of the most frequent element rust

> submit time: Mon Jul 19 02:12:00 UTC 2021

```rust
impl Solution {

pub fn max_frequency(nums: Vec<i32>, k: i32) -> i32 {
    let mut ans = 0;
    let mut diff = 0;
    let mut nums = nums;
    nums.sort_unstable();
    let n = nums.len();
    let mut left = 0;
    for right in 1..n {
        diff += ((right - left) * (nums[right] - nums[right - 1]) as usize) as i32;
        while diff > k {
            diff -= nums[right] - nums[left];
            left += 1;
        }
        ans = ans.max(right - left);
    }
    1 + ans as i32
}

}
```

### maximum element after decreasing and rearranging rust

> submit time: Thu Jul 15 01:01:06 UTC 2021

```rust
impl Solution {

pub fn maximum_element_after_decrementing_and_rearranging(arr: Vec<i32>) -> i32 {
    let mut arr = arr;
    arr.sort_unstable();
    arr[0] = 1;
    for i in 1..arr.len() {
        if (arr[i] - arr[i - 1]).abs() > 1 {
            arr[i] = arr[i - 1] + 1;
        }
    }
    *arr.last().unwrap()
}
}
```

### minimize maximum pair sum in array rust

> submit time: Tue Jul 20 01:02:22 UTC 2021

```rust
impl Solution {

pub fn min_pair_sum(nums: Vec<i32>) -> i32 {
    let mut nums = nums;
    nums.sort_unstable();
    let n = nums.len();
    let mut left = 0;
    let mut right = n - 1;
    let mut ans = 0;
    while left < right {
        ans = ans.max(nums[left] + nums[right]);
        left += 1;
        right -= 1;
    }
    ans
}

}
```

### chuan di xin xi rust

> submit time: Thu Jul 01 02:33:47 UTC 2021

```rust
impl Solution {

    pub fn num_ways(n: i32, relation: Vec<Vec<i32>>, k: i32) -> i32 {
        let mut map: std::collections::HashMap<i32, Vec<i32>>= std::collections::HashMap::new();
        for r in &relation {
            if map.contains_key(&r[0]) {
                map.get_mut(&r[0]).unwrap().push(r[1]);
            }else{
                map.insert(r[0], vec![r[1]]);
            }
        }
        let target = n - 1;
        let mut left = vec![0];
        let mut right: Vec<i32> = vec![];
        for i in 0..k {
            for node in &left {
                if let Some(t) = map.get(node) {
                    for &x in t {
                        right.push(x);
                    }
                }
            }
            let mut tmp = left;
            left = right;
            right = tmp;
            right.clear();
        }

        left.iter().filter(|&&x| x == target).count() as i32
    }

}
```

### lian xu zi shu zu de zui da he lcof rust

> submit time: Sat Jul 17 00:07:00 UTC 2021

```rust
impl Solution {

    pub fn max_sub_array(nums: Vec<i32>) -> i32 {
        let mut ans = nums[0];
        let mut cur = 0;
        for i in nums {
            cur = i.max(i + cur);
            ans = ans.max(cur);
        }
        ans
    }
}
```

### liang ge lian biao de di yi ge gong gong jie dian lcof python3

> submit time: Wed Jul 21 01:07:46 UTC 2021

```python3
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        a, b = headA, headB
        while a != b:
            a = a.next if a != None else headB
            b = b.next if b != None else headA
        return a
```

### zai pai xu shu zu zhong cha zhao shu zi lcof rust

> submit time: Fri Jul 16 01:31:57 UTC 2021

```rust
impl Solution {

    pub fn search(nums: Vec<i32>, target: i32) -> i32 {
        let d = match nums.binary_search(&target) {
            Ok(i) => i as i32,
            _ => -1,
        };
        if d < 0 {
            return 0;
        }
        let d = d;
        let mut cnt = 0;
        {
            let mut left = 0;
            let mut right = d;
            while left <= right {
                let mid = left + (right - left) / 2;
                match nums[mid as usize].cmp(&target) {
                    std::cmp::Ordering::Less => left = mid + 1,
                    _ => right = mid - 1,
                }
            }
            cnt += d + 1 - left;
        }
        {
            let mut left = d;
            let mut right = nums.len()  as i32 - 1;
            while left <= right {
                let mid = left + (right - left) / 2;
                match nums[mid as usize].cmp(&target) {
                    std::cmp::Ordering::Greater => right = mid - 1,
                    _ => left = mid + 1,
                }
            }
            cnt += right - d;
        }
        cnt
    }
}
```

### group anagrams lcci rust

> submit time: Sun Jul 18 02:43:59 UTC 2021

```rust
impl Solution {

    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {
        let mut result: Vec<Vec<String>> = vec![];
        let mut m = vec![];
        for s in strs {
            let mut cs: Vec<u8> = s.clone().into_bytes().to_vec();
            cs.sort();
            let key = String::from_utf8(cs).unwrap();
            let a = m.iter().enumerate().filter(|&(_, x)| x == &key).next();
            if a.is_some() {
                let v = a.unwrap().0;
                let tmp = &mut result[v];
                tmp.push(s);
            } else {
                m.push(key);
                result.push(vec![s]);
            }
        }
        result
    }

}
```

### find majority element lcci rust

> submit time: Fri Jul 09 01:12:38 UTC 2021

```rust
impl Solution {
    
    pub fn majority_element(nums: Vec<i32>) -> i32 {
        let mut cur = 0;
        let mut vote = 0;
        for &i in &nums {
            if vote == 0 {
                cur = i;
            }
            if i == cur {
                vote += 1;
            } else {
                vote -= 1;
            }
        }
        let c = nums.iter().filter(|&x|cur.eq(x)).count();
        if c > nums.len() >> 1 {
            cur
        } else {
            -1
        }
    }
}
```

